//rotating and expanding cylinder animation
//with menu bar and dialog widget

//dialog to switch mouse control on and off


#include <stream.h>
#include <stdio.h>
#include <ctype.h>

#include <Xm/Xm.h>
#include <Xm/MainW.h>
#include <Xm/ToggleBG.h>
#include <Xm/RowColumn.h>
#include <Xm/Frame.h>
#include <Xm/PushB.h>
#include <Xm/CascadeB.h>
#include <Xm/MessageB.h>
#include <Xm/Form.h>
#include <Xm/Text.h>
#include <Xm/LabelG.h>
#include <Xm/PanedW.h>
#include <Xm/DialogS.h>
#include <Xm/PushBG.h>
#include <Xm/FileSB.h>

#include <Inventor/Xt/SoXt.h>
#include <Inventor/Xt/SoXtRenderArea.h>

#include <Inventor/SoDB.h>
#include <Inventor/nodes/SoTranslation.h>
#include <Inventor/nodes/SoScale.h>	
#include <Inventor/nodes/SoRotationXYZ.h>
#include <Inventor/nodes/SoCube.h>
#include <Inventor/nodes/SoCylinder.h>
#include <Inventor/nodes/SoSphere.h>
#include <Inventor/nodes/SoMaterial.h>
#include <Inventor/nodes/SoSeparator.h>
#include <Inventor/nodes/SoDrawStyle.h>
#include <Inventor/nodes/SoShapeHints.h>




#include <Inventor/Xt/viewers/SoXtExaminerViewer.h>
#include <Inventor/nodes/SoEnvironment.h>
#include <Inventor/sensors/SoTimerSensor.h>
#include <Inventor/sensors/SoTimerSensor.h>


SoSeparator *loadModel(char *name);

#define NUMBOIDS 40    // Number of boids.
#define UPDATEFPS 25   // Update rate of the boids (internally) in frames-per-second.

/* --- This is a good value for an Indy --- */
#define GRAPHICSFPS 4  // Update rate of the graphics in frames-per-second.

/* --- This is a good value if you have a Reality Engine, or if you are
       running the program remotely and displaying on an Indy.
#define GRAPHICSFPS 12  // Update rate of the graphics in frames-per-second.
--- */

//#define SPHERE      // Use the sphere as bounding object? If this is
		    // not defined, a rectangle will be used.

double RAD = 25;    // RAD of the bounding sphere of the world.

//---------------- Globals ---------------------------

//CIoSimulation *mySimulation;


Widget myWindow,myForm, theparent, thebar, theframe, thefilebutton,theviewbutton, theviewmenu, thefilemenu, thehelpmenu,helpbutton, quitbutton, viewcontrolbutton;
Widget playbutton,theplaymenu;
Widget     w,        *cascade_btns,help_dlg;
    int                num_btns;

/* The following help text information is a continuous stream of characters
** that will all be placed in a single ScrolledText object. If a specific
** newline is desired, you must do that yourself. See "index_help" below.
*/
String context_help[] = {
    "This is context-sensitive help. Well, not really, but such", 
    "help text could easily be generated by a real help system.",
    "All you really need to do is obtain information from the user",
    "about the widget from which he needs help, or perhaps prompt",
    "for other application-specific contexts.",
    NULL};

String window_help[] = {
    "Each of the windows in your application should have an",
    "XmNhelpCallback associated with it so you can monitor when",
    "the user presses the Help key over any particular widget.",
    "This is another way to provide context-sensitive help.",
    "The MenuBar should always have a Help entry at the far right",
    "that provides help for most aspects of the program, including",
    "the user interface. By providing different levels of help",
    "indexing, you can provide multiple stages of help, making the",
    "entire help system easier to use.",
    NULL};

String index_help[] = {
    "This is a small demonstration program, so there is very little",
    "material to provide an index. However, an index should contain",
    "a summary of the type of help available. For example, we have:\n",
    "    Help On Context\n",
    "    Help On Windows\n",
    "    This Index\n",
    "\n",
    "Higher-end applications might also provide a tutorial.",
    NULL};

String *help_texts[] = {context_help, window_help, index_help};



//Window theparent, thebar, theframe, thebutton, themenu, quitbutton;
SoXtExaminerViewer *myViewer;


SoSeparator *root;

SoNode * simobject;
SoMaterial *mat;
//SoTransform *tran;

//------------------Support Routines------------------------
int tog_mousemeth_item_set,tog_mousedim_item_set;

void toggled_mousemeth (Widget widget, XtPointer client_data, XtPointer call_data)
{
    int which = (int) client_data;
    XmToggleButtonCallbackStruct *state =
                        (XmToggleButtonCallbackStruct *) call_data;
    printf ("%s: %s\n", XtName (widget),
                    state->set == XmSET ? "on" : 
                    state->set == XmOFF ? "off" : "indeterminate");
    if (state->set == XmSET)
        tog_mousemeth_item_set = which;
    else
        tog_mousemeth_item_set = 0;
}

void toggled_mousedim (Widget widget, XtPointer client_data, XtPointer call_data)
{
    int which = (int) client_data;
    XmToggleButtonCallbackStruct *state =
                        (XmToggleButtonCallbackStruct *) call_data;
    printf ("%s: %s\n", XtName (widget),
                    state->set == XmSET ? "on" : 
                    state->set == XmOFF ? "off" : "indeterminate");
    if (state->set == XmSET)
        tog_mousedim_item_set = which;
    else
        tog_mousedim_item_set = 0;
}

static void
animateSimObjects(void *, SoSensor *) {

  // for (int i = 0; i < NUMSIMOBJECTS; i++) {
  //    mySimObjects[i]->updateGraphics();
  // }
}

static void
updateSimObjects(void *, SoSensor *) {

  static double elapsedTime = 0;
  
  SoCylinder *cyl =(SoCylinder *)simobject;
  cyl->radius =1.5+2*sin(elapsedTime);
  cyl->height =1.5+2*cos(elapsedTime);
  //for (int i = 0; i < NUMSIMOBJECTS; i++) {
   //   mySimObject[i]->update(elapsedTime);
   //}

  // increment elapsed time
  elapsedTime += 1.0/UPDATEFPS;
}

/* climb widget tree until we get to the top. Return the Shell */
Widget GetTopShell (Widget w)
{
    while (w && !XtIsWMShell (w))
    w = XtParent (w);
    return w;
}

/* The callback function for the "OK" button. Since this is not a 
** predefined Motif dialog, the "widget" parameter is not the dialog
** itself. That is only done by Motif dialog callbacks. Here in the
** real world, the callback routine is called directly by the widget
** that was invoked. Thus, we must pass the dialog as the client
** data to get its handle. (We could get it using GetTopShell(),
** but this way is quicker, since it's immediately available.)
*/
void DestroyShell (Widget widget, XtPointer client_data,
                   XtPointer call_data)
{
    Widget shell = (Widget) client_data;
    XtDestroyWidget (shell);
}



/*Callback for quit button*/
void quitbutton_func(Widget w, XtPointer client_data, XtPointer call_data)
{
	printf("Quit button selected, terminating program.");
	exit(0);		
}

void widgetcancel_cb(Widget w, XtPointer client_data, XtPointer call_data)
{
 XtUnmanageChild(w);
 //XtDestroyWidget (w);	
}

void loadsimulation_cb (Widget w, XtPointer client_data, XtPointer call_data)
{
    char *filename;
    XmFileSelectionBoxCallbackStruct *cbs =
                        (XmFileSelectionBoxCallbackStruct *) call_data;

    filename = (char *) XmStringUnparse (cbs->value,
                                         XmFONTLIST_DEFAULT_TAG,
                                         XmCHARSET_TEXT,
                                         XmCHARSET_TEXT,
                                         NULL, 0, XmOUTPUT_ALL);
    if (!filename)
        /* must have been an internal error */
        return;
    if (!*filename) {
        /* nothing typed? */
        puts ("No file selected.");
        /* even "" is an allocated byte */
        XtFree (filename);
        return;
    }
    printf ("Filename given: \"%s\"\n", filename);
    XtFree (filename);
	
}


void fileopen_cb(Widget w, XtPointer client_data, XtPointer call_data)
{
	Widget dialog, remove;
	XmString mask;
	Arg args[1];
	
	/*Create file selection dalog*/
	mask=XmStringCreateLocalized("*.xml");
	XtSetArg(args[0], XmNdirMask, mask);
	printf ("Creating fs dialog\n");
	dialog=XmCreateFileSelectionDialog(w, "select", args, 1);
	
	//remove=XmSelectionBoxGetChild(dialog, XmDIALOG_HELP_BUTTON);
	//XtUnmanageChild(remove);
	
	XtAddCallback(dialog, XmNokCallback,loadsimulation_cb,NULL);
	XtAddCallback(dialog, XmNcancelCallback,widgetcancel_cb,NULL);
	
	XtManageChild(dialog);
	XtPopup(XtParent(dialog), XtGrabNone);
}




/* callback for all the entries in the File pulldown menu. */
void file_cb (Widget w, XtPointer client_data, XtPointer call_data)
{
    int item_no = (int) client_data;
    if (item_no == 2)
        /* the Quit menu button */
        exit (0);
    if (item_no == 1)
    {
    	printf ("File open Item %d (%s) selected\n", item_no + 1, XtName (w));
        /* the File open menu button */
        //fileopen_cb(w,client_data,call_data);
    }    
    printf ("Item %d (%s) selected\n", item_no + 1, XtName (w));
}



/* callback for all the entries in the File pulldown menu. */
void play_cb (Widget w, XtPointer client_data, XtPointer call_data)
{
    int item_no = (int) client_data;
    if (item_no == 2)
        /* the Quit menu button */
        exit (0);
    printf ("Item %d (%s) selected\n", item_no + 1, XtName (w));
}








void help_cb (Widget w, XtPointer client_data, XtPointer call_data)
{
    Widget       help_dialog, pane, text_w, form, sep, widget, label;
    void         DestroyShell(Widget, XtPointer, XtPointer);
	//Pixel        fg, bg;
	//Pixmap       pixmap;

    Arg          args[10];
    int          n = 0;
    int          i;
    char         *p, buf[BUFSIZ];
    int          item_no = (int) client_data; 
    Dimension    h;
    /* Set up a DialogShell as a popup window. Set the delete
    ** window protocol response to XmDESTROY to make sure that
    ** the window goes away appropriately. Otherwise, it's XmUNMAP
    ** which means it'd be lost forever, since we're not storing
    ** the widget globally or statically to this function. 
    */
    i = 0;
    XtSetArg (args[i], XmNdeleteResponse, XmDESTROY); 
    i++;
    help_dialog = XmCreateDialogShell ( GetTopShell(w), "Help", args, i);

    /* Create a PanedWindow to manage the stuff in this dialog. */
    /* PanedWindow won't let us set these to 0! */
    XtSetArg (args[0], XmNsashWidth, 1);    
    /* Make small so user doesn't try to resize */ 
    XtSetArg (args[1], XmNsashHeight, 1);    
    pane = XmCreatePanedWindow (help_dialog, "pane", args, 2);
    /* Create a RowColumn in the form for Label and Text widgets.
    ** This is the control area. 
    */
    form = XmCreateForm (pane, "form1", NULL, 0);
    //XtVaGetValues (form, /* once created, we can get its colors */
    //               XmNforeground, &fg,
    //               XmNbackground, &bg,
     //              NULL);
    /* create the pixmap of the appropriate depth using the colors 
    ** that will be used by the parent (form). 
    */
    /*pixmap = XCreatePixmapFromBitmapData (XtDisplay (form),
    RootWindowOfScreen (XtScreen (form)),
                        (char *) info_bits, info_width, info_height,
                        fg, bg,
                        DefaultDepthOfScreen (XtScreen (form)));*/
    /* Create a label gadget using this pixmap */
    n = 0;
    //XtSetArg (args[n], XmNlabelType,        XmPIXMAP);      n++;
    //XtSetArg (args[n], XmNlabelPixmap,      pixmap);        n++;
    XtSetArg (args[n], XmNleftAttachment,   XmATTACH_FORM); n++;
    XtSetArg (args[n], XmNtopAttachment,    XmATTACH_FORM); n++;
    XtSetArg (args[n], XmNbottomAttachment, XmATTACH_FORM); n++;
    label = XmCreateLabelGadget (form, "label", args, n);
    XtManageChild (label); 
    /* prepare the text for display in the ScrolledText object 
    ** we are about to create. 
    */
    for (p = buf, i = 0; help_texts[item_no][i]; i++) {
        p += strlen (strcpy (p, help_texts[item_no][i]));
        if (!isspace (p[-1]))
        /* spaces, tabs and newlines are spaces. */
            *p++ = ' '; /* lines are concatenated together, insert space */
    }
    *--p = 0; /* get rid of trailing space... */
    n = 0;
    XtSetArg (args[n], XmNscrollVertical,        True);              n++;
    XtSetArg (args[n], XmNscrollHorizontal,      False);             n++;
    XtSetArg (args[n], XmNeditMode,              XmMULTI_LINE_EDIT); n++;
    XtSetArg (args[n], XmNeditable,              False);             n++;
    XtSetArg (args[n], XmNcursorPositionVisible, False);             n++;
    XtSetArg (args[n], XmNwordWrap,              True);              n++;
    XtSetArg (args[n], XmNvalue,                 buf);               n++;
    XtSetArg (args[n], XmNrows,                  5);                 n++;
    text_w = XmCreateScrolledText (form, "help_text", args, n);
    /* Attachment values must be set on the Text widget's PARENT, 
    ** the ScrolledWindow. This is the object that is positioned. 
    */ 
    XtVaSetValues (XtParent (text_w),
                   XmNleftAttachment,   XmATTACH_WIDGET,
                   XmNleftWidget,       label,
                   XmNtopAttachment,    XmATTACH_FORM,
                   XmNrightAttachment,  XmATTACH_FORM,
                   XmNbottomAttachment, XmATTACH_FORM,
                   NULL);
    XtManageChild (text_w);
    XtManageChild (form);
    /* Create another form to act as the action area for the dialog */
    XtSetArg (args[0], XmNfractionBase, 5);
    form = XmCreateForm (pane, "form2", args, 1);
    /* The OK button is under the pane's separator and is 
    ** attached to the left edge of the form. It spreads from
    ** position 0 to 1 along the bottom (the form is split into 
    ** 5 separate grids via XmNfractionBase upon creation). 
    */
    widget = XmCreatePushButtonGadget (form, "OK", NULL, 0);
    XtVaSetValues (widget,
                   XmNtopAttachment,                XmATTACH_FORM,  
                   XmNbottomAttachment,             XmATTACH_FORM,   
                   XmNleftAttachment,               XmATTACH_POSITION,  
                   XmNleftPosition,                 1, 
                   XmNrightAttachment,              XmATTACH_POSITION, 
                   XmNrightPosition,                2, 
                   XmNshowAsDefault,                True,
                   XmNdefaultButtonShadowThickness, 1,
                   NULL);
    XtManageChild (widget);
    XtAddCallback (widget, XmNactivateCallback, DestroyShell,
                   (XtPointer) help_dialog);
    /* This is created with its XmNsensitive resource set to False 
    ** because we don't support "more" help. However, this is the 
    ** place to attach it to if there were any more. 
    */
    widget = XmCreatePushButtonGadget (form, "More", NULL, 0);
    XtVaSetValues (widget,
                   XmNsensitive,                    False, 
                   XmNtopAttachment,                XmATTACH_FORM,
                   XmNbottomAttachment,             XmATTACH_FORM,
                   XmNleftAttachment,               XmATTACH_POSITION,
                   XmNleftPosition,                 3,
                   XmNrightAttachment,              XmATTACH_POSITION,
                   XmNrightPosition,                4,
                   XmNshowAsDefault,                False,
                   XmNdefaultButtonShadowThickness, 1,
                   NULL);
    XtManageChild (widget);
    /* Fix the action area pane to its current height -- never let it resize */
    XtManageChild (form);
    XtVaGetValues (widget, XmNheight, &h, NULL);
    XtVaSetValues (form, XmNpaneMaximum, h, XmNpaneMinimum, h, NULL);
    /* This also pops up the dialog, as it is the child of a DialogShell */
    XtManageChild (pane);
}






void view_cb (Widget w, XtPointer client_data, XtPointer call_data)
{
    Widget       help_dialog, pane, text_w, form, sep, widget, label;
    Widget         mm_radio_box, mmtrans, mmrot, mmsca, mmoff;
    Widget         form2,md_radio_box, mdxy, mdyz, mdxz;
    
    void         DestroyShell(Widget, XtPointer, XtPointer);
	//Pixel        fg, bg;
	//Pixmap       pixmap;

    Arg          args[10];
    int          n = 0;
    int          i;
    char         *p, buf[BUFSIZ];
    int          item_no = (int) client_data; 
    Dimension    h;
    /* Set up a DialogShell as a popup window. Set the delete
    ** window protocol response to XmDESTROY to make sure that
    ** the window goes away appropriately. Otherwise, it's XmUNMAP
    ** which means it'd be lost forever, since we're not storing
    ** the widget globally or statically to this function. 
    */
    i = 0;
    XtSetArg (args[i], XmNdeleteResponse, XmDESTROY); 
    i++;
    help_dialog = XmCreateDialogShell ( GetTopShell(w), "MouseViewControl", args, i);

    /* Create a PanedWindow to manage the stuff in this dialog. */
    /* PanedWindow won't let us set these to 0! */
    XtSetArg (args[0], XmNsashWidth, 1);    
    /* Make small so user doesn't try to resize */ 
    XtSetArg (args[1], XmNsashHeight, 1);    
    pane = XmCreatePanedWindow (help_dialog, "pane", args, 2);
    /* Create a RowColumn in the form for Label and Text widgets.
    ** This is the control area. 
    */
    form = XmCreateForm (pane, "form1", NULL, 0);
    form2 = XmCreateForm (pane, "form2", NULL, 0);
    //XtVaGetValues (form, /* once created, we can get its colors */
    //               XmNforeground, &fg,
    //               XmNbackground, &bg,
     //              NULL);
    /* create the pixmap of the appropriate depth using the colors 
    ** that will be used by the parent (form). 
    */
    /*pixmap = XCreatePixmapFromBitmapData (XtDisplay (form),
    RootWindowOfScreen (XtScreen (form)),
                        (char *) info_bits, info_width, info_height,
                        fg, bg,
                        DefaultDepthOfScreen (XtScreen (form)));*/
    /* Create a label gadget using this pixmap */
    n = 0;
    //XtSetArg (args[n], XmNlabelType,        XmPIXMAP);      n++;
    //XtSetArg (args[n], XmNlabelPixmap,      pixmap);        n++;
    XtSetArg (args[n], XmNleftAttachment,   XmATTACH_FORM); n++;
    XtSetArg (args[n], XmNtopAttachment,    XmATTACH_FORM); n++;
    XtSetArg (args[n], XmNbottomAttachment, XmATTACH_FORM); n++;
    label = XmCreateLabelGadget (form, "label", args, n);
    XtManageChild (label); 
    /* prepare the text for display in the ScrolledText object 
    ** we are about to create. 
    */
    for (p = buf, i = 0; help_texts[item_no][i]; i++) {
        p += strlen (strcpy (p, help_texts[item_no][i]));
        if (!isspace (p[-1]))
        /* spaces, tabs and newlines are spaces. */
            *p++ = ' '; /* lines are concatenated together, insert space */
    }
    *--p = 0; /* get rid of trailing space... */
    n = 0;
    XtSetArg (args[n], XmNscrollVertical,        True);              n++;
    XtSetArg (args[n], XmNscrollHorizontal,      False);             n++;
    XtSetArg (args[n], XmNeditMode,              XmMULTI_LINE_EDIT); n++;
    XtSetArg (args[n], XmNeditable,              False);             n++;
    XtSetArg (args[n], XmNcursorPositionVisible, False);             n++;
    XtSetArg (args[n], XmNwordWrap,              True);              n++;
    XtSetArg (args[n], XmNvalue,                 buf);               n++;
    XtSetArg (args[n], XmNrows,                  5);                 n++;
 
 mm_radio_box = XmCreateRadioBox (form, "Mouse method radio_box", NULL, 0);

    mmtrans = XmCreateToggleButtonGadget (mm_radio_box, "Translation", NULL, 0);
    XtAddCallback (mmtrans, XmNvalueChangedCallback, toggled_mousemeth, (XtPointer) 1);
    XtManageChild (mmtrans);

    mmrot = XmCreateToggleButtonGadget (mm_radio_box, "Rotation", NULL, 0);
    XtAddCallback (mmrot, XmNvalueChangedCallback, toggled_mousemeth, (XtPointer) 2);
    XtManageChild (mmrot);

    mmsca = XmCreateToggleButtonGadget (mm_radio_box, "Scale", NULL, 0);
    XtAddCallback (mmsca, XmNvalueChangedCallback, toggled_mousemeth, (XtPointer) 3);
    XtManageChild (mmsca);

    mmoff = XmCreateToggleButtonGadget (mm_radio_box, "Off", NULL, 0);
    XtAddCallback (mmoff, XmNvalueChangedCallback, toggled_mousemeth, (XtPointer) 4);
    XtManageChild (mmoff);


    XtManageChild (mm_radio_box);
    

md_radio_box = XmCreateRadioBox (form2, "Mouse Dimension radio_box", NULL, 0);

    mdxy = XmCreateToggleButtonGadget (md_radio_box, "xy", NULL, 0);
    XtAddCallback (mdxy, XmNvalueChangedCallback, toggled_mousedim, (XtPointer) 1);
    XtManageChild (mdxy);

    mdyz = XmCreateToggleButtonGadget (md_radio_box, "yx", NULL, 0);
    XtAddCallback (mdyz, XmNvalueChangedCallback, toggled_mousedim, (XtPointer) 2);
    XtManageChild (mdyz);

    mdxz = XmCreateToggleButtonGadget (md_radio_box, "xz", NULL, 0);
    XtAddCallback (mdxz, XmNvalueChangedCallback, toggled_mousedim, (XtPointer) 3);
    XtManageChild (mdxz);



    XtManageChild (md_radio_box);
 
 
    
    XtManageChild (form);
    XtManageChild (form2);
    
    
    
    
    /* Create another form to act as the action area for the dialog */
    XtSetArg (args[0], XmNfractionBase, 5);
    form = XmCreateForm (pane, "form2", args, 1);
    /* The OK button is under the pane's separator and is 
    ** attached to the left edge of the form. It spreads from
    ** position 0 to 1 along the bottom (the form is split into 
    ** 5 separate grids via XmNfractionBase upon creation). 
    */
    widget = XmCreatePushButtonGadget (form, "OK", NULL, 0);
    XtVaSetValues (widget,
                   XmNtopAttachment,                XmATTACH_FORM,  
                   XmNbottomAttachment,             XmATTACH_FORM,   
                   XmNleftAttachment,               XmATTACH_POSITION,  
                   XmNleftPosition,                 1, 
                   XmNrightAttachment,              XmATTACH_POSITION, 
                   XmNrightPosition,                2, 
                   XmNshowAsDefault,                True,
                   XmNdefaultButtonShadowThickness, 1,
                   NULL);
    XtManageChild (widget);
    XtAddCallback (widget, XmNactivateCallback, DestroyShell,
                   (XtPointer) help_dialog);
    /* This is created with its XmNsensitive resource set to False 
    ** because we don't support "more" help. However, this is the 
    ** place to attach it to if there were any more. 
    */
    widget = XmCreatePushButtonGadget (form, "More", NULL, 0);
    XtVaSetValues (widget,
                   XmNsensitive,                    False, 
                   XmNtopAttachment,                XmATTACH_FORM,
                   XmNbottomAttachment,             XmATTACH_FORM,
                   XmNleftAttachment,               XmATTACH_POSITION,
                   XmNleftPosition,                 3,
                   XmNrightAttachment,              XmATTACH_POSITION,
                   XmNrightPosition,                4,
                   XmNshowAsDefault,                False,
                   XmNdefaultButtonShadowThickness, 1,
                   NULL);
    XtManageChild (widget);
    /* Fix the action area pane to its current height -- never let it resize */
    XtManageChild (form);
    XtVaGetValues (widget, XmNheight, &h, NULL);
    XtVaSetValues (form, XmNpaneMaximum, h, XmNpaneMinimum, h, NULL);
    /* This also pops up the dialog, as it is the child of a DialogShell */
    XtManageChild (pane);
}



/* callback for all the entries in the File pulldown menu. */
void help_menu_cb (Widget w, XtPointer client_data, XtPointer call_data)
{
    int item_no = (int) client_data;
    if (item_no == 1)
        /* the Quit menu button */
        help_cb(w, client_data, call_data);
    printf ("Item %d (%s) selected\n", item_no + 1, XtName (w));
}

void
setUpGraphics(void) {

   XmString           str1, str2, str3,str4;
   myWindow = SoXt::init("SimViewer");
   if (myWindow == NULL) {
     cerr << "myWindow is null. bye!\n";
     exit(1); 
   }

   root = new SoSeparator;
   root->ref();

   
   SoEnvironment *Env = new SoEnvironment;
   Env->ambientIntensity.setValue(.5);
   root->addChild(Env);

    myForm = XtCreateWidget("Form", xmFormWidgetClass, myWindow, NULL, 0);

    str1 = XmStringCreateLocalized ("File");
    str4 = XmStringCreateLocalized ("Help");
    str2 = XmStringCreateLocalized ("View");
    str3 = XmStringCreateLocalized ("Play");
    thebar = XmVaCreateSimpleMenuBar (myForm, "MenuBar",
                                       XmVaCASCADEBUTTON, str1, 'F',
                                       XmVaCASCADEBUTTON, str2, 'V',
                                       XmVaCASCADEBUTTON, str3, 'P',
                                       XmVaCASCADEBUTTON, str4, 'H',
                                       NULL);

 
 	XmStringFree (str1);
    XmStringFree (str2);
    XmStringFree (str3); 
    XmStringFree (str4); 
    /* create the "File" pulldown menu -- callback is file_cb() */
    str1 = XmStringCreateLocalized ("New");
    str2 = XmStringCreateLocalized ("Open");
    str3 = XmStringCreateLocalized ("Quit");
    thefilemenu=XmVaCreateSimplePulldownMenu (thebar, "file_menu", 0, file_cb, 
                                  XmVaPUSHBUTTON, str1, 'N', NULL, NULL, 
                                  XmVaPUSHBUTTON, str2, 'O', NULL, NULL,
                                  XmVaSEPARATOR,
                                  XmVaPUSHBUTTON, str3, 'Q', NULL, NULL,
                                  NULL);
    XmStringFree (str1);
    XmStringFree (str2);
    XmStringFree (str3);
    
    str1 = XmStringCreateLocalized ("ReadConfig");
    str2 = XmStringCreateLocalized ("PlayFileList");
    str3 = XmStringCreateLocalized ("VideoFileList");
    str4 = XmStringCreateLocalized ("SaveViewImage");
    
    theplaymenu=XmVaCreateSimplePulldownMenu (thebar, "play_menu", 2, play_cb, 
                                  XmVaPUSHBUTTON, str1, 'R', NULL, NULL, 
                                  XmVaPUSHBUTTON, str2, 'P', NULL, NULL,
                                  XmVaPUSHBUTTON, str3, 'V', NULL, NULL,
                                 XmVaPUSHBUTTON, str4, 'S', NULL, NULL,
                                  NULL);
    XmStringFree (str1);
    XmStringFree (str2);
    XmStringFree (str3);    
    XmStringFree (str4);    
    
    
    
    /* create the "Help" menu -- callback is help_cb() */
    str1 = XmStringCreateLocalized ("On Context");
    str2 = XmStringCreateLocalized ("On Window");
    str3 = XmStringCreateLocalized ("Index");
    thehelpmenu = XmVaCreateSimplePulldownMenu (thebar, "help_menu", 3, help_menu_cb,
                                      XmVaPUSHBUTTON, str1, 'C', NULL, NULL,
                                      XmVaPUSHBUTTON, str2, 'W', NULL, NULL,
                                      XmVaPUSHBUTTON, str3, 'I', NULL, NULL,
                                      NULL);
    XmStringFree (str1);
    XmStringFree (str2);
    XmStringFree (str3);

    /* create the "File" pulldown menu -- callback is file_cb() */
    str1 = XmStringCreateLocalized ("MouseControl");
    theviewmenu=XmVaCreateSimplePulldownMenu (thebar, "view_menu", 1, view_cb, 
                                  XmVaPUSHBUTTON, str1, 'M', NULL, NULL, 
                                  NULL);
    XmStringFree (str1);
    
    /* Identify the Help Menu for the MenuBar */
    XtVaGetValues (thebar, XmNchildren, &cascade_btns, XmNnumChildren, 
                    &num_btns, NULL);
    XtVaSetValues (thebar, XmNmenuHelpWidget, cascade_btns[num_btns-1], 
                   NULL);

    XtManageChild(thebar);
    theframe=XtVaCreateManagedWidget("theframe", xmFrameWidgetClass, myForm, NULL);
   	
   	//thefilebutton=XtVaCreateManagedWidget("thefilebutton",xmCascadeButtonWidgetClass,thebar,NULL);
   	//theviewbutton=XtVaCreateManagedWidget("theviewbutton",xmCascadeButtonWidgetClass,thebar,NULL);
   	
   	//thefilemenu=XmCreatePulldownMenu(thebar, "file", NULL, 0);
   	//theviewmenu=XmCreatePulldownMenu(thebar, "view", NULL, 0);
   	playbutton=XtVaCreateManagedWidget("playbutton", xmPushButtonWidgetClass, theplaymenu, NULL);
   	thefilebutton=XtVaCreateManagedWidget("fileopenbutton", xmPushButtonWidgetClass, thefilemenu, NULL);
   	
   	quitbutton=XtVaCreateManagedWidget("quitbutton", xmPushButtonWidgetClass, thefilemenu, NULL);
   	helpbutton=XtVaCreateManagedWidget("helpbutton", xmPushButtonWidgetClass, thehelpmenu, NULL);
    viewcontrolbutton=XtVaCreateManagedWidget("viewcontrolbutton", xmPushButtonWidgetClass, theviewmenu, NULL);
   	
   	//XtVaSetValues(thefilebutton, XmNsubMenuId, thefilemenu, NULL);
   	//XtVaSetValues(thehelpbutton, XmNsubMenuId, thehelpmenu, NULL);   	
   	XtAddCallback(quitbutton, XmNactivateCallback, quitbutton_func, 0);
   	XtAddCallback(helpbutton, XmNactivateCallback, help_cb, 0);
   	XtAddCallback(viewcontrolbutton, XmNactivateCallback, view_cb, 0);
   	XtAddCallback(thefilebutton, XmNactivateCallback, fileopen_cb, 0);
   	
     
 
 
   
   // Set up viewer:
   //myViewer = new SoXtExaminerViewer(myWindow);
   myViewer = new SoXtExaminerViewer(theframe);
   //myViewer->setDrawStyle(SoXtViewer::STILL, SoXtViewer::VIEW_LINE);
   myViewer->setSize(SbVec2s(600, 450)); 
   myViewer->setTitle("SimViewer");
   myViewer->setTransparencyType(SoGLRenderAction::DELAYED_ADD);
   myViewer->setSceneGraph(root);
   myViewer->setHeadlight(TRUE);
   
   	XmMainWindowSetAreas(myWindow,myForm, theframe,  NULL, NULL, NULL);

 
   myViewer->show();
   
    //layout components in form
   Arg args[8];
   XtSetArg(args[0], XmNtopAttachment, XmATTACH_WIDGET);
   XtSetArg(args[1], XmNbottomAttachment, XmATTACH_FORM);
   XtSetArg(args[2], XmNleftAttachment, XmATTACH_FORM);
   XtSetArg(args[3], XmNrightAttachment, XmATTACH_FORM);
   //XtSetArg(args[4], XmNrightPosition, 40);
   
   XtSetValues(theframe,args,4);
   
   XtSetArg(args[0], XmNtopAttachment, XmATTACH_FORM);
   XtSetArg(args[1], XmNbottomAttachment, XmATTACH_WIDGET); 
   //XtSetArg(args[2], XmNrightAttachment, XmATTACH_FORM);
   //XtSetArg(args[1], XmNleftAttachment, XmATTACH_FORM);
   //XtSetArg(args[4], XmNleftPosition, 41);  
   XtSetValues(myForm,args,2);   
   SoXt::show(myForm);  
   SoXt::show(myWindow);

}


void
makeScenery(void) {

  // Make a subgraph for the boundary obstacle
  SoSeparator *boundary = new SoSeparator;
  SoMaterial *m =  new SoMaterial;
  m->transparency.setValue(.9);
  m->ambientColor.setValue(1, 1, 1);
  boundary->addChild(m);

  // Make a subgraph for the other obstacles
  SoSeparator *r = new SoSeparator;
  r->addChild(boundary);
  SoMaterial *m2 =  new SoMaterial;
  m2->ambientColor.setValue(0, 0, 1);
  m2->diffuseColor.setValue(0, 0, 1);
  m2->specularColor.setValue(.5, .5, .5);
  m2->shininess.setValue(0.2);
  r->addChild(m2);

  root->addChild(r);

}

void
setupUpdateCallbacks() {

  SoTimerSensor *updateTimer = new SoTimerSensor(updateSimObjects, NULL);
  updateTimer->setInterval(1.0/UPDATEFPS);
  updateTimer->schedule(); 

  SoTimerSensor *graphicsTimer = new SoTimerSensor(animateSimObjects, NULL);
  graphicsTimer->setInterval(1.0/GRAPHICSFPS);
  graphicsTimer->schedule(); 

}

bool
makeConfig(void) {
      
 
    simobject = new SoCylinder;
  mat =  new SoMaterial;
  mat->transparency.setValue(.9);
  mat->ambientColor.setValue(0.3, 1, 0.8);
      
    root->addChild(simobject);
    root->addChild(mat);
    return TRUE;
}


//----------------Simulation Routines-----------------------

void
initSimulation(char *simfilename, char *sceneryfile) {
  
  setUpGraphics();
  
  cerr << "Graphics set up\n";

  if (makeConfig() == FALSE)
     cerr << "\nmakeConfig() returned an error\n";
  
  cerr << "Made config\n";
  
  makeScenery();

  cerr << "Scenery set up\n";

  // Set up an asynchronous callback to update boids.
  setupUpdateCallbacks();

}

int
main (int argc, char **argv) {

  initSimulation(argv[1], argv[2]);
  
  myViewer->viewAll(); 
  SoXt::mainLoop();

  // This will never be reached, but it stops compiler warnings.
  return 0;
}
