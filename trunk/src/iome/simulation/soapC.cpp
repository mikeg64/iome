/* soapC.cpp
   Generated by gSOAP 2.7.6e from IoSteerWS.h
   Copyright (C) 2000-2005, Robert van Engelen, Genivia Inc. All Rights Reserved.
   This part of the software is released under one of the following licenses:
   GPL, the gSOAP public license, or Genivia's license for commercial use.
*/

#include "soapH.h"

SOAP_SOURCE_STAMP("@(#) soapC.cpp ver 2.7.6e 2009-11-04 07:13:17 GMT")


#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serializeheader(struct soap *soap)
{
	if (soap->header)
		soap_serialize_SOAP_ENV__Header(soap, soap->header);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_putheader(struct soap *soap)
{
	if (soap->header)
	{	soap->part = SOAP_IN_HEADER;
		soap_out_SOAP_ENV__Header(soap, "SOAP-ENV:Header", 0, soap->header, NULL);
		soap->part = SOAP_END_HEADER;
	}
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_getheader(struct soap *soap)
{
	soap->part = SOAP_IN_HEADER;
	soap->header = soap_in_SOAP_ENV__Header(soap, "SOAP-ENV:Header", NULL, NULL);
	soap->part = SOAP_END_HEADER;
	return soap->header == NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_fault(struct soap *soap)
{
	if (!soap->fault)
	{	soap->fault = (struct SOAP_ENV__Fault*)soap_malloc(soap, sizeof(struct SOAP_ENV__Fault));
		soap_default_SOAP_ENV__Fault(soap, soap->fault);
	}
	if (soap->version == 2 && !soap->fault->SOAP_ENV__Code)
	{	soap->fault->SOAP_ENV__Code = (struct SOAP_ENV__Code*)soap_malloc(soap, sizeof(struct SOAP_ENV__Code));
		soap_default_SOAP_ENV__Code(soap, soap->fault->SOAP_ENV__Code);
	}
	if (soap->version == 2 && !soap->fault->SOAP_ENV__Reason)
	{	soap->fault->SOAP_ENV__Reason = (struct SOAP_ENV__Reason*)soap_malloc(soap, sizeof(struct SOAP_ENV__Reason));
		soap_default_SOAP_ENV__Reason(soap, soap->fault->SOAP_ENV__Reason);
	}
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serializefault(struct soap *soap)
{
	if (soap->fault)
		soap_serialize_SOAP_ENV__Fault(soap, soap->fault);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_putfault(struct soap *soap)
{
	if (soap->fault)
		return soap_put_SOAP_ENV__Fault(soap, soap->fault, "SOAP-ENV:Fault", NULL);
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_getfault(struct soap *soap)
{
	return (soap->fault = soap_get_SOAP_ENV__Fault(soap, NULL, "SOAP-ENV:Fault", NULL)) == NULL;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultcode(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
		return (const char**)&soap->fault->SOAP_ENV__Code->SOAP_ENV__Value;
	return (const char**)&soap->fault->faultcode;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultsubcode(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
	{	if (!soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode)
		{	soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode = (struct SOAP_ENV__Code*)soap_malloc(soap, sizeof(struct SOAP_ENV__Code));
			soap_default_SOAP_ENV__Code(soap, soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode);
		}
		return (const char**)&soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode->SOAP_ENV__Value;
	}
	return (const char**)&soap->fault->faultcode;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultstring(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
		return (const char**)&soap->fault->SOAP_ENV__Reason->SOAP_ENV__Text;
	return (const char**)&soap->fault->faultstring;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultdetail(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 1)
	{	if (!soap->fault->detail)
		{	soap->fault->detail = (struct SOAP_ENV__Detail*)soap_malloc(soap, sizeof(struct SOAP_ENV__Detail));
			soap_default_SOAP_ENV__Detail(soap, soap->fault->detail);
		}
		return (const char**)&soap->fault->detail->__any;
	}
	if (!soap->fault->SOAP_ENV__Detail)
	{	soap->fault->SOAP_ENV__Detail = (struct SOAP_ENV__Detail*)soap_malloc(soap, sizeof(struct SOAP_ENV__Detail));
		soap_default_SOAP_ENV__Detail(soap, soap->fault->SOAP_ENV__Detail);
	}
	return (const char**)&soap->fault->SOAP_ENV__Detail->__any;
}

#endif

#ifndef WITH_NOIDREF
SOAP_FMAC3 int SOAP_FMAC4 soap_getindependent(struct soap *soap)
{
	int t;
	for (;;)
		if (!soap_getelement(soap, &t))
			if (soap->error || soap_ignore_element(soap))
				break;
	if (soap->error == SOAP_NO_TAG || soap->error == SOAP_EOF)
		soap->error = SOAP_OK;
	return soap->error;
}
#endif

#ifndef WITH_NOIDREF
SOAP_FMAC3 void * SOAP_FMAC4 soap_getelement(struct soap *soap, int *type)
{
	if (soap_peek_element(soap))
		return NULL;
	if (!*soap->id || !(*type = soap_lookup_type(soap, soap->id)))
		*type = soap_lookup_type(soap, soap->href);
	switch (*type)
	{
	case SOAP_TYPE_byte:
		return soap_in_byte(soap, NULL, NULL, "xsd:byte");
	case SOAP_TYPE_int:
		return soap_in_int(soap, NULL, NULL, "xsd:int");
	case SOAP_TYPE_double:
		return soap_in_double(soap, NULL, NULL, "xsd:double");
	case SOAP_TYPE_ns__setgroupbarrier:
		return soap_in_ns__setgroupbarrier(soap, NULL, NULL, "ns:setgroupbarrier");
	case SOAP_TYPE_ns__setgroupbarrierResponse:
		return soap_in_ns__setgroupbarrierResponse(soap, NULL, NULL, "ns:setgroupbarrierResponse");
	case SOAP_TYPE_ns__testgroupbarrier:
		return soap_in_ns__testgroupbarrier(soap, NULL, NULL, "ns:testgroupbarrier");
	case SOAP_TYPE_ns__testgroupbarrierResponse:
		return soap_in_ns__testgroupbarrierResponse(soap, NULL, NULL, "ns:testgroupbarrierResponse");
	case SOAP_TYPE_ns__getobjnum:
		return soap_in_ns__getobjnum(soap, NULL, NULL, "ns:getobjnum");
	case SOAP_TYPE_ns__getobjnumResponse:
		return soap_in_ns__getobjnumResponse(soap, NULL, NULL, "ns:getobjnumResponse");
	case SOAP_TYPE_ns__getnumobj:
		return soap_in_ns__getnumobj(soap, NULL, NULL, "ns:getnumobj");
	case SOAP_TYPE_ns__getnumobjResponse:
		return soap_in_ns__getnumobjResponse(soap, NULL, NULL, "ns:getnumobjResponse");
	case SOAP_TYPE_ns__listparam:
		return soap_in_ns__listparam(soap, NULL, NULL, "ns:listparam");
	case SOAP_TYPE_ns__listparamResponse:
		return soap_in_ns__listparamResponse(soap, NULL, NULL, "ns:listparamResponse");
	case SOAP_TYPE_ns__deleteparam:
		return soap_in_ns__deleteparam(soap, NULL, NULL, "ns:deleteparam");
	case SOAP_TYPE_ns__deleteparamResponse:
		return soap_in_ns__deleteparamResponse(soap, NULL, NULL, "ns:deleteparamResponse");
	case SOAP_TYPE_ns__deletemetadata:
		return soap_in_ns__deletemetadata(soap, NULL, NULL, "ns:deletemetadata");
	case SOAP_TYPE_ns__deletemetadataResponse:
		return soap_in_ns__deletemetadataResponse(soap, NULL, NULL, "ns:deletemetadataResponse");
	case SOAP_TYPE_ns__listmetadata:
		return soap_in_ns__listmetadata(soap, NULL, NULL, "ns:listmetadata");
	case SOAP_TYPE_ns__listmetadataResponse:
		return soap_in_ns__listmetadataResponse(soap, NULL, NULL, "ns:listmetadataResponse");
	case SOAP_TYPE_ns__setmetadata:
		return soap_in_ns__setmetadata(soap, NULL, NULL, "ns:setmetadata");
	case SOAP_TYPE_ns__setmetadataResponse:
		return soap_in_ns__setmetadataResponse(soap, NULL, NULL, "ns:setmetadataResponse");
	case SOAP_TYPE_ns__setparammmat3d:
		return soap_in_ns__setparammmat3d(soap, NULL, NULL, "ns:setparammmat3d");
	case SOAP_TYPE_ns__setparammmat3dResponse:
		return soap_in_ns__setparammmat3dResponse(soap, NULL, NULL, "ns:setparammmat3dResponse");
	case SOAP_TYPE_ns__setparamstring:
		return soap_in_ns__setparamstring(soap, NULL, NULL, "ns:setparamstring");
	case SOAP_TYPE_ns__setparamstringResponse:
		return soap_in_ns__setparamstringResponse(soap, NULL, NULL, "ns:setparamstringResponse");
	case SOAP_TYPE_ns__setparammat:
		return soap_in_ns__setparammat(soap, NULL, NULL, "ns:setparammat");
	case SOAP_TYPE_ns__setparammatResponse:
		return soap_in_ns__setparammatResponse(soap, NULL, NULL, "ns:setparammatResponse");
	case SOAP_TYPE_ns__setparamvec:
		return soap_in_ns__setparamvec(soap, NULL, NULL, "ns:setparamvec");
	case SOAP_TYPE_ns__setparamvecResponse:
		return soap_in_ns__setparamvecResponse(soap, NULL, NULL, "ns:setparamvecResponse");
	case SOAP_TYPE_ns__setparamint:
		return soap_in_ns__setparamint(soap, NULL, NULL, "ns:setparamint");
	case SOAP_TYPE_ns__setparamintResponse:
		return soap_in_ns__setparamintResponse(soap, NULL, NULL, "ns:setparamintResponse");
	case SOAP_TYPE_ns__setparamdouble:
		return soap_in_ns__setparamdouble(soap, NULL, NULL, "ns:setparamdouble");
	case SOAP_TYPE_ns__setparamdoubleResponse:
		return soap_in_ns__setparamdoubleResponse(soap, NULL, NULL, "ns:setparamdoubleResponse");
	case SOAP_TYPE_ns__getmetadata:
		return soap_in_ns__getmetadata(soap, NULL, NULL, "ns:getmetadata");
	case SOAP_TYPE_ns__getmetadataResponse:
		return soap_in_ns__getmetadataResponse(soap, NULL, NULL, "ns:getmetadataResponse");
	case SOAP_TYPE_ns__getparammmat3d:
		return soap_in_ns__getparammmat3d(soap, NULL, NULL, "ns:getparammmat3d");
	case SOAP_TYPE_ns__getparammmat3dResponse:
		return soap_in_ns__getparammmat3dResponse(soap, NULL, NULL, "ns:getparammmat3dResponse");
	case SOAP_TYPE_ns__getparamstring:
		return soap_in_ns__getparamstring(soap, NULL, NULL, "ns:getparamstring");
	case SOAP_TYPE_ns__getparamstringResponse:
		return soap_in_ns__getparamstringResponse(soap, NULL, NULL, "ns:getparamstringResponse");
	case SOAP_TYPE_ns__getparammat:
		return soap_in_ns__getparammat(soap, NULL, NULL, "ns:getparammat");
	case SOAP_TYPE_ns__getparammatResponse:
		return soap_in_ns__getparammatResponse(soap, NULL, NULL, "ns:getparammatResponse");
	case SOAP_TYPE_ns__getparamvec:
		return soap_in_ns__getparamvec(soap, NULL, NULL, "ns:getparamvec");
	case SOAP_TYPE_ns__getparamvecResponse:
		return soap_in_ns__getparamvecResponse(soap, NULL, NULL, "ns:getparamvecResponse");
	case SOAP_TYPE_ns__getparamint:
		return soap_in_ns__getparamint(soap, NULL, NULL, "ns:getparamint");
	case SOAP_TYPE_ns__getparamintResponse:
		return soap_in_ns__getparamintResponse(soap, NULL, NULL, "ns:getparamintResponse");
	case SOAP_TYPE_ns__getparamdouble:
		return soap_in_ns__getparamdouble(soap, NULL, NULL, "ns:getparamdouble");
	case SOAP_TYPE_ns__getparamdoubleResponse:
		return soap_in_ns__getparamdoubleResponse(soap, NULL, NULL, "ns:getparamdoubleResponse");
	case SOAP_TYPE_ns__addmetadata:
		return soap_in_ns__addmetadata(soap, NULL, NULL, "ns:addmetadata");
	case SOAP_TYPE_ns__addmetadataResponse:
		return soap_in_ns__addmetadataResponse(soap, NULL, NULL, "ns:addmetadataResponse");
	case SOAP_TYPE_ns__addparammmat3d:
		return soap_in_ns__addparammmat3d(soap, NULL, NULL, "ns:addparammmat3d");
	case SOAP_TYPE_ns__addparammmat3dResponse:
		return soap_in_ns__addparammmat3dResponse(soap, NULL, NULL, "ns:addparammmat3dResponse");
	case SOAP_TYPE_ns__addparamstring:
		return soap_in_ns__addparamstring(soap, NULL, NULL, "ns:addparamstring");
	case SOAP_TYPE_ns__addparamstringResponse:
		return soap_in_ns__addparamstringResponse(soap, NULL, NULL, "ns:addparamstringResponse");
	case SOAP_TYPE_ns__addparammat:
		return soap_in_ns__addparammat(soap, NULL, NULL, "ns:addparammat");
	case SOAP_TYPE_ns__addparammatResponse:
		return soap_in_ns__addparammatResponse(soap, NULL, NULL, "ns:addparammatResponse");
	case SOAP_TYPE_ns__addparamvec:
		return soap_in_ns__addparamvec(soap, NULL, NULL, "ns:addparamvec");
	case SOAP_TYPE_ns__addparamvecResponse:
		return soap_in_ns__addparamvecResponse(soap, NULL, NULL, "ns:addparamvecResponse");
	case SOAP_TYPE_ns__addparamint:
		return soap_in_ns__addparamint(soap, NULL, NULL, "ns:addparamint");
	case SOAP_TYPE_ns__addparamintResponse:
		return soap_in_ns__addparamintResponse(soap, NULL, NULL, "ns:addparamintResponse");
	case SOAP_TYPE_ns__addparamdouble:
		return soap_in_ns__addparamdouble(soap, NULL, NULL, "ns:addparamdouble");
	case SOAP_TYPE_ns__addparamdoubleResponse:
		return soap_in_ns__addparamdoubleResponse(soap, NULL, NULL, "ns:addparamdoubleResponse");
	case SOAP_TYPE_ns__exitiome:
		return soap_in_ns__exitiome(soap, NULL, NULL, "ns:exitiome");
	case SOAP_TYPE_ns__exitiomeResponse:
		return soap_in_ns__exitiomeResponse(soap, NULL, NULL, "ns:exitiomeResponse");
	case SOAP_TYPE_ns__readsimulation:
		return soap_in_ns__readsimulation(soap, NULL, NULL, "ns:readsimulation");
	case SOAP_TYPE_ns__readsimulationResponse:
		return soap_in_ns__readsimulationResponse(soap, NULL, NULL, "ns:readsimulationResponse");
	case SOAP_TYPE_ns__writesimulation:
		return soap_in_ns__writesimulation(soap, NULL, NULL, "ns:writesimulation");
	case SOAP_TYPE_ns__writesimulationResponse:
		return soap_in_ns__writesimulationResponse(soap, NULL, NULL, "ns:writesimulationResponse");
	case SOAP_TYPE_ns__readlocalsimulation:
		return soap_in_ns__readlocalsimulation(soap, NULL, NULL, "ns:readlocalsimulation");
	case SOAP_TYPE_ns__readlocalsimulationResponse:
		return soap_in_ns__readlocalsimulationResponse(soap, NULL, NULL, "ns:readlocalsimulationResponse");
	case SOAP_TYPE_ns__writelocalsimulation:
		return soap_in_ns__writelocalsimulation(soap, NULL, NULL, "ns:writelocalsimulation");
	case SOAP_TYPE_ns__writelocalsimulationResponse:
		return soap_in_ns__writelocalsimulationResponse(soap, NULL, NULL, "ns:writelocalsimulationResponse");
	case SOAP_TYPE_ns__createsimulation:
		return soap_in_ns__createsimulation(soap, NULL, NULL, "ns:createsimulation");
	case SOAP_TYPE_ns__createsimulationResponse:
		return soap_in_ns__createsimulationResponse(soap, NULL, NULL, "ns:createsimulationResponse");
	case SOAP_TYPE_ns__newsimulation:
		return soap_in_ns__newsimulation(soap, NULL, NULL, "ns:newsimulation");
	case SOAP_TYPE_ns__newsimulationResponse:
		return soap_in_ns__newsimulationResponse(soap, NULL, NULL, "ns:newsimulationResponse");
	case SOAP_TYPE_ns__deletesimulation:
		return soap_in_ns__deletesimulation(soap, NULL, NULL, "ns:deletesimulation");
	case SOAP_TYPE_ns__deletesimulationResponse:
		return soap_in_ns__deletesimulationResponse(soap, NULL, NULL, "ns:deletesimulationResponse");
	case SOAP_TYPE_ns__getsimulationresults:
		return soap_in_ns__getsimulationresults(soap, NULL, NULL, "ns:getsimulationresults");
	case SOAP_TYPE_ns__getsimulationresultsResponse:
		return soap_in_ns__getsimulationresultsResponse(soap, NULL, NULL, "ns:getsimulationresultsResponse");
	case SOAP_TYPE_ns__setsimulationstatus:
		return soap_in_ns__setsimulationstatus(soap, NULL, NULL, "ns:setsimulationstatus");
	case SOAP_TYPE_ns__setsimulationstatusResponse:
		return soap_in_ns__setsimulationstatusResponse(soap, NULL, NULL, "ns:setsimulationstatusResponse");
	case SOAP_TYPE_ns__simulationstatus:
		return soap_in_ns__simulationstatus(soap, NULL, NULL, "ns:simulationstatus");
	case SOAP_TYPE_ns__simulationstatusResponse:
		return soap_in_ns__simulationstatusResponse(soap, NULL, NULL, "ns:simulationstatusResponse");
	case SOAP_TYPE_ns__submitsimulation:
		return soap_in_ns__submitsimulation(soap, NULL, NULL, "ns:submitsimulation");
	case SOAP_TYPE_ns__submitsimulationResponse:
		return soap_in_ns__submitsimulationResponse(soap, NULL, NULL, "ns:submitsimulationResponse");
	case SOAP_TYPE_ns__runrequestedsimulation:
		return soap_in_ns__runrequestedsimulation(soap, NULL, NULL, "ns:runrequestedsimulation");
	case SOAP_TYPE_ns__runrequestedsimulationResponse:
		return soap_in_ns__runrequestedsimulationResponse(soap, NULL, NULL, "ns:runrequestedsimulationResponse");
	case SOAP_TYPE_ns__requestsimulation:
		return soap_in_ns__requestsimulation(soap, NULL, NULL, "ns:requestsimulation");
	case SOAP_TYPE_ns__requestsimulationResponse:
		return soap_in_ns__requestsimulationResponse(soap, NULL, NULL, "ns:requestsimulationResponse");
	case SOAP_TYPE_ns__runsimulation:
		return soap_in_ns__runsimulation(soap, NULL, NULL, "ns:runsimulation");
	case SOAP_TYPE_ns__runsimulationResponse:
		return soap_in_ns__runsimulationResponse(soap, NULL, NULL, "ns:runsimulationResponse");
	case SOAP_TYPE_ns__runsimulationstep:
		return soap_in_ns__runsimulationstep(soap, NULL, NULL, "ns:runsimulationstep");
	case SOAP_TYPE_ns__runsimulationstepResponse:
		return soap_in_ns__runsimulationstepResponse(soap, NULL, NULL, "ns:runsimulationstepResponse");
	case SOAP_TYPE_ns__setnsteps:
		return soap_in_ns__setnsteps(soap, NULL, NULL, "ns:setnsteps");
	case SOAP_TYPE_ns__setnstepsResponse:
		return soap_in_ns__setnstepsResponse(soap, NULL, NULL, "ns:setnstepsResponse");
	case SOAP_TYPE_ns__getnsteps:
		return soap_in_ns__getnsteps(soap, NULL, NULL, "ns:getnsteps");
	case SOAP_TYPE_ns__getnstepsResponse:
		return soap_in_ns__getnstepsResponse(soap, NULL, NULL, "ns:getnstepsResponse");
	case SOAP_TYPE_ns__setstep:
		return soap_in_ns__setstep(soap, NULL, NULL, "ns:setstep");
	case SOAP_TYPE_ns__setstepResponse:
		return soap_in_ns__setstepResponse(soap, NULL, NULL, "ns:setstepResponse");
	case SOAP_TYPE_ns__getstep:
		return soap_in_ns__getstep(soap, NULL, NULL, "ns:getstep");
	case SOAP_TYPE_ns__getstepResponse:
		return soap_in_ns__getstepResponse(soap, NULL, NULL, "ns:getstepResponse");
	case SOAP_TYPE_ns__add:
		return soap_in_ns__add(soap, NULL, NULL, "ns:add");
	case SOAP_TYPE_ns__addResponse:
		return soap_in_ns__addResponse(soap, NULL, NULL, "ns:addResponse");
	case SOAP_TYPE_fdata:
		return soap_in_fdata(soap, NULL, NULL, "xsd:double");
	case SOAP_TYPE_PointerToPointerTofdata:
		return soap_in_PointerToPointerTofdata(soap, NULL, NULL, "xsd:double");
	case SOAP_TYPE_PointerTofdata:
		return soap_in_PointerTofdata(soap, NULL, NULL, "xsd:double");
	case SOAP_TYPE_PointerTostring:
		return soap_in_PointerTostring(soap, NULL, NULL, "xsd:string");
	case SOAP_TYPE_PointerToint:
		return soap_in_PointerToint(soap, NULL, NULL, "xsd:int");
	case SOAP_TYPE_PointerTodouble:
		return soap_in_PointerTodouble(soap, NULL, NULL, "xsd:double");
	case SOAP_TYPE__QName:
	{	char **s;
		s = soap_in__QName(soap, NULL, NULL, "QName");
		return s ? *s : NULL;
	}
	case SOAP_TYPE_string:
	{	char **s;
		s = soap_in_string(soap, NULL, NULL, "xsd:string");
		return s ? *s : NULL;
	}
	default:
	{	const char *t = soap->type;
		if (!*t)
			t = soap->tag;
		if (!soap_match_tag(soap, t, "xsd:byte"))
		{	*type = SOAP_TYPE_byte;
			return soap_in_byte(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:int"))
		{	*type = SOAP_TYPE_int;
			return soap_in_int(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:double"))
		{	*type = SOAP_TYPE_double;
			return soap_in_double(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:setgroupbarrier"))
		{	*type = SOAP_TYPE_ns__setgroupbarrier;
			return soap_in_ns__setgroupbarrier(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:setgroupbarrierResponse"))
		{	*type = SOAP_TYPE_ns__setgroupbarrierResponse;
			return soap_in_ns__setgroupbarrierResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:testgroupbarrier"))
		{	*type = SOAP_TYPE_ns__testgroupbarrier;
			return soap_in_ns__testgroupbarrier(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:testgroupbarrierResponse"))
		{	*type = SOAP_TYPE_ns__testgroupbarrierResponse;
			return soap_in_ns__testgroupbarrierResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:getobjnum"))
		{	*type = SOAP_TYPE_ns__getobjnum;
			return soap_in_ns__getobjnum(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:getobjnumResponse"))
		{	*type = SOAP_TYPE_ns__getobjnumResponse;
			return soap_in_ns__getobjnumResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:getnumobj"))
		{	*type = SOAP_TYPE_ns__getnumobj;
			return soap_in_ns__getnumobj(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:getnumobjResponse"))
		{	*type = SOAP_TYPE_ns__getnumobjResponse;
			return soap_in_ns__getnumobjResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:listparam"))
		{	*type = SOAP_TYPE_ns__listparam;
			return soap_in_ns__listparam(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:listparamResponse"))
		{	*type = SOAP_TYPE_ns__listparamResponse;
			return soap_in_ns__listparamResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:deleteparam"))
		{	*type = SOAP_TYPE_ns__deleteparam;
			return soap_in_ns__deleteparam(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:deleteparamResponse"))
		{	*type = SOAP_TYPE_ns__deleteparamResponse;
			return soap_in_ns__deleteparamResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:deletemetadata"))
		{	*type = SOAP_TYPE_ns__deletemetadata;
			return soap_in_ns__deletemetadata(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:deletemetadataResponse"))
		{	*type = SOAP_TYPE_ns__deletemetadataResponse;
			return soap_in_ns__deletemetadataResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:listmetadata"))
		{	*type = SOAP_TYPE_ns__listmetadata;
			return soap_in_ns__listmetadata(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:listmetadataResponse"))
		{	*type = SOAP_TYPE_ns__listmetadataResponse;
			return soap_in_ns__listmetadataResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:setmetadata"))
		{	*type = SOAP_TYPE_ns__setmetadata;
			return soap_in_ns__setmetadata(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:setmetadataResponse"))
		{	*type = SOAP_TYPE_ns__setmetadataResponse;
			return soap_in_ns__setmetadataResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:setparammmat3d"))
		{	*type = SOAP_TYPE_ns__setparammmat3d;
			return soap_in_ns__setparammmat3d(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:setparammmat3dResponse"))
		{	*type = SOAP_TYPE_ns__setparammmat3dResponse;
			return soap_in_ns__setparammmat3dResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:setparamstring"))
		{	*type = SOAP_TYPE_ns__setparamstring;
			return soap_in_ns__setparamstring(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:setparamstringResponse"))
		{	*type = SOAP_TYPE_ns__setparamstringResponse;
			return soap_in_ns__setparamstringResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:setparammat"))
		{	*type = SOAP_TYPE_ns__setparammat;
			return soap_in_ns__setparammat(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:setparammatResponse"))
		{	*type = SOAP_TYPE_ns__setparammatResponse;
			return soap_in_ns__setparammatResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:setparamvec"))
		{	*type = SOAP_TYPE_ns__setparamvec;
			return soap_in_ns__setparamvec(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:setparamvecResponse"))
		{	*type = SOAP_TYPE_ns__setparamvecResponse;
			return soap_in_ns__setparamvecResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:setparamint"))
		{	*type = SOAP_TYPE_ns__setparamint;
			return soap_in_ns__setparamint(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:setparamintResponse"))
		{	*type = SOAP_TYPE_ns__setparamintResponse;
			return soap_in_ns__setparamintResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:setparamdouble"))
		{	*type = SOAP_TYPE_ns__setparamdouble;
			return soap_in_ns__setparamdouble(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:setparamdoubleResponse"))
		{	*type = SOAP_TYPE_ns__setparamdoubleResponse;
			return soap_in_ns__setparamdoubleResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:getmetadata"))
		{	*type = SOAP_TYPE_ns__getmetadata;
			return soap_in_ns__getmetadata(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:getmetadataResponse"))
		{	*type = SOAP_TYPE_ns__getmetadataResponse;
			return soap_in_ns__getmetadataResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:getparammmat3d"))
		{	*type = SOAP_TYPE_ns__getparammmat3d;
			return soap_in_ns__getparammmat3d(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:getparammmat3dResponse"))
		{	*type = SOAP_TYPE_ns__getparammmat3dResponse;
			return soap_in_ns__getparammmat3dResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:getparamstring"))
		{	*type = SOAP_TYPE_ns__getparamstring;
			return soap_in_ns__getparamstring(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:getparamstringResponse"))
		{	*type = SOAP_TYPE_ns__getparamstringResponse;
			return soap_in_ns__getparamstringResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:getparammat"))
		{	*type = SOAP_TYPE_ns__getparammat;
			return soap_in_ns__getparammat(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:getparammatResponse"))
		{	*type = SOAP_TYPE_ns__getparammatResponse;
			return soap_in_ns__getparammatResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:getparamvec"))
		{	*type = SOAP_TYPE_ns__getparamvec;
			return soap_in_ns__getparamvec(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:getparamvecResponse"))
		{	*type = SOAP_TYPE_ns__getparamvecResponse;
			return soap_in_ns__getparamvecResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:getparamint"))
		{	*type = SOAP_TYPE_ns__getparamint;
			return soap_in_ns__getparamint(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:getparamintResponse"))
		{	*type = SOAP_TYPE_ns__getparamintResponse;
			return soap_in_ns__getparamintResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:getparamdouble"))
		{	*type = SOAP_TYPE_ns__getparamdouble;
			return soap_in_ns__getparamdouble(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:getparamdoubleResponse"))
		{	*type = SOAP_TYPE_ns__getparamdoubleResponse;
			return soap_in_ns__getparamdoubleResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:addmetadata"))
		{	*type = SOAP_TYPE_ns__addmetadata;
			return soap_in_ns__addmetadata(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:addmetadataResponse"))
		{	*type = SOAP_TYPE_ns__addmetadataResponse;
			return soap_in_ns__addmetadataResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:addparammmat3d"))
		{	*type = SOAP_TYPE_ns__addparammmat3d;
			return soap_in_ns__addparammmat3d(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:addparammmat3dResponse"))
		{	*type = SOAP_TYPE_ns__addparammmat3dResponse;
			return soap_in_ns__addparammmat3dResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:addparamstring"))
		{	*type = SOAP_TYPE_ns__addparamstring;
			return soap_in_ns__addparamstring(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:addparamstringResponse"))
		{	*type = SOAP_TYPE_ns__addparamstringResponse;
			return soap_in_ns__addparamstringResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:addparammat"))
		{	*type = SOAP_TYPE_ns__addparammat;
			return soap_in_ns__addparammat(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:addparammatResponse"))
		{	*type = SOAP_TYPE_ns__addparammatResponse;
			return soap_in_ns__addparammatResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:addparamvec"))
		{	*type = SOAP_TYPE_ns__addparamvec;
			return soap_in_ns__addparamvec(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:addparamvecResponse"))
		{	*type = SOAP_TYPE_ns__addparamvecResponse;
			return soap_in_ns__addparamvecResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:addparamint"))
		{	*type = SOAP_TYPE_ns__addparamint;
			return soap_in_ns__addparamint(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:addparamintResponse"))
		{	*type = SOAP_TYPE_ns__addparamintResponse;
			return soap_in_ns__addparamintResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:addparamdouble"))
		{	*type = SOAP_TYPE_ns__addparamdouble;
			return soap_in_ns__addparamdouble(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:addparamdoubleResponse"))
		{	*type = SOAP_TYPE_ns__addparamdoubleResponse;
			return soap_in_ns__addparamdoubleResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:exitiome"))
		{	*type = SOAP_TYPE_ns__exitiome;
			return soap_in_ns__exitiome(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:exitiomeResponse"))
		{	*type = SOAP_TYPE_ns__exitiomeResponse;
			return soap_in_ns__exitiomeResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:readsimulation"))
		{	*type = SOAP_TYPE_ns__readsimulation;
			return soap_in_ns__readsimulation(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:readsimulationResponse"))
		{	*type = SOAP_TYPE_ns__readsimulationResponse;
			return soap_in_ns__readsimulationResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:writesimulation"))
		{	*type = SOAP_TYPE_ns__writesimulation;
			return soap_in_ns__writesimulation(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:writesimulationResponse"))
		{	*type = SOAP_TYPE_ns__writesimulationResponse;
			return soap_in_ns__writesimulationResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:readlocalsimulation"))
		{	*type = SOAP_TYPE_ns__readlocalsimulation;
			return soap_in_ns__readlocalsimulation(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:readlocalsimulationResponse"))
		{	*type = SOAP_TYPE_ns__readlocalsimulationResponse;
			return soap_in_ns__readlocalsimulationResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:writelocalsimulation"))
		{	*type = SOAP_TYPE_ns__writelocalsimulation;
			return soap_in_ns__writelocalsimulation(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:writelocalsimulationResponse"))
		{	*type = SOAP_TYPE_ns__writelocalsimulationResponse;
			return soap_in_ns__writelocalsimulationResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:createsimulation"))
		{	*type = SOAP_TYPE_ns__createsimulation;
			return soap_in_ns__createsimulation(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:createsimulationResponse"))
		{	*type = SOAP_TYPE_ns__createsimulationResponse;
			return soap_in_ns__createsimulationResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:newsimulation"))
		{	*type = SOAP_TYPE_ns__newsimulation;
			return soap_in_ns__newsimulation(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:newsimulationResponse"))
		{	*type = SOAP_TYPE_ns__newsimulationResponse;
			return soap_in_ns__newsimulationResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:deletesimulation"))
		{	*type = SOAP_TYPE_ns__deletesimulation;
			return soap_in_ns__deletesimulation(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:deletesimulationResponse"))
		{	*type = SOAP_TYPE_ns__deletesimulationResponse;
			return soap_in_ns__deletesimulationResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:getsimulationresults"))
		{	*type = SOAP_TYPE_ns__getsimulationresults;
			return soap_in_ns__getsimulationresults(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:getsimulationresultsResponse"))
		{	*type = SOAP_TYPE_ns__getsimulationresultsResponse;
			return soap_in_ns__getsimulationresultsResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:setsimulationstatus"))
		{	*type = SOAP_TYPE_ns__setsimulationstatus;
			return soap_in_ns__setsimulationstatus(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:setsimulationstatusResponse"))
		{	*type = SOAP_TYPE_ns__setsimulationstatusResponse;
			return soap_in_ns__setsimulationstatusResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:simulationstatus"))
		{	*type = SOAP_TYPE_ns__simulationstatus;
			return soap_in_ns__simulationstatus(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:simulationstatusResponse"))
		{	*type = SOAP_TYPE_ns__simulationstatusResponse;
			return soap_in_ns__simulationstatusResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:submitsimulation"))
		{	*type = SOAP_TYPE_ns__submitsimulation;
			return soap_in_ns__submitsimulation(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:submitsimulationResponse"))
		{	*type = SOAP_TYPE_ns__submitsimulationResponse;
			return soap_in_ns__submitsimulationResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:runrequestedsimulation"))
		{	*type = SOAP_TYPE_ns__runrequestedsimulation;
			return soap_in_ns__runrequestedsimulation(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:runrequestedsimulationResponse"))
		{	*type = SOAP_TYPE_ns__runrequestedsimulationResponse;
			return soap_in_ns__runrequestedsimulationResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:requestsimulation"))
		{	*type = SOAP_TYPE_ns__requestsimulation;
			return soap_in_ns__requestsimulation(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:requestsimulationResponse"))
		{	*type = SOAP_TYPE_ns__requestsimulationResponse;
			return soap_in_ns__requestsimulationResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:runsimulation"))
		{	*type = SOAP_TYPE_ns__runsimulation;
			return soap_in_ns__runsimulation(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:runsimulationResponse"))
		{	*type = SOAP_TYPE_ns__runsimulationResponse;
			return soap_in_ns__runsimulationResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:runsimulationstep"))
		{	*type = SOAP_TYPE_ns__runsimulationstep;
			return soap_in_ns__runsimulationstep(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:runsimulationstepResponse"))
		{	*type = SOAP_TYPE_ns__runsimulationstepResponse;
			return soap_in_ns__runsimulationstepResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:setnsteps"))
		{	*type = SOAP_TYPE_ns__setnsteps;
			return soap_in_ns__setnsteps(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:setnstepsResponse"))
		{	*type = SOAP_TYPE_ns__setnstepsResponse;
			return soap_in_ns__setnstepsResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:getnsteps"))
		{	*type = SOAP_TYPE_ns__getnsteps;
			return soap_in_ns__getnsteps(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:getnstepsResponse"))
		{	*type = SOAP_TYPE_ns__getnstepsResponse;
			return soap_in_ns__getnstepsResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:setstep"))
		{	*type = SOAP_TYPE_ns__setstep;
			return soap_in_ns__setstep(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:setstepResponse"))
		{	*type = SOAP_TYPE_ns__setstepResponse;
			return soap_in_ns__setstepResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:getstep"))
		{	*type = SOAP_TYPE_ns__getstep;
			return soap_in_ns__getstep(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:getstepResponse"))
		{	*type = SOAP_TYPE_ns__getstepResponse;
			return soap_in_ns__getstepResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:add"))
		{	*type = SOAP_TYPE_ns__add;
			return soap_in_ns__add(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:addResponse"))
		{	*type = SOAP_TYPE_ns__addResponse;
			return soap_in_ns__addResponse(soap, NULL, NULL, NULL);
		}
		if (*soap->arrayType && !soap_match_array(soap, "xsd:double"))
		{	*type = SOAP_TYPE_fdata;
			return soap_in_fdata(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "QName"))
		{	char **s;
			*type = SOAP_TYPE__QName;
			s = soap_in__QName(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "xsd:string"))
		{	char **s;
			*type = SOAP_TYPE_string;
			s = soap_in_string(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
	}
	}
	soap->error = SOAP_TAG_MISMATCH;
	return NULL;
}
#endif

SOAP_FMAC3 int SOAP_FMAC4 soap_ignore_element(struct soap *soap)
{
	if (!soap_peek_element(soap))
	{	int t;
		if (soap->mustUnderstand && !soap->other)
			return soap->error = SOAP_MUSTUNDERSTAND;
		if (((soap->mode & SOAP_XML_STRICT) && soap->part != SOAP_IN_HEADER) || !soap_match_tag(soap, soap->tag, "SOAP-ENV:"))
			return soap->error = SOAP_TAG_MISMATCH;
		if (!*soap->id || !soap_getelement(soap, &t))
		{	soap->peeked = 0;
			DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Unknown element '%s' (level=%u, %d)\n", soap->tag, soap->level, soap->body));
			if (soap->fignore)
				soap->error = soap->fignore(soap, soap->tag);
			else
				soap->error = SOAP_OK;
			DBGLOG(TEST, if (!soap->error) SOAP_MESSAGE(fdebug, "IGNORING element '%s'\n", soap->tag));
			if (!soap->error && soap->body)
			{	soap->level++;
				while (!soap_ignore_element(soap))
					;
				if (soap->error == SOAP_NO_TAG)
					soap->error = soap_element_end_in(soap, NULL);
			}
		}
	}
	return soap->error;
}

#ifndef WITH_NOIDREF
SOAP_FMAC3 int SOAP_FMAC4 soap_putindependent(struct soap *soap)
{
	int i;
	struct soap_plist *pp;
	if (soap->version == 1 && soap->encodingStyle && !(soap->mode & (SOAP_XML_TREE | SOAP_XML_GRAPH)))
		for (i = 0; i < SOAP_PTRHASH; i++)
			for (pp = soap->pht[i]; pp; pp = pp->next)
				if (pp->mark1 == 2 || pp->mark2 == 2)
					if (soap_putelement(soap, pp->ptr, "id", pp->id, pp->type))
						return soap->error;
	return SOAP_OK;
}
#endif

#ifndef WITH_NOIDREF
SOAP_FMAC3 int SOAP_FMAC4 soap_putelement(struct soap *soap, const void *ptr, const char *tag, int id, int type)
{
	switch (type)
	{
	case SOAP_TYPE_byte:
		return soap_out_byte(soap, tag, id, (const char *)ptr, "xsd:byte");
	case SOAP_TYPE_int:
		return soap_out_int(soap, tag, id, (const int *)ptr, "xsd:int");
	case SOAP_TYPE_double:
		return soap_out_double(soap, tag, id, (const double *)ptr, "xsd:double");
	case SOAP_TYPE_ns__setgroupbarrier:
		return soap_out_ns__setgroupbarrier(soap, tag, id, (const struct ns__setgroupbarrier *)ptr, "ns:setgroupbarrier");
	case SOAP_TYPE_ns__setgroupbarrierResponse:
		return soap_out_ns__setgroupbarrierResponse(soap, tag, id, (const struct ns__setgroupbarrierResponse *)ptr, "ns:setgroupbarrierResponse");
	case SOAP_TYPE_ns__testgroupbarrier:
		return soap_out_ns__testgroupbarrier(soap, tag, id, (const struct ns__testgroupbarrier *)ptr, "ns:testgroupbarrier");
	case SOAP_TYPE_ns__testgroupbarrierResponse:
		return soap_out_ns__testgroupbarrierResponse(soap, tag, id, (const struct ns__testgroupbarrierResponse *)ptr, "ns:testgroupbarrierResponse");
	case SOAP_TYPE_ns__getobjnum:
		return soap_out_ns__getobjnum(soap, tag, id, (const struct ns__getobjnum *)ptr, "ns:getobjnum");
	case SOAP_TYPE_ns__getobjnumResponse:
		return soap_out_ns__getobjnumResponse(soap, tag, id, (const struct ns__getobjnumResponse *)ptr, "ns:getobjnumResponse");
	case SOAP_TYPE_ns__getnumobj:
		return soap_out_ns__getnumobj(soap, tag, id, (const struct ns__getnumobj *)ptr, "ns:getnumobj");
	case SOAP_TYPE_ns__getnumobjResponse:
		return soap_out_ns__getnumobjResponse(soap, tag, id, (const struct ns__getnumobjResponse *)ptr, "ns:getnumobjResponse");
	case SOAP_TYPE_ns__listparam:
		return soap_out_ns__listparam(soap, tag, id, (const struct ns__listparam *)ptr, "ns:listparam");
	case SOAP_TYPE_ns__listparamResponse:
		return soap_out_ns__listparamResponse(soap, tag, id, (const struct ns__listparamResponse *)ptr, "ns:listparamResponse");
	case SOAP_TYPE_ns__deleteparam:
		return soap_out_ns__deleteparam(soap, tag, id, (const struct ns__deleteparam *)ptr, "ns:deleteparam");
	case SOAP_TYPE_ns__deleteparamResponse:
		return soap_out_ns__deleteparamResponse(soap, tag, id, (const struct ns__deleteparamResponse *)ptr, "ns:deleteparamResponse");
	case SOAP_TYPE_ns__deletemetadata:
		return soap_out_ns__deletemetadata(soap, tag, id, (const struct ns__deletemetadata *)ptr, "ns:deletemetadata");
	case SOAP_TYPE_ns__deletemetadataResponse:
		return soap_out_ns__deletemetadataResponse(soap, tag, id, (const struct ns__deletemetadataResponse *)ptr, "ns:deletemetadataResponse");
	case SOAP_TYPE_ns__listmetadata:
		return soap_out_ns__listmetadata(soap, tag, id, (const struct ns__listmetadata *)ptr, "ns:listmetadata");
	case SOAP_TYPE_ns__listmetadataResponse:
		return soap_out_ns__listmetadataResponse(soap, tag, id, (const struct ns__listmetadataResponse *)ptr, "ns:listmetadataResponse");
	case SOAP_TYPE_ns__setmetadata:
		return soap_out_ns__setmetadata(soap, tag, id, (const struct ns__setmetadata *)ptr, "ns:setmetadata");
	case SOAP_TYPE_ns__setmetadataResponse:
		return soap_out_ns__setmetadataResponse(soap, tag, id, (const struct ns__setmetadataResponse *)ptr, "ns:setmetadataResponse");
	case SOAP_TYPE_ns__setparammmat3d:
		return soap_out_ns__setparammmat3d(soap, tag, id, (const struct ns__setparammmat3d *)ptr, "ns:setparammmat3d");
	case SOAP_TYPE_ns__setparammmat3dResponse:
		return soap_out_ns__setparammmat3dResponse(soap, tag, id, (const struct ns__setparammmat3dResponse *)ptr, "ns:setparammmat3dResponse");
	case SOAP_TYPE_ns__setparamstring:
		return soap_out_ns__setparamstring(soap, tag, id, (const struct ns__setparamstring *)ptr, "ns:setparamstring");
	case SOAP_TYPE_ns__setparamstringResponse:
		return soap_out_ns__setparamstringResponse(soap, tag, id, (const struct ns__setparamstringResponse *)ptr, "ns:setparamstringResponse");
	case SOAP_TYPE_ns__setparammat:
		return soap_out_ns__setparammat(soap, tag, id, (const struct ns__setparammat *)ptr, "ns:setparammat");
	case SOAP_TYPE_ns__setparammatResponse:
		return soap_out_ns__setparammatResponse(soap, tag, id, (const struct ns__setparammatResponse *)ptr, "ns:setparammatResponse");
	case SOAP_TYPE_ns__setparamvec:
		return soap_out_ns__setparamvec(soap, tag, id, (const struct ns__setparamvec *)ptr, "ns:setparamvec");
	case SOAP_TYPE_ns__setparamvecResponse:
		return soap_out_ns__setparamvecResponse(soap, tag, id, (const struct ns__setparamvecResponse *)ptr, "ns:setparamvecResponse");
	case SOAP_TYPE_ns__setparamint:
		return soap_out_ns__setparamint(soap, tag, id, (const struct ns__setparamint *)ptr, "ns:setparamint");
	case SOAP_TYPE_ns__setparamintResponse:
		return soap_out_ns__setparamintResponse(soap, tag, id, (const struct ns__setparamintResponse *)ptr, "ns:setparamintResponse");
	case SOAP_TYPE_ns__setparamdouble:
		return soap_out_ns__setparamdouble(soap, tag, id, (const struct ns__setparamdouble *)ptr, "ns:setparamdouble");
	case SOAP_TYPE_ns__setparamdoubleResponse:
		return soap_out_ns__setparamdoubleResponse(soap, tag, id, (const struct ns__setparamdoubleResponse *)ptr, "ns:setparamdoubleResponse");
	case SOAP_TYPE_ns__getmetadata:
		return soap_out_ns__getmetadata(soap, tag, id, (const struct ns__getmetadata *)ptr, "ns:getmetadata");
	case SOAP_TYPE_ns__getmetadataResponse:
		return soap_out_ns__getmetadataResponse(soap, tag, id, (const struct ns__getmetadataResponse *)ptr, "ns:getmetadataResponse");
	case SOAP_TYPE_ns__getparammmat3d:
		return soap_out_ns__getparammmat3d(soap, tag, id, (const struct ns__getparammmat3d *)ptr, "ns:getparammmat3d");
	case SOAP_TYPE_ns__getparammmat3dResponse:
		return soap_out_ns__getparammmat3dResponse(soap, tag, id, (const struct ns__getparammmat3dResponse *)ptr, "ns:getparammmat3dResponse");
	case SOAP_TYPE_ns__getparamstring:
		return soap_out_ns__getparamstring(soap, tag, id, (const struct ns__getparamstring *)ptr, "ns:getparamstring");
	case SOAP_TYPE_ns__getparamstringResponse:
		return soap_out_ns__getparamstringResponse(soap, tag, id, (const struct ns__getparamstringResponse *)ptr, "ns:getparamstringResponse");
	case SOAP_TYPE_ns__getparammat:
		return soap_out_ns__getparammat(soap, tag, id, (const struct ns__getparammat *)ptr, "ns:getparammat");
	case SOAP_TYPE_ns__getparammatResponse:
		return soap_out_ns__getparammatResponse(soap, tag, id, (const struct ns__getparammatResponse *)ptr, "ns:getparammatResponse");
	case SOAP_TYPE_ns__getparamvec:
		return soap_out_ns__getparamvec(soap, tag, id, (const struct ns__getparamvec *)ptr, "ns:getparamvec");
	case SOAP_TYPE_ns__getparamvecResponse:
		return soap_out_ns__getparamvecResponse(soap, tag, id, (const struct ns__getparamvecResponse *)ptr, "ns:getparamvecResponse");
	case SOAP_TYPE_ns__getparamint:
		return soap_out_ns__getparamint(soap, tag, id, (const struct ns__getparamint *)ptr, "ns:getparamint");
	case SOAP_TYPE_ns__getparamintResponse:
		return soap_out_ns__getparamintResponse(soap, tag, id, (const struct ns__getparamintResponse *)ptr, "ns:getparamintResponse");
	case SOAP_TYPE_ns__getparamdouble:
		return soap_out_ns__getparamdouble(soap, tag, id, (const struct ns__getparamdouble *)ptr, "ns:getparamdouble");
	case SOAP_TYPE_ns__getparamdoubleResponse:
		return soap_out_ns__getparamdoubleResponse(soap, tag, id, (const struct ns__getparamdoubleResponse *)ptr, "ns:getparamdoubleResponse");
	case SOAP_TYPE_ns__addmetadata:
		return soap_out_ns__addmetadata(soap, tag, id, (const struct ns__addmetadata *)ptr, "ns:addmetadata");
	case SOAP_TYPE_ns__addmetadataResponse:
		return soap_out_ns__addmetadataResponse(soap, tag, id, (const struct ns__addmetadataResponse *)ptr, "ns:addmetadataResponse");
	case SOAP_TYPE_ns__addparammmat3d:
		return soap_out_ns__addparammmat3d(soap, tag, id, (const struct ns__addparammmat3d *)ptr, "ns:addparammmat3d");
	case SOAP_TYPE_ns__addparammmat3dResponse:
		return soap_out_ns__addparammmat3dResponse(soap, tag, id, (const struct ns__addparammmat3dResponse *)ptr, "ns:addparammmat3dResponse");
	case SOAP_TYPE_ns__addparamstring:
		return soap_out_ns__addparamstring(soap, tag, id, (const struct ns__addparamstring *)ptr, "ns:addparamstring");
	case SOAP_TYPE_ns__addparamstringResponse:
		return soap_out_ns__addparamstringResponse(soap, tag, id, (const struct ns__addparamstringResponse *)ptr, "ns:addparamstringResponse");
	case SOAP_TYPE_ns__addparammat:
		return soap_out_ns__addparammat(soap, tag, id, (const struct ns__addparammat *)ptr, "ns:addparammat");
	case SOAP_TYPE_ns__addparammatResponse:
		return soap_out_ns__addparammatResponse(soap, tag, id, (const struct ns__addparammatResponse *)ptr, "ns:addparammatResponse");
	case SOAP_TYPE_ns__addparamvec:
		return soap_out_ns__addparamvec(soap, tag, id, (const struct ns__addparamvec *)ptr, "ns:addparamvec");
	case SOAP_TYPE_ns__addparamvecResponse:
		return soap_out_ns__addparamvecResponse(soap, tag, id, (const struct ns__addparamvecResponse *)ptr, "ns:addparamvecResponse");
	case SOAP_TYPE_ns__addparamint:
		return soap_out_ns__addparamint(soap, tag, id, (const struct ns__addparamint *)ptr, "ns:addparamint");
	case SOAP_TYPE_ns__addparamintResponse:
		return soap_out_ns__addparamintResponse(soap, tag, id, (const struct ns__addparamintResponse *)ptr, "ns:addparamintResponse");
	case SOAP_TYPE_ns__addparamdouble:
		return soap_out_ns__addparamdouble(soap, tag, id, (const struct ns__addparamdouble *)ptr, "ns:addparamdouble");
	case SOAP_TYPE_ns__addparamdoubleResponse:
		return soap_out_ns__addparamdoubleResponse(soap, tag, id, (const struct ns__addparamdoubleResponse *)ptr, "ns:addparamdoubleResponse");
	case SOAP_TYPE_ns__exitiome:
		return soap_out_ns__exitiome(soap, tag, id, (const struct ns__exitiome *)ptr, "ns:exitiome");
	case SOAP_TYPE_ns__exitiomeResponse:
		return soap_out_ns__exitiomeResponse(soap, tag, id, (const struct ns__exitiomeResponse *)ptr, "ns:exitiomeResponse");
	case SOAP_TYPE_ns__readsimulation:
		return soap_out_ns__readsimulation(soap, tag, id, (const struct ns__readsimulation *)ptr, "ns:readsimulation");
	case SOAP_TYPE_ns__readsimulationResponse:
		return soap_out_ns__readsimulationResponse(soap, tag, id, (const struct ns__readsimulationResponse *)ptr, "ns:readsimulationResponse");
	case SOAP_TYPE_ns__writesimulation:
		return soap_out_ns__writesimulation(soap, tag, id, (const struct ns__writesimulation *)ptr, "ns:writesimulation");
	case SOAP_TYPE_ns__writesimulationResponse:
		return soap_out_ns__writesimulationResponse(soap, tag, id, (const struct ns__writesimulationResponse *)ptr, "ns:writesimulationResponse");
	case SOAP_TYPE_ns__readlocalsimulation:
		return soap_out_ns__readlocalsimulation(soap, tag, id, (const struct ns__readlocalsimulation *)ptr, "ns:readlocalsimulation");
	case SOAP_TYPE_ns__readlocalsimulationResponse:
		return soap_out_ns__readlocalsimulationResponse(soap, tag, id, (const struct ns__readlocalsimulationResponse *)ptr, "ns:readlocalsimulationResponse");
	case SOAP_TYPE_ns__writelocalsimulation:
		return soap_out_ns__writelocalsimulation(soap, tag, id, (const struct ns__writelocalsimulation *)ptr, "ns:writelocalsimulation");
	case SOAP_TYPE_ns__writelocalsimulationResponse:
		return soap_out_ns__writelocalsimulationResponse(soap, tag, id, (const struct ns__writelocalsimulationResponse *)ptr, "ns:writelocalsimulationResponse");
	case SOAP_TYPE_ns__createsimulation:
		return soap_out_ns__createsimulation(soap, tag, id, (const struct ns__createsimulation *)ptr, "ns:createsimulation");
	case SOAP_TYPE_ns__createsimulationResponse:
		return soap_out_ns__createsimulationResponse(soap, tag, id, (const struct ns__createsimulationResponse *)ptr, "ns:createsimulationResponse");
	case SOAP_TYPE_ns__newsimulation:
		return soap_out_ns__newsimulation(soap, tag, id, (const struct ns__newsimulation *)ptr, "ns:newsimulation");
	case SOAP_TYPE_ns__newsimulationResponse:
		return soap_out_ns__newsimulationResponse(soap, tag, id, (const struct ns__newsimulationResponse *)ptr, "ns:newsimulationResponse");
	case SOAP_TYPE_ns__deletesimulation:
		return soap_out_ns__deletesimulation(soap, tag, id, (const struct ns__deletesimulation *)ptr, "ns:deletesimulation");
	case SOAP_TYPE_ns__deletesimulationResponse:
		return soap_out_ns__deletesimulationResponse(soap, tag, id, (const struct ns__deletesimulationResponse *)ptr, "ns:deletesimulationResponse");
	case SOAP_TYPE_ns__getsimulationresults:
		return soap_out_ns__getsimulationresults(soap, tag, id, (const struct ns__getsimulationresults *)ptr, "ns:getsimulationresults");
	case SOAP_TYPE_ns__getsimulationresultsResponse:
		return soap_out_ns__getsimulationresultsResponse(soap, tag, id, (const struct ns__getsimulationresultsResponse *)ptr, "ns:getsimulationresultsResponse");
	case SOAP_TYPE_ns__setsimulationstatus:
		return soap_out_ns__setsimulationstatus(soap, tag, id, (const struct ns__setsimulationstatus *)ptr, "ns:setsimulationstatus");
	case SOAP_TYPE_ns__setsimulationstatusResponse:
		return soap_out_ns__setsimulationstatusResponse(soap, tag, id, (const struct ns__setsimulationstatusResponse *)ptr, "ns:setsimulationstatusResponse");
	case SOAP_TYPE_ns__simulationstatus:
		return soap_out_ns__simulationstatus(soap, tag, id, (const struct ns__simulationstatus *)ptr, "ns:simulationstatus");
	case SOAP_TYPE_ns__simulationstatusResponse:
		return soap_out_ns__simulationstatusResponse(soap, tag, id, (const struct ns__simulationstatusResponse *)ptr, "ns:simulationstatusResponse");
	case SOAP_TYPE_ns__submitsimulation:
		return soap_out_ns__submitsimulation(soap, tag, id, (const struct ns__submitsimulation *)ptr, "ns:submitsimulation");
	case SOAP_TYPE_ns__submitsimulationResponse:
		return soap_out_ns__submitsimulationResponse(soap, tag, id, (const struct ns__submitsimulationResponse *)ptr, "ns:submitsimulationResponse");
	case SOAP_TYPE_ns__runrequestedsimulation:
		return soap_out_ns__runrequestedsimulation(soap, tag, id, (const struct ns__runrequestedsimulation *)ptr, "ns:runrequestedsimulation");
	case SOAP_TYPE_ns__runrequestedsimulationResponse:
		return soap_out_ns__runrequestedsimulationResponse(soap, tag, id, (const struct ns__runrequestedsimulationResponse *)ptr, "ns:runrequestedsimulationResponse");
	case SOAP_TYPE_ns__requestsimulation:
		return soap_out_ns__requestsimulation(soap, tag, id, (const struct ns__requestsimulation *)ptr, "ns:requestsimulation");
	case SOAP_TYPE_ns__requestsimulationResponse:
		return soap_out_ns__requestsimulationResponse(soap, tag, id, (const struct ns__requestsimulationResponse *)ptr, "ns:requestsimulationResponse");
	case SOAP_TYPE_ns__runsimulation:
		return soap_out_ns__runsimulation(soap, tag, id, (const struct ns__runsimulation *)ptr, "ns:runsimulation");
	case SOAP_TYPE_ns__runsimulationResponse:
		return soap_out_ns__runsimulationResponse(soap, tag, id, (const struct ns__runsimulationResponse *)ptr, "ns:runsimulationResponse");
	case SOAP_TYPE_ns__runsimulationstep:
		return soap_out_ns__runsimulationstep(soap, tag, id, (const struct ns__runsimulationstep *)ptr, "ns:runsimulationstep");
	case SOAP_TYPE_ns__runsimulationstepResponse:
		return soap_out_ns__runsimulationstepResponse(soap, tag, id, (const struct ns__runsimulationstepResponse *)ptr, "ns:runsimulationstepResponse");
	case SOAP_TYPE_ns__setnsteps:
		return soap_out_ns__setnsteps(soap, tag, id, (const struct ns__setnsteps *)ptr, "ns:setnsteps");
	case SOAP_TYPE_ns__setnstepsResponse:
		return soap_out_ns__setnstepsResponse(soap, tag, id, (const struct ns__setnstepsResponse *)ptr, "ns:setnstepsResponse");
	case SOAP_TYPE_ns__getnsteps:
		return soap_out_ns__getnsteps(soap, tag, id, (const struct ns__getnsteps *)ptr, "ns:getnsteps");
	case SOAP_TYPE_ns__getnstepsResponse:
		return soap_out_ns__getnstepsResponse(soap, tag, id, (const struct ns__getnstepsResponse *)ptr, "ns:getnstepsResponse");
	case SOAP_TYPE_ns__setstep:
		return soap_out_ns__setstep(soap, tag, id, (const struct ns__setstep *)ptr, "ns:setstep");
	case SOAP_TYPE_ns__setstepResponse:
		return soap_out_ns__setstepResponse(soap, tag, id, (const struct ns__setstepResponse *)ptr, "ns:setstepResponse");
	case SOAP_TYPE_ns__getstep:
		return soap_out_ns__getstep(soap, tag, id, (const struct ns__getstep *)ptr, "ns:getstep");
	case SOAP_TYPE_ns__getstepResponse:
		return soap_out_ns__getstepResponse(soap, tag, id, (const struct ns__getstepResponse *)ptr, "ns:getstepResponse");
	case SOAP_TYPE_ns__add:
		return soap_out_ns__add(soap, tag, id, (const struct ns__add *)ptr, "ns:add");
	case SOAP_TYPE_ns__addResponse:
		return soap_out_ns__addResponse(soap, tag, id, (const struct ns__addResponse *)ptr, "ns:addResponse");
	case SOAP_TYPE_fdata:
		return soap_out_fdata(soap, tag, id, (const struct fdata *)ptr, "xsd:double");
	case SOAP_TYPE_PointerToPointerTofdata:
		return soap_out_PointerToPointerTofdata(soap, tag, id, (struct fdata **const*)ptr, "xsd:double");
	case SOAP_TYPE_PointerTofdata:
		return soap_out_PointerTofdata(soap, tag, id, (struct fdata *const*)ptr, "xsd:double");
	case SOAP_TYPE_PointerTostring:
		return soap_out_PointerTostring(soap, tag, id, (char **const*)ptr, "xsd:string");
	case SOAP_TYPE_PointerToint:
		return soap_out_PointerToint(soap, tag, id, (int *const*)ptr, "xsd:int");
	case SOAP_TYPE_PointerTodouble:
		return soap_out_PointerTodouble(soap, tag, id, (double *const*)ptr, "xsd:double");
	case SOAP_TYPE__QName:
		return soap_out_string(soap, "QName", id, (char**)&ptr, NULL);
	case SOAP_TYPE_string:
		return soap_out_string(soap, tag, id, (char**)&ptr, "xsd:string");
	}
	return SOAP_OK;
}
#endif

#ifndef WITH_NOIDREF
SOAP_FMAC3 void SOAP_FMAC4 soap_markelement(struct soap *soap, const void *ptr, int type)
{
	(void)soap; (void)ptr; (void)type; /* appease -Wall -Werror */
	switch (type)
	{
	case SOAP_TYPE_ns__setgroupbarrier:
		soap_serialize_ns__setgroupbarrier(soap, (const struct ns__setgroupbarrier *)ptr);
		break;
	case SOAP_TYPE_ns__setgroupbarrierResponse:
		soap_serialize_ns__setgroupbarrierResponse(soap, (const struct ns__setgroupbarrierResponse *)ptr);
		break;
	case SOAP_TYPE_ns__testgroupbarrier:
		soap_serialize_ns__testgroupbarrier(soap, (const struct ns__testgroupbarrier *)ptr);
		break;
	case SOAP_TYPE_ns__testgroupbarrierResponse:
		soap_serialize_ns__testgroupbarrierResponse(soap, (const struct ns__testgroupbarrierResponse *)ptr);
		break;
	case SOAP_TYPE_ns__getobjnum:
		soap_serialize_ns__getobjnum(soap, (const struct ns__getobjnum *)ptr);
		break;
	case SOAP_TYPE_ns__getobjnumResponse:
		soap_serialize_ns__getobjnumResponse(soap, (const struct ns__getobjnumResponse *)ptr);
		break;
	case SOAP_TYPE_ns__getnumobj:
		soap_serialize_ns__getnumobj(soap, (const struct ns__getnumobj *)ptr);
		break;
	case SOAP_TYPE_ns__getnumobjResponse:
		soap_serialize_ns__getnumobjResponse(soap, (const struct ns__getnumobjResponse *)ptr);
		break;
	case SOAP_TYPE_ns__listparam:
		soap_serialize_ns__listparam(soap, (const struct ns__listparam *)ptr);
		break;
	case SOAP_TYPE_ns__listparamResponse:
		soap_serialize_ns__listparamResponse(soap, (const struct ns__listparamResponse *)ptr);
		break;
	case SOAP_TYPE_ns__deleteparam:
		soap_serialize_ns__deleteparam(soap, (const struct ns__deleteparam *)ptr);
		break;
	case SOAP_TYPE_ns__deleteparamResponse:
		soap_serialize_ns__deleteparamResponse(soap, (const struct ns__deleteparamResponse *)ptr);
		break;
	case SOAP_TYPE_ns__deletemetadata:
		soap_serialize_ns__deletemetadata(soap, (const struct ns__deletemetadata *)ptr);
		break;
	case SOAP_TYPE_ns__deletemetadataResponse:
		soap_serialize_ns__deletemetadataResponse(soap, (const struct ns__deletemetadataResponse *)ptr);
		break;
	case SOAP_TYPE_ns__listmetadata:
		soap_serialize_ns__listmetadata(soap, (const struct ns__listmetadata *)ptr);
		break;
	case SOAP_TYPE_ns__listmetadataResponse:
		soap_serialize_ns__listmetadataResponse(soap, (const struct ns__listmetadataResponse *)ptr);
		break;
	case SOAP_TYPE_ns__setmetadata:
		soap_serialize_ns__setmetadata(soap, (const struct ns__setmetadata *)ptr);
		break;
	case SOAP_TYPE_ns__setmetadataResponse:
		soap_serialize_ns__setmetadataResponse(soap, (const struct ns__setmetadataResponse *)ptr);
		break;
	case SOAP_TYPE_ns__setparammmat3d:
		soap_serialize_ns__setparammmat3d(soap, (const struct ns__setparammmat3d *)ptr);
		break;
	case SOAP_TYPE_ns__setparammmat3dResponse:
		soap_serialize_ns__setparammmat3dResponse(soap, (const struct ns__setparammmat3dResponse *)ptr);
		break;
	case SOAP_TYPE_ns__setparamstring:
		soap_serialize_ns__setparamstring(soap, (const struct ns__setparamstring *)ptr);
		break;
	case SOAP_TYPE_ns__setparamstringResponse:
		soap_serialize_ns__setparamstringResponse(soap, (const struct ns__setparamstringResponse *)ptr);
		break;
	case SOAP_TYPE_ns__setparammat:
		soap_serialize_ns__setparammat(soap, (const struct ns__setparammat *)ptr);
		break;
	case SOAP_TYPE_ns__setparammatResponse:
		soap_serialize_ns__setparammatResponse(soap, (const struct ns__setparammatResponse *)ptr);
		break;
	case SOAP_TYPE_ns__setparamvec:
		soap_serialize_ns__setparamvec(soap, (const struct ns__setparamvec *)ptr);
		break;
	case SOAP_TYPE_ns__setparamvecResponse:
		soap_serialize_ns__setparamvecResponse(soap, (const struct ns__setparamvecResponse *)ptr);
		break;
	case SOAP_TYPE_ns__setparamint:
		soap_serialize_ns__setparamint(soap, (const struct ns__setparamint *)ptr);
		break;
	case SOAP_TYPE_ns__setparamintResponse:
		soap_serialize_ns__setparamintResponse(soap, (const struct ns__setparamintResponse *)ptr);
		break;
	case SOAP_TYPE_ns__setparamdouble:
		soap_serialize_ns__setparamdouble(soap, (const struct ns__setparamdouble *)ptr);
		break;
	case SOAP_TYPE_ns__setparamdoubleResponse:
		soap_serialize_ns__setparamdoubleResponse(soap, (const struct ns__setparamdoubleResponse *)ptr);
		break;
	case SOAP_TYPE_ns__getmetadata:
		soap_serialize_ns__getmetadata(soap, (const struct ns__getmetadata *)ptr);
		break;
	case SOAP_TYPE_ns__getmetadataResponse:
		soap_serialize_ns__getmetadataResponse(soap, (const struct ns__getmetadataResponse *)ptr);
		break;
	case SOAP_TYPE_ns__getparammmat3d:
		soap_serialize_ns__getparammmat3d(soap, (const struct ns__getparammmat3d *)ptr);
		break;
	case SOAP_TYPE_ns__getparammmat3dResponse:
		soap_serialize_ns__getparammmat3dResponse(soap, (const struct ns__getparammmat3dResponse *)ptr);
		break;
	case SOAP_TYPE_ns__getparamstring:
		soap_serialize_ns__getparamstring(soap, (const struct ns__getparamstring *)ptr);
		break;
	case SOAP_TYPE_ns__getparamstringResponse:
		soap_serialize_ns__getparamstringResponse(soap, (const struct ns__getparamstringResponse *)ptr);
		break;
	case SOAP_TYPE_ns__getparammat:
		soap_serialize_ns__getparammat(soap, (const struct ns__getparammat *)ptr);
		break;
	case SOAP_TYPE_ns__getparammatResponse:
		soap_serialize_ns__getparammatResponse(soap, (const struct ns__getparammatResponse *)ptr);
		break;
	case SOAP_TYPE_ns__getparamvec:
		soap_serialize_ns__getparamvec(soap, (const struct ns__getparamvec *)ptr);
		break;
	case SOAP_TYPE_ns__getparamvecResponse:
		soap_serialize_ns__getparamvecResponse(soap, (const struct ns__getparamvecResponse *)ptr);
		break;
	case SOAP_TYPE_ns__getparamint:
		soap_serialize_ns__getparamint(soap, (const struct ns__getparamint *)ptr);
		break;
	case SOAP_TYPE_ns__getparamintResponse:
		soap_serialize_ns__getparamintResponse(soap, (const struct ns__getparamintResponse *)ptr);
		break;
	case SOAP_TYPE_ns__getparamdouble:
		soap_serialize_ns__getparamdouble(soap, (const struct ns__getparamdouble *)ptr);
		break;
	case SOAP_TYPE_ns__getparamdoubleResponse:
		soap_serialize_ns__getparamdoubleResponse(soap, (const struct ns__getparamdoubleResponse *)ptr);
		break;
	case SOAP_TYPE_ns__addmetadata:
		soap_serialize_ns__addmetadata(soap, (const struct ns__addmetadata *)ptr);
		break;
	case SOAP_TYPE_ns__addmetadataResponse:
		soap_serialize_ns__addmetadataResponse(soap, (const struct ns__addmetadataResponse *)ptr);
		break;
	case SOAP_TYPE_ns__addparammmat3d:
		soap_serialize_ns__addparammmat3d(soap, (const struct ns__addparammmat3d *)ptr);
		break;
	case SOAP_TYPE_ns__addparammmat3dResponse:
		soap_serialize_ns__addparammmat3dResponse(soap, (const struct ns__addparammmat3dResponse *)ptr);
		break;
	case SOAP_TYPE_ns__addparamstring:
		soap_serialize_ns__addparamstring(soap, (const struct ns__addparamstring *)ptr);
		break;
	case SOAP_TYPE_ns__addparamstringResponse:
		soap_serialize_ns__addparamstringResponse(soap, (const struct ns__addparamstringResponse *)ptr);
		break;
	case SOAP_TYPE_ns__addparammat:
		soap_serialize_ns__addparammat(soap, (const struct ns__addparammat *)ptr);
		break;
	case SOAP_TYPE_ns__addparammatResponse:
		soap_serialize_ns__addparammatResponse(soap, (const struct ns__addparammatResponse *)ptr);
		break;
	case SOAP_TYPE_ns__addparamvec:
		soap_serialize_ns__addparamvec(soap, (const struct ns__addparamvec *)ptr);
		break;
	case SOAP_TYPE_ns__addparamvecResponse:
		soap_serialize_ns__addparamvecResponse(soap, (const struct ns__addparamvecResponse *)ptr);
		break;
	case SOAP_TYPE_ns__addparamint:
		soap_serialize_ns__addparamint(soap, (const struct ns__addparamint *)ptr);
		break;
	case SOAP_TYPE_ns__addparamintResponse:
		soap_serialize_ns__addparamintResponse(soap, (const struct ns__addparamintResponse *)ptr);
		break;
	case SOAP_TYPE_ns__addparamdouble:
		soap_serialize_ns__addparamdouble(soap, (const struct ns__addparamdouble *)ptr);
		break;
	case SOAP_TYPE_ns__addparamdoubleResponse:
		soap_serialize_ns__addparamdoubleResponse(soap, (const struct ns__addparamdoubleResponse *)ptr);
		break;
	case SOAP_TYPE_ns__exitiome:
		soap_serialize_ns__exitiome(soap, (const struct ns__exitiome *)ptr);
		break;
	case SOAP_TYPE_ns__exitiomeResponse:
		soap_serialize_ns__exitiomeResponse(soap, (const struct ns__exitiomeResponse *)ptr);
		break;
	case SOAP_TYPE_ns__readsimulation:
		soap_serialize_ns__readsimulation(soap, (const struct ns__readsimulation *)ptr);
		break;
	case SOAP_TYPE_ns__readsimulationResponse:
		soap_serialize_ns__readsimulationResponse(soap, (const struct ns__readsimulationResponse *)ptr);
		break;
	case SOAP_TYPE_ns__writesimulation:
		soap_serialize_ns__writesimulation(soap, (const struct ns__writesimulation *)ptr);
		break;
	case SOAP_TYPE_ns__writesimulationResponse:
		soap_serialize_ns__writesimulationResponse(soap, (const struct ns__writesimulationResponse *)ptr);
		break;
	case SOAP_TYPE_ns__readlocalsimulation:
		soap_serialize_ns__readlocalsimulation(soap, (const struct ns__readlocalsimulation *)ptr);
		break;
	case SOAP_TYPE_ns__readlocalsimulationResponse:
		soap_serialize_ns__readlocalsimulationResponse(soap, (const struct ns__readlocalsimulationResponse *)ptr);
		break;
	case SOAP_TYPE_ns__writelocalsimulation:
		soap_serialize_ns__writelocalsimulation(soap, (const struct ns__writelocalsimulation *)ptr);
		break;
	case SOAP_TYPE_ns__writelocalsimulationResponse:
		soap_serialize_ns__writelocalsimulationResponse(soap, (const struct ns__writelocalsimulationResponse *)ptr);
		break;
	case SOAP_TYPE_ns__createsimulation:
		soap_serialize_ns__createsimulation(soap, (const struct ns__createsimulation *)ptr);
		break;
	case SOAP_TYPE_ns__createsimulationResponse:
		soap_serialize_ns__createsimulationResponse(soap, (const struct ns__createsimulationResponse *)ptr);
		break;
	case SOAP_TYPE_ns__newsimulation:
		soap_serialize_ns__newsimulation(soap, (const struct ns__newsimulation *)ptr);
		break;
	case SOAP_TYPE_ns__newsimulationResponse:
		soap_serialize_ns__newsimulationResponse(soap, (const struct ns__newsimulationResponse *)ptr);
		break;
	case SOAP_TYPE_ns__deletesimulation:
		soap_serialize_ns__deletesimulation(soap, (const struct ns__deletesimulation *)ptr);
		break;
	case SOAP_TYPE_ns__deletesimulationResponse:
		soap_serialize_ns__deletesimulationResponse(soap, (const struct ns__deletesimulationResponse *)ptr);
		break;
	case SOAP_TYPE_ns__getsimulationresults:
		soap_serialize_ns__getsimulationresults(soap, (const struct ns__getsimulationresults *)ptr);
		break;
	case SOAP_TYPE_ns__getsimulationresultsResponse:
		soap_serialize_ns__getsimulationresultsResponse(soap, (const struct ns__getsimulationresultsResponse *)ptr);
		break;
	case SOAP_TYPE_ns__setsimulationstatus:
		soap_serialize_ns__setsimulationstatus(soap, (const struct ns__setsimulationstatus *)ptr);
		break;
	case SOAP_TYPE_ns__setsimulationstatusResponse:
		soap_serialize_ns__setsimulationstatusResponse(soap, (const struct ns__setsimulationstatusResponse *)ptr);
		break;
	case SOAP_TYPE_ns__simulationstatus:
		soap_serialize_ns__simulationstatus(soap, (const struct ns__simulationstatus *)ptr);
		break;
	case SOAP_TYPE_ns__simulationstatusResponse:
		soap_serialize_ns__simulationstatusResponse(soap, (const struct ns__simulationstatusResponse *)ptr);
		break;
	case SOAP_TYPE_ns__submitsimulation:
		soap_serialize_ns__submitsimulation(soap, (const struct ns__submitsimulation *)ptr);
		break;
	case SOAP_TYPE_ns__submitsimulationResponse:
		soap_serialize_ns__submitsimulationResponse(soap, (const struct ns__submitsimulationResponse *)ptr);
		break;
	case SOAP_TYPE_ns__runrequestedsimulation:
		soap_serialize_ns__runrequestedsimulation(soap, (const struct ns__runrequestedsimulation *)ptr);
		break;
	case SOAP_TYPE_ns__runrequestedsimulationResponse:
		soap_serialize_ns__runrequestedsimulationResponse(soap, (const struct ns__runrequestedsimulationResponse *)ptr);
		break;
	case SOAP_TYPE_ns__requestsimulation:
		soap_serialize_ns__requestsimulation(soap, (const struct ns__requestsimulation *)ptr);
		break;
	case SOAP_TYPE_ns__requestsimulationResponse:
		soap_serialize_ns__requestsimulationResponse(soap, (const struct ns__requestsimulationResponse *)ptr);
		break;
	case SOAP_TYPE_ns__runsimulation:
		soap_serialize_ns__runsimulation(soap, (const struct ns__runsimulation *)ptr);
		break;
	case SOAP_TYPE_ns__runsimulationResponse:
		soap_serialize_ns__runsimulationResponse(soap, (const struct ns__runsimulationResponse *)ptr);
		break;
	case SOAP_TYPE_ns__runsimulationstep:
		soap_serialize_ns__runsimulationstep(soap, (const struct ns__runsimulationstep *)ptr);
		break;
	case SOAP_TYPE_ns__runsimulationstepResponse:
		soap_serialize_ns__runsimulationstepResponse(soap, (const struct ns__runsimulationstepResponse *)ptr);
		break;
	case SOAP_TYPE_ns__setnsteps:
		soap_serialize_ns__setnsteps(soap, (const struct ns__setnsteps *)ptr);
		break;
	case SOAP_TYPE_ns__setnstepsResponse:
		soap_serialize_ns__setnstepsResponse(soap, (const struct ns__setnstepsResponse *)ptr);
		break;
	case SOAP_TYPE_ns__getnsteps:
		soap_serialize_ns__getnsteps(soap, (const struct ns__getnsteps *)ptr);
		break;
	case SOAP_TYPE_ns__getnstepsResponse:
		soap_serialize_ns__getnstepsResponse(soap, (const struct ns__getnstepsResponse *)ptr);
		break;
	case SOAP_TYPE_ns__setstep:
		soap_serialize_ns__setstep(soap, (const struct ns__setstep *)ptr);
		break;
	case SOAP_TYPE_ns__setstepResponse:
		soap_serialize_ns__setstepResponse(soap, (const struct ns__setstepResponse *)ptr);
		break;
	case SOAP_TYPE_ns__getstep:
		soap_serialize_ns__getstep(soap, (const struct ns__getstep *)ptr);
		break;
	case SOAP_TYPE_ns__getstepResponse:
		soap_serialize_ns__getstepResponse(soap, (const struct ns__getstepResponse *)ptr);
		break;
	case SOAP_TYPE_ns__add:
		soap_serialize_ns__add(soap, (const struct ns__add *)ptr);
		break;
	case SOAP_TYPE_ns__addResponse:
		soap_serialize_ns__addResponse(soap, (const struct ns__addResponse *)ptr);
		break;
	case SOAP_TYPE_fdata:
		soap_serialize_fdata(soap, (const struct fdata *)ptr);
		break;
	case SOAP_TYPE_PointerToPointerTofdata:
		soap_serialize_PointerToPointerTofdata(soap, (struct fdata **const*)ptr);
		break;
	case SOAP_TYPE_PointerTofdata:
		soap_serialize_PointerTofdata(soap, (struct fdata *const*)ptr);
		break;
	case SOAP_TYPE_PointerTostring:
		soap_serialize_PointerTostring(soap, (char **const*)ptr);
		break;
	case SOAP_TYPE_PointerToint:
		soap_serialize_PointerToint(soap, (int *const*)ptr);
		break;
	case SOAP_TYPE_PointerTodouble:
		soap_serialize_PointerTodouble(soap, (double *const*)ptr);
		break;
	case SOAP_TYPE__QName:
		soap_serialize_string(soap, (char**)&ptr);
		break;
	case SOAP_TYPE_string:
		soap_serialize_string(soap, (char**)&ptr);
		break;
	}
}
#endif

SOAP_FMAC3 void * SOAP_FMAC4 soap_instantiate(struct soap *soap, int t, const char *type, const char *arrayType, size_t *n)
{
	switch (t)
	{
	case SOAP_TYPE_fdata:
		return (void*)soap_instantiate_fdata(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns__addResponse:
		return (void*)soap_instantiate_ns__addResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns__add:
		return (void*)soap_instantiate_ns__add(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns__getstepResponse:
		return (void*)soap_instantiate_ns__getstepResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns__getstep:
		return (void*)soap_instantiate_ns__getstep(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns__setstepResponse:
		return (void*)soap_instantiate_ns__setstepResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns__setstep:
		return (void*)soap_instantiate_ns__setstep(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns__getnstepsResponse:
		return (void*)soap_instantiate_ns__getnstepsResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns__getnsteps:
		return (void*)soap_instantiate_ns__getnsteps(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns__setnstepsResponse:
		return (void*)soap_instantiate_ns__setnstepsResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns__setnsteps:
		return (void*)soap_instantiate_ns__setnsteps(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns__runsimulationstepResponse:
		return (void*)soap_instantiate_ns__runsimulationstepResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns__runsimulationstep:
		return (void*)soap_instantiate_ns__runsimulationstep(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns__runsimulationResponse:
		return (void*)soap_instantiate_ns__runsimulationResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns__runsimulation:
		return (void*)soap_instantiate_ns__runsimulation(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns__requestsimulationResponse:
		return (void*)soap_instantiate_ns__requestsimulationResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns__requestsimulation:
		return (void*)soap_instantiate_ns__requestsimulation(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns__runrequestedsimulationResponse:
		return (void*)soap_instantiate_ns__runrequestedsimulationResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns__runrequestedsimulation:
		return (void*)soap_instantiate_ns__runrequestedsimulation(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns__submitsimulationResponse:
		return (void*)soap_instantiate_ns__submitsimulationResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns__submitsimulation:
		return (void*)soap_instantiate_ns__submitsimulation(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns__simulationstatusResponse:
		return (void*)soap_instantiate_ns__simulationstatusResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns__simulationstatus:
		return (void*)soap_instantiate_ns__simulationstatus(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns__setsimulationstatusResponse:
		return (void*)soap_instantiate_ns__setsimulationstatusResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns__setsimulationstatus:
		return (void*)soap_instantiate_ns__setsimulationstatus(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns__getsimulationresultsResponse:
		return (void*)soap_instantiate_ns__getsimulationresultsResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns__getsimulationresults:
		return (void*)soap_instantiate_ns__getsimulationresults(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns__deletesimulationResponse:
		return (void*)soap_instantiate_ns__deletesimulationResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns__deletesimulation:
		return (void*)soap_instantiate_ns__deletesimulation(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns__newsimulationResponse:
		return (void*)soap_instantiate_ns__newsimulationResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns__newsimulation:
		return (void*)soap_instantiate_ns__newsimulation(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns__createsimulationResponse:
		return (void*)soap_instantiate_ns__createsimulationResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns__createsimulation:
		return (void*)soap_instantiate_ns__createsimulation(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns__writelocalsimulationResponse:
		return (void*)soap_instantiate_ns__writelocalsimulationResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns__writelocalsimulation:
		return (void*)soap_instantiate_ns__writelocalsimulation(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns__readlocalsimulationResponse:
		return (void*)soap_instantiate_ns__readlocalsimulationResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns__readlocalsimulation:
		return (void*)soap_instantiate_ns__readlocalsimulation(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns__writesimulationResponse:
		return (void*)soap_instantiate_ns__writesimulationResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns__writesimulation:
		return (void*)soap_instantiate_ns__writesimulation(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns__readsimulationResponse:
		return (void*)soap_instantiate_ns__readsimulationResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns__readsimulation:
		return (void*)soap_instantiate_ns__readsimulation(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns__exitiomeResponse:
		return (void*)soap_instantiate_ns__exitiomeResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns__exitiome:
		return (void*)soap_instantiate_ns__exitiome(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns__addparamdoubleResponse:
		return (void*)soap_instantiate_ns__addparamdoubleResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns__addparamdouble:
		return (void*)soap_instantiate_ns__addparamdouble(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns__addparamintResponse:
		return (void*)soap_instantiate_ns__addparamintResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns__addparamint:
		return (void*)soap_instantiate_ns__addparamint(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns__addparamvecResponse:
		return (void*)soap_instantiate_ns__addparamvecResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns__addparamvec:
		return (void*)soap_instantiate_ns__addparamvec(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns__addparammatResponse:
		return (void*)soap_instantiate_ns__addparammatResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns__addparammat:
		return (void*)soap_instantiate_ns__addparammat(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns__addparamstringResponse:
		return (void*)soap_instantiate_ns__addparamstringResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns__addparamstring:
		return (void*)soap_instantiate_ns__addparamstring(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns__addparammmat3dResponse:
		return (void*)soap_instantiate_ns__addparammmat3dResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns__addparammmat3d:
		return (void*)soap_instantiate_ns__addparammmat3d(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns__addmetadataResponse:
		return (void*)soap_instantiate_ns__addmetadataResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns__addmetadata:
		return (void*)soap_instantiate_ns__addmetadata(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns__getparamdoubleResponse:
		return (void*)soap_instantiate_ns__getparamdoubleResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns__getparamdouble:
		return (void*)soap_instantiate_ns__getparamdouble(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns__getparamintResponse:
		return (void*)soap_instantiate_ns__getparamintResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns__getparamint:
		return (void*)soap_instantiate_ns__getparamint(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns__getparamvecResponse:
		return (void*)soap_instantiate_ns__getparamvecResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns__getparamvec:
		return (void*)soap_instantiate_ns__getparamvec(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns__getparammatResponse:
		return (void*)soap_instantiate_ns__getparammatResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns__getparammat:
		return (void*)soap_instantiate_ns__getparammat(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns__getparamstringResponse:
		return (void*)soap_instantiate_ns__getparamstringResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns__getparamstring:
		return (void*)soap_instantiate_ns__getparamstring(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns__getparammmat3dResponse:
		return (void*)soap_instantiate_ns__getparammmat3dResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns__getparammmat3d:
		return (void*)soap_instantiate_ns__getparammmat3d(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns__getmetadataResponse:
		return (void*)soap_instantiate_ns__getmetadataResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns__getmetadata:
		return (void*)soap_instantiate_ns__getmetadata(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns__setparamdoubleResponse:
		return (void*)soap_instantiate_ns__setparamdoubleResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns__setparamdouble:
		return (void*)soap_instantiate_ns__setparamdouble(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns__setparamintResponse:
		return (void*)soap_instantiate_ns__setparamintResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns__setparamint:
		return (void*)soap_instantiate_ns__setparamint(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns__setparamvecResponse:
		return (void*)soap_instantiate_ns__setparamvecResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns__setparamvec:
		return (void*)soap_instantiate_ns__setparamvec(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns__setparammatResponse:
		return (void*)soap_instantiate_ns__setparammatResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns__setparammat:
		return (void*)soap_instantiate_ns__setparammat(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns__setparamstringResponse:
		return (void*)soap_instantiate_ns__setparamstringResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns__setparamstring:
		return (void*)soap_instantiate_ns__setparamstring(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns__setparammmat3dResponse:
		return (void*)soap_instantiate_ns__setparammmat3dResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns__setparammmat3d:
		return (void*)soap_instantiate_ns__setparammmat3d(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns__setmetadataResponse:
		return (void*)soap_instantiate_ns__setmetadataResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns__setmetadata:
		return (void*)soap_instantiate_ns__setmetadata(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns__listmetadataResponse:
		return (void*)soap_instantiate_ns__listmetadataResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns__listmetadata:
		return (void*)soap_instantiate_ns__listmetadata(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns__deletemetadataResponse:
		return (void*)soap_instantiate_ns__deletemetadataResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns__deletemetadata:
		return (void*)soap_instantiate_ns__deletemetadata(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns__deleteparamResponse:
		return (void*)soap_instantiate_ns__deleteparamResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns__deleteparam:
		return (void*)soap_instantiate_ns__deleteparam(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns__listparamResponse:
		return (void*)soap_instantiate_ns__listparamResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns__listparam:
		return (void*)soap_instantiate_ns__listparam(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns__getnumobjResponse:
		return (void*)soap_instantiate_ns__getnumobjResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns__getnumobj:
		return (void*)soap_instantiate_ns__getnumobj(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns__getobjnumResponse:
		return (void*)soap_instantiate_ns__getobjnumResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns__getobjnum:
		return (void*)soap_instantiate_ns__getobjnum(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns__testgroupbarrierResponse:
		return (void*)soap_instantiate_ns__testgroupbarrierResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns__testgroupbarrier:
		return (void*)soap_instantiate_ns__testgroupbarrier(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns__setgroupbarrierResponse:
		return (void*)soap_instantiate_ns__setgroupbarrierResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns__setgroupbarrier:
		return (void*)soap_instantiate_ns__setgroupbarrier(soap, -1, type, arrayType, n);
	}
	return NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_fdelete(struct soap_clist *p)
{	switch (p->type)
	{
	case SOAP_TYPE_fdata:
		if (p->size < 0)
			delete (struct fdata*)p->ptr;
		else
			delete[] (struct fdata*)p->ptr;
		break;
	case SOAP_TYPE_ns__addResponse:
		if (p->size < 0)
			delete (struct ns__addResponse*)p->ptr;
		else
			delete[] (struct ns__addResponse*)p->ptr;
		break;
	case SOAP_TYPE_ns__add:
		if (p->size < 0)
			delete (struct ns__add*)p->ptr;
		else
			delete[] (struct ns__add*)p->ptr;
		break;
	case SOAP_TYPE_ns__getstepResponse:
		if (p->size < 0)
			delete (struct ns__getstepResponse*)p->ptr;
		else
			delete[] (struct ns__getstepResponse*)p->ptr;
		break;
	case SOAP_TYPE_ns__getstep:
		if (p->size < 0)
			delete (struct ns__getstep*)p->ptr;
		else
			delete[] (struct ns__getstep*)p->ptr;
		break;
	case SOAP_TYPE_ns__setstepResponse:
		if (p->size < 0)
			delete (struct ns__setstepResponse*)p->ptr;
		else
			delete[] (struct ns__setstepResponse*)p->ptr;
		break;
	case SOAP_TYPE_ns__setstep:
		if (p->size < 0)
			delete (struct ns__setstep*)p->ptr;
		else
			delete[] (struct ns__setstep*)p->ptr;
		break;
	case SOAP_TYPE_ns__getnstepsResponse:
		if (p->size < 0)
			delete (struct ns__getnstepsResponse*)p->ptr;
		else
			delete[] (struct ns__getnstepsResponse*)p->ptr;
		break;
	case SOAP_TYPE_ns__getnsteps:
		if (p->size < 0)
			delete (struct ns__getnsteps*)p->ptr;
		else
			delete[] (struct ns__getnsteps*)p->ptr;
		break;
	case SOAP_TYPE_ns__setnstepsResponse:
		if (p->size < 0)
			delete (struct ns__setnstepsResponse*)p->ptr;
		else
			delete[] (struct ns__setnstepsResponse*)p->ptr;
		break;
	case SOAP_TYPE_ns__setnsteps:
		if (p->size < 0)
			delete (struct ns__setnsteps*)p->ptr;
		else
			delete[] (struct ns__setnsteps*)p->ptr;
		break;
	case SOAP_TYPE_ns__runsimulationstepResponse:
		if (p->size < 0)
			delete (struct ns__runsimulationstepResponse*)p->ptr;
		else
			delete[] (struct ns__runsimulationstepResponse*)p->ptr;
		break;
	case SOAP_TYPE_ns__runsimulationstep:
		if (p->size < 0)
			delete (struct ns__runsimulationstep*)p->ptr;
		else
			delete[] (struct ns__runsimulationstep*)p->ptr;
		break;
	case SOAP_TYPE_ns__runsimulationResponse:
		if (p->size < 0)
			delete (struct ns__runsimulationResponse*)p->ptr;
		else
			delete[] (struct ns__runsimulationResponse*)p->ptr;
		break;
	case SOAP_TYPE_ns__runsimulation:
		if (p->size < 0)
			delete (struct ns__runsimulation*)p->ptr;
		else
			delete[] (struct ns__runsimulation*)p->ptr;
		break;
	case SOAP_TYPE_ns__requestsimulationResponse:
		if (p->size < 0)
			delete (struct ns__requestsimulationResponse*)p->ptr;
		else
			delete[] (struct ns__requestsimulationResponse*)p->ptr;
		break;
	case SOAP_TYPE_ns__requestsimulation:
		if (p->size < 0)
			delete (struct ns__requestsimulation*)p->ptr;
		else
			delete[] (struct ns__requestsimulation*)p->ptr;
		break;
	case SOAP_TYPE_ns__runrequestedsimulationResponse:
		if (p->size < 0)
			delete (struct ns__runrequestedsimulationResponse*)p->ptr;
		else
			delete[] (struct ns__runrequestedsimulationResponse*)p->ptr;
		break;
	case SOAP_TYPE_ns__runrequestedsimulation:
		if (p->size < 0)
			delete (struct ns__runrequestedsimulation*)p->ptr;
		else
			delete[] (struct ns__runrequestedsimulation*)p->ptr;
		break;
	case SOAP_TYPE_ns__submitsimulationResponse:
		if (p->size < 0)
			delete (struct ns__submitsimulationResponse*)p->ptr;
		else
			delete[] (struct ns__submitsimulationResponse*)p->ptr;
		break;
	case SOAP_TYPE_ns__submitsimulation:
		if (p->size < 0)
			delete (struct ns__submitsimulation*)p->ptr;
		else
			delete[] (struct ns__submitsimulation*)p->ptr;
		break;
	case SOAP_TYPE_ns__simulationstatusResponse:
		if (p->size < 0)
			delete (struct ns__simulationstatusResponse*)p->ptr;
		else
			delete[] (struct ns__simulationstatusResponse*)p->ptr;
		break;
	case SOAP_TYPE_ns__simulationstatus:
		if (p->size < 0)
			delete (struct ns__simulationstatus*)p->ptr;
		else
			delete[] (struct ns__simulationstatus*)p->ptr;
		break;
	case SOAP_TYPE_ns__setsimulationstatusResponse:
		if (p->size < 0)
			delete (struct ns__setsimulationstatusResponse*)p->ptr;
		else
			delete[] (struct ns__setsimulationstatusResponse*)p->ptr;
		break;
	case SOAP_TYPE_ns__setsimulationstatus:
		if (p->size < 0)
			delete (struct ns__setsimulationstatus*)p->ptr;
		else
			delete[] (struct ns__setsimulationstatus*)p->ptr;
		break;
	case SOAP_TYPE_ns__getsimulationresultsResponse:
		if (p->size < 0)
			delete (struct ns__getsimulationresultsResponse*)p->ptr;
		else
			delete[] (struct ns__getsimulationresultsResponse*)p->ptr;
		break;
	case SOAP_TYPE_ns__getsimulationresults:
		if (p->size < 0)
			delete (struct ns__getsimulationresults*)p->ptr;
		else
			delete[] (struct ns__getsimulationresults*)p->ptr;
		break;
	case SOAP_TYPE_ns__deletesimulationResponse:
		if (p->size < 0)
			delete (struct ns__deletesimulationResponse*)p->ptr;
		else
			delete[] (struct ns__deletesimulationResponse*)p->ptr;
		break;
	case SOAP_TYPE_ns__deletesimulation:
		if (p->size < 0)
			delete (struct ns__deletesimulation*)p->ptr;
		else
			delete[] (struct ns__deletesimulation*)p->ptr;
		break;
	case SOAP_TYPE_ns__newsimulationResponse:
		if (p->size < 0)
			delete (struct ns__newsimulationResponse*)p->ptr;
		else
			delete[] (struct ns__newsimulationResponse*)p->ptr;
		break;
	case SOAP_TYPE_ns__newsimulation:
		if (p->size < 0)
			delete (struct ns__newsimulation*)p->ptr;
		else
			delete[] (struct ns__newsimulation*)p->ptr;
		break;
	case SOAP_TYPE_ns__createsimulationResponse:
		if (p->size < 0)
			delete (struct ns__createsimulationResponse*)p->ptr;
		else
			delete[] (struct ns__createsimulationResponse*)p->ptr;
		break;
	case SOAP_TYPE_ns__createsimulation:
		if (p->size < 0)
			delete (struct ns__createsimulation*)p->ptr;
		else
			delete[] (struct ns__createsimulation*)p->ptr;
		break;
	case SOAP_TYPE_ns__writelocalsimulationResponse:
		if (p->size < 0)
			delete (struct ns__writelocalsimulationResponse*)p->ptr;
		else
			delete[] (struct ns__writelocalsimulationResponse*)p->ptr;
		break;
	case SOAP_TYPE_ns__writelocalsimulation:
		if (p->size < 0)
			delete (struct ns__writelocalsimulation*)p->ptr;
		else
			delete[] (struct ns__writelocalsimulation*)p->ptr;
		break;
	case SOAP_TYPE_ns__readlocalsimulationResponse:
		if (p->size < 0)
			delete (struct ns__readlocalsimulationResponse*)p->ptr;
		else
			delete[] (struct ns__readlocalsimulationResponse*)p->ptr;
		break;
	case SOAP_TYPE_ns__readlocalsimulation:
		if (p->size < 0)
			delete (struct ns__readlocalsimulation*)p->ptr;
		else
			delete[] (struct ns__readlocalsimulation*)p->ptr;
		break;
	case SOAP_TYPE_ns__writesimulationResponse:
		if (p->size < 0)
			delete (struct ns__writesimulationResponse*)p->ptr;
		else
			delete[] (struct ns__writesimulationResponse*)p->ptr;
		break;
	case SOAP_TYPE_ns__writesimulation:
		if (p->size < 0)
			delete (struct ns__writesimulation*)p->ptr;
		else
			delete[] (struct ns__writesimulation*)p->ptr;
		break;
	case SOAP_TYPE_ns__readsimulationResponse:
		if (p->size < 0)
			delete (struct ns__readsimulationResponse*)p->ptr;
		else
			delete[] (struct ns__readsimulationResponse*)p->ptr;
		break;
	case SOAP_TYPE_ns__readsimulation:
		if (p->size < 0)
			delete (struct ns__readsimulation*)p->ptr;
		else
			delete[] (struct ns__readsimulation*)p->ptr;
		break;
	case SOAP_TYPE_ns__exitiomeResponse:
		if (p->size < 0)
			delete (struct ns__exitiomeResponse*)p->ptr;
		else
			delete[] (struct ns__exitiomeResponse*)p->ptr;
		break;
	case SOAP_TYPE_ns__exitiome:
		if (p->size < 0)
			delete (struct ns__exitiome*)p->ptr;
		else
			delete[] (struct ns__exitiome*)p->ptr;
		break;
	case SOAP_TYPE_ns__addparamdoubleResponse:
		if (p->size < 0)
			delete (struct ns__addparamdoubleResponse*)p->ptr;
		else
			delete[] (struct ns__addparamdoubleResponse*)p->ptr;
		break;
	case SOAP_TYPE_ns__addparamdouble:
		if (p->size < 0)
			delete (struct ns__addparamdouble*)p->ptr;
		else
			delete[] (struct ns__addparamdouble*)p->ptr;
		break;
	case SOAP_TYPE_ns__addparamintResponse:
		if (p->size < 0)
			delete (struct ns__addparamintResponse*)p->ptr;
		else
			delete[] (struct ns__addparamintResponse*)p->ptr;
		break;
	case SOAP_TYPE_ns__addparamint:
		if (p->size < 0)
			delete (struct ns__addparamint*)p->ptr;
		else
			delete[] (struct ns__addparamint*)p->ptr;
		break;
	case SOAP_TYPE_ns__addparamvecResponse:
		if (p->size < 0)
			delete (struct ns__addparamvecResponse*)p->ptr;
		else
			delete[] (struct ns__addparamvecResponse*)p->ptr;
		break;
	case SOAP_TYPE_ns__addparamvec:
		if (p->size < 0)
			delete (struct ns__addparamvec*)p->ptr;
		else
			delete[] (struct ns__addparamvec*)p->ptr;
		break;
	case SOAP_TYPE_ns__addparammatResponse:
		if (p->size < 0)
			delete (struct ns__addparammatResponse*)p->ptr;
		else
			delete[] (struct ns__addparammatResponse*)p->ptr;
		break;
	case SOAP_TYPE_ns__addparammat:
		if (p->size < 0)
			delete (struct ns__addparammat*)p->ptr;
		else
			delete[] (struct ns__addparammat*)p->ptr;
		break;
	case SOAP_TYPE_ns__addparamstringResponse:
		if (p->size < 0)
			delete (struct ns__addparamstringResponse*)p->ptr;
		else
			delete[] (struct ns__addparamstringResponse*)p->ptr;
		break;
	case SOAP_TYPE_ns__addparamstring:
		if (p->size < 0)
			delete (struct ns__addparamstring*)p->ptr;
		else
			delete[] (struct ns__addparamstring*)p->ptr;
		break;
	case SOAP_TYPE_ns__addparammmat3dResponse:
		if (p->size < 0)
			delete (struct ns__addparammmat3dResponse*)p->ptr;
		else
			delete[] (struct ns__addparammmat3dResponse*)p->ptr;
		break;
	case SOAP_TYPE_ns__addparammmat3d:
		if (p->size < 0)
			delete (struct ns__addparammmat3d*)p->ptr;
		else
			delete[] (struct ns__addparammmat3d*)p->ptr;
		break;
	case SOAP_TYPE_ns__addmetadataResponse:
		if (p->size < 0)
			delete (struct ns__addmetadataResponse*)p->ptr;
		else
			delete[] (struct ns__addmetadataResponse*)p->ptr;
		break;
	case SOAP_TYPE_ns__addmetadata:
		if (p->size < 0)
			delete (struct ns__addmetadata*)p->ptr;
		else
			delete[] (struct ns__addmetadata*)p->ptr;
		break;
	case SOAP_TYPE_ns__getparamdoubleResponse:
		if (p->size < 0)
			delete (struct ns__getparamdoubleResponse*)p->ptr;
		else
			delete[] (struct ns__getparamdoubleResponse*)p->ptr;
		break;
	case SOAP_TYPE_ns__getparamdouble:
		if (p->size < 0)
			delete (struct ns__getparamdouble*)p->ptr;
		else
			delete[] (struct ns__getparamdouble*)p->ptr;
		break;
	case SOAP_TYPE_ns__getparamintResponse:
		if (p->size < 0)
			delete (struct ns__getparamintResponse*)p->ptr;
		else
			delete[] (struct ns__getparamintResponse*)p->ptr;
		break;
	case SOAP_TYPE_ns__getparamint:
		if (p->size < 0)
			delete (struct ns__getparamint*)p->ptr;
		else
			delete[] (struct ns__getparamint*)p->ptr;
		break;
	case SOAP_TYPE_ns__getparamvecResponse:
		if (p->size < 0)
			delete (struct ns__getparamvecResponse*)p->ptr;
		else
			delete[] (struct ns__getparamvecResponse*)p->ptr;
		break;
	case SOAP_TYPE_ns__getparamvec:
		if (p->size < 0)
			delete (struct ns__getparamvec*)p->ptr;
		else
			delete[] (struct ns__getparamvec*)p->ptr;
		break;
	case SOAP_TYPE_ns__getparammatResponse:
		if (p->size < 0)
			delete (struct ns__getparammatResponse*)p->ptr;
		else
			delete[] (struct ns__getparammatResponse*)p->ptr;
		break;
	case SOAP_TYPE_ns__getparammat:
		if (p->size < 0)
			delete (struct ns__getparammat*)p->ptr;
		else
			delete[] (struct ns__getparammat*)p->ptr;
		break;
	case SOAP_TYPE_ns__getparamstringResponse:
		if (p->size < 0)
			delete (struct ns__getparamstringResponse*)p->ptr;
		else
			delete[] (struct ns__getparamstringResponse*)p->ptr;
		break;
	case SOAP_TYPE_ns__getparamstring:
		if (p->size < 0)
			delete (struct ns__getparamstring*)p->ptr;
		else
			delete[] (struct ns__getparamstring*)p->ptr;
		break;
	case SOAP_TYPE_ns__getparammmat3dResponse:
		if (p->size < 0)
			delete (struct ns__getparammmat3dResponse*)p->ptr;
		else
			delete[] (struct ns__getparammmat3dResponse*)p->ptr;
		break;
	case SOAP_TYPE_ns__getparammmat3d:
		if (p->size < 0)
			delete (struct ns__getparammmat3d*)p->ptr;
		else
			delete[] (struct ns__getparammmat3d*)p->ptr;
		break;
	case SOAP_TYPE_ns__getmetadataResponse:
		if (p->size < 0)
			delete (struct ns__getmetadataResponse*)p->ptr;
		else
			delete[] (struct ns__getmetadataResponse*)p->ptr;
		break;
	case SOAP_TYPE_ns__getmetadata:
		if (p->size < 0)
			delete (struct ns__getmetadata*)p->ptr;
		else
			delete[] (struct ns__getmetadata*)p->ptr;
		break;
	case SOAP_TYPE_ns__setparamdoubleResponse:
		if (p->size < 0)
			delete (struct ns__setparamdoubleResponse*)p->ptr;
		else
			delete[] (struct ns__setparamdoubleResponse*)p->ptr;
		break;
	case SOAP_TYPE_ns__setparamdouble:
		if (p->size < 0)
			delete (struct ns__setparamdouble*)p->ptr;
		else
			delete[] (struct ns__setparamdouble*)p->ptr;
		break;
	case SOAP_TYPE_ns__setparamintResponse:
		if (p->size < 0)
			delete (struct ns__setparamintResponse*)p->ptr;
		else
			delete[] (struct ns__setparamintResponse*)p->ptr;
		break;
	case SOAP_TYPE_ns__setparamint:
		if (p->size < 0)
			delete (struct ns__setparamint*)p->ptr;
		else
			delete[] (struct ns__setparamint*)p->ptr;
		break;
	case SOAP_TYPE_ns__setparamvecResponse:
		if (p->size < 0)
			delete (struct ns__setparamvecResponse*)p->ptr;
		else
			delete[] (struct ns__setparamvecResponse*)p->ptr;
		break;
	case SOAP_TYPE_ns__setparamvec:
		if (p->size < 0)
			delete (struct ns__setparamvec*)p->ptr;
		else
			delete[] (struct ns__setparamvec*)p->ptr;
		break;
	case SOAP_TYPE_ns__setparammatResponse:
		if (p->size < 0)
			delete (struct ns__setparammatResponse*)p->ptr;
		else
			delete[] (struct ns__setparammatResponse*)p->ptr;
		break;
	case SOAP_TYPE_ns__setparammat:
		if (p->size < 0)
			delete (struct ns__setparammat*)p->ptr;
		else
			delete[] (struct ns__setparammat*)p->ptr;
		break;
	case SOAP_TYPE_ns__setparamstringResponse:
		if (p->size < 0)
			delete (struct ns__setparamstringResponse*)p->ptr;
		else
			delete[] (struct ns__setparamstringResponse*)p->ptr;
		break;
	case SOAP_TYPE_ns__setparamstring:
		if (p->size < 0)
			delete (struct ns__setparamstring*)p->ptr;
		else
			delete[] (struct ns__setparamstring*)p->ptr;
		break;
	case SOAP_TYPE_ns__setparammmat3dResponse:
		if (p->size < 0)
			delete (struct ns__setparammmat3dResponse*)p->ptr;
		else
			delete[] (struct ns__setparammmat3dResponse*)p->ptr;
		break;
	case SOAP_TYPE_ns__setparammmat3d:
		if (p->size < 0)
			delete (struct ns__setparammmat3d*)p->ptr;
		else
			delete[] (struct ns__setparammmat3d*)p->ptr;
		break;
	case SOAP_TYPE_ns__setmetadataResponse:
		if (p->size < 0)
			delete (struct ns__setmetadataResponse*)p->ptr;
		else
			delete[] (struct ns__setmetadataResponse*)p->ptr;
		break;
	case SOAP_TYPE_ns__setmetadata:
		if (p->size < 0)
			delete (struct ns__setmetadata*)p->ptr;
		else
			delete[] (struct ns__setmetadata*)p->ptr;
		break;
	case SOAP_TYPE_ns__listmetadataResponse:
		if (p->size < 0)
			delete (struct ns__listmetadataResponse*)p->ptr;
		else
			delete[] (struct ns__listmetadataResponse*)p->ptr;
		break;
	case SOAP_TYPE_ns__listmetadata:
		if (p->size < 0)
			delete (struct ns__listmetadata*)p->ptr;
		else
			delete[] (struct ns__listmetadata*)p->ptr;
		break;
	case SOAP_TYPE_ns__deletemetadataResponse:
		if (p->size < 0)
			delete (struct ns__deletemetadataResponse*)p->ptr;
		else
			delete[] (struct ns__deletemetadataResponse*)p->ptr;
		break;
	case SOAP_TYPE_ns__deletemetadata:
		if (p->size < 0)
			delete (struct ns__deletemetadata*)p->ptr;
		else
			delete[] (struct ns__deletemetadata*)p->ptr;
		break;
	case SOAP_TYPE_ns__deleteparamResponse:
		if (p->size < 0)
			delete (struct ns__deleteparamResponse*)p->ptr;
		else
			delete[] (struct ns__deleteparamResponse*)p->ptr;
		break;
	case SOAP_TYPE_ns__deleteparam:
		if (p->size < 0)
			delete (struct ns__deleteparam*)p->ptr;
		else
			delete[] (struct ns__deleteparam*)p->ptr;
		break;
	case SOAP_TYPE_ns__listparamResponse:
		if (p->size < 0)
			delete (struct ns__listparamResponse*)p->ptr;
		else
			delete[] (struct ns__listparamResponse*)p->ptr;
		break;
	case SOAP_TYPE_ns__listparam:
		if (p->size < 0)
			delete (struct ns__listparam*)p->ptr;
		else
			delete[] (struct ns__listparam*)p->ptr;
		break;
	case SOAP_TYPE_ns__getnumobjResponse:
		if (p->size < 0)
			delete (struct ns__getnumobjResponse*)p->ptr;
		else
			delete[] (struct ns__getnumobjResponse*)p->ptr;
		break;
	case SOAP_TYPE_ns__getnumobj:
		if (p->size < 0)
			delete (struct ns__getnumobj*)p->ptr;
		else
			delete[] (struct ns__getnumobj*)p->ptr;
		break;
	case SOAP_TYPE_ns__getobjnumResponse:
		if (p->size < 0)
			delete (struct ns__getobjnumResponse*)p->ptr;
		else
			delete[] (struct ns__getobjnumResponse*)p->ptr;
		break;
	case SOAP_TYPE_ns__getobjnum:
		if (p->size < 0)
			delete (struct ns__getobjnum*)p->ptr;
		else
			delete[] (struct ns__getobjnum*)p->ptr;
		break;
	case SOAP_TYPE_ns__testgroupbarrierResponse:
		if (p->size < 0)
			delete (struct ns__testgroupbarrierResponse*)p->ptr;
		else
			delete[] (struct ns__testgroupbarrierResponse*)p->ptr;
		break;
	case SOAP_TYPE_ns__testgroupbarrier:
		if (p->size < 0)
			delete (struct ns__testgroupbarrier*)p->ptr;
		else
			delete[] (struct ns__testgroupbarrier*)p->ptr;
		break;
	case SOAP_TYPE_ns__setgroupbarrierResponse:
		if (p->size < 0)
			delete (struct ns__setgroupbarrierResponse*)p->ptr;
		else
			delete[] (struct ns__setgroupbarrierResponse*)p->ptr;
		break;
	case SOAP_TYPE_ns__setgroupbarrier:
		if (p->size < 0)
			delete (struct ns__setgroupbarrier*)p->ptr;
		else
			delete[] (struct ns__setgroupbarrier*)p->ptr;
		break;
	case SOAP_TYPE_SOAP_ENV__Header:
		if (p->size < 0)
			delete (struct SOAP_ENV__Header*)p->ptr;
		else
			delete[] (struct SOAP_ENV__Header*)p->ptr;
		break;
	case SOAP_TYPE_SOAP_ENV__Code:
		if (p->size < 0)
			delete (struct SOAP_ENV__Code*)p->ptr;
		else
			delete[] (struct SOAP_ENV__Code*)p->ptr;
		break;
	case SOAP_TYPE_SOAP_ENV__Detail:
		if (p->size < 0)
			delete (struct SOAP_ENV__Detail*)p->ptr;
		else
			delete[] (struct SOAP_ENV__Detail*)p->ptr;
		break;
	case SOAP_TYPE_SOAP_ENV__Reason:
		if (p->size < 0)
			delete (struct SOAP_ENV__Reason*)p->ptr;
		else
			delete[] (struct SOAP_ENV__Reason*)p->ptr;
		break;
	case SOAP_TYPE_SOAP_ENV__Fault:
		if (p->size < 0)
			delete (struct SOAP_ENV__Fault*)p->ptr;
		else
			delete[] (struct SOAP_ENV__Fault*)p->ptr;
		break;
	}
}

SOAP_FMAC3 void* SOAP_FMAC4 soap_class_id_enter(struct soap *soap, const char *id, void *p, int t, size_t n, const char *type, const char *arrayType)
{	return soap_id_enter(soap, id, p, t, n, 0, type, arrayType, soap_instantiate);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_byte(struct soap *soap, char *a)
{	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_byte
	*a = SOAP_DEFAULT_byte;
#else
	*a = (char)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_byte(struct soap *soap, const char *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_byte);
	if (soap_out_byte(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_byte(struct soap *soap, const char *tag, int id, const char *a, const char *type)
{
	return soap_outbyte(soap, tag, id, a, type, SOAP_TYPE_byte);
}

SOAP_FMAC3 char * SOAP_FMAC4 soap_get_byte(struct soap *soap, char *p, const char *tag, const char *type)
{
	if ((p = soap_in_byte(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 char * SOAP_FMAC4 soap_in_byte(struct soap *soap, const char *tag, char *a, const char *type)
{
	return soap_inbyte(soap, tag, a, type, SOAP_TYPE_byte);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_int(struct soap *soap, int *a)
{	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_int
	*a = SOAP_DEFAULT_int;
#else
	*a = (int)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_int(struct soap *soap, const int *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_int);
	if (soap_out_int(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_int(struct soap *soap, const char *tag, int id, const int *a, const char *type)
{
	return soap_outint(soap, tag, id, a, type, SOAP_TYPE_int);
}

SOAP_FMAC3 int * SOAP_FMAC4 soap_get_int(struct soap *soap, int *p, const char *tag, const char *type)
{
	if ((p = soap_in_int(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 int * SOAP_FMAC4 soap_in_int(struct soap *soap, const char *tag, int *a, const char *type)
{
	return soap_inint(soap, tag, a, type, SOAP_TYPE_int);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_double(struct soap *soap, double *a)
{	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_double
	*a = SOAP_DEFAULT_double;
#else
	*a = (double)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_double(struct soap *soap, const double *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_double);
	if (soap_out_double(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_double(struct soap *soap, const char *tag, int id, const double *a, const char *type)
{
	return soap_outdouble(soap, tag, id, a, type, SOAP_TYPE_double);
}

SOAP_FMAC3 double * SOAP_FMAC4 soap_get_double(struct soap *soap, double *p, const char *tag, const char *type)
{
	if ((p = soap_in_double(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 double * SOAP_FMAC4 soap_in_double(struct soap *soap, const char *tag, double *a, const char *type)
{
	return soap_indouble(soap, tag, a, type, SOAP_TYPE_double);
}

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Fault(struct soap *soap, const struct SOAP_ENV__Fault *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize__QName(soap, &a->faultcode);
	soap_serialize_string(soap, &a->faultstring);
	soap_serialize_string(soap, &a->faultactor);
	soap_serialize_PointerToSOAP_ENV__Detail(soap, &a->detail);
	soap_serialize_PointerToSOAP_ENV__Code(soap, &a->SOAP_ENV__Code);
	soap_serialize_PointerToSOAP_ENV__Reason(soap, &a->SOAP_ENV__Reason);
	soap_serialize_string(soap, &a->SOAP_ENV__Node);
	soap_serialize_string(soap, &a->SOAP_ENV__Role);
	soap_serialize_PointerToSOAP_ENV__Detail(soap, &a->SOAP_ENV__Detail);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Fault(struct soap *soap, struct SOAP_ENV__Fault *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default__QName(soap, &a->faultcode);
	soap_default_string(soap, &a->faultstring);
	soap_default_string(soap, &a->faultactor);
	a->detail = NULL;
	a->SOAP_ENV__Code = NULL;
	a->SOAP_ENV__Reason = NULL;
	soap_default_string(soap, &a->SOAP_ENV__Node);
	soap_default_string(soap, &a->SOAP_ENV__Role);
	a->SOAP_ENV__Detail = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Fault(struct soap *soap, const struct SOAP_ENV__Fault *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Fault);
	if (soap_out_SOAP_ENV__Fault(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Fault(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Fault *a, const char *type)
{
	const char *soap_tmp_faultcode = soap_QName2s(soap, a->faultcode);
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Fault), type);
	soap_out__QName(soap, "faultcode", -1, (char*const*)&soap_tmp_faultcode, "");
	soap_out_string(soap, "faultstring", -1, &a->faultstring, "");
	soap_out_string(soap, "faultactor", -1, &a->faultactor, "");
	soap_out_PointerToSOAP_ENV__Detail(soap, "detail", -1, &a->detail, "");
	soap_out_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Code", -1, &a->SOAP_ENV__Code, "");
	soap_out_PointerToSOAP_ENV__Reason(soap, "SOAP-ENV:Reason", -1, &a->SOAP_ENV__Reason, "");
	soap_out_string(soap, "SOAP-ENV:Node", -1, &a->SOAP_ENV__Node, "");
	soap_out_string(soap, "SOAP-ENV:Role", -1, &a->SOAP_ENV__Role, "");
	soap_out_PointerToSOAP_ENV__Detail(soap, "SOAP-ENV:Detail", -1, &a->SOAP_ENV__Detail, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct SOAP_ENV__Fault * SOAP_FMAC4 soap_get_SOAP_ENV__Fault(struct soap *soap, struct SOAP_ENV__Fault *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Fault(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct SOAP_ENV__Fault * SOAP_FMAC4 soap_in_SOAP_ENV__Fault(struct soap *soap, const char *tag, struct SOAP_ENV__Fault *a, const char *type)
{
	short soap_flag_faultcode = 1, soap_flag_faultstring = 1, soap_flag_faultactor = 1, soap_flag_detail = 1, soap_flag_SOAP_ENV__Code = 1, soap_flag_SOAP_ENV__Reason = 1, soap_flag_SOAP_ENV__Node = 1, soap_flag_SOAP_ENV__Role = 1, soap_flag_SOAP_ENV__Detail = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct SOAP_ENV__Fault *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Fault, sizeof(struct SOAP_ENV__Fault), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Fault(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_faultcode && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in__QName(soap, "faultcode", &a->faultcode, ""))
				{	soap_flag_faultcode--;
					continue;
				}
			if (soap_flag_faultstring && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "faultstring", &a->faultstring, "xsd:string"))
				{	soap_flag_faultstring--;
					continue;
				}
			if (soap_flag_faultactor && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "faultactor", &a->faultactor, "xsd:string"))
				{	soap_flag_faultactor--;
					continue;
				}
			if (soap_flag_detail && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Detail(soap, "detail", &a->detail, ""))
				{	soap_flag_detail--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Code && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Code", &a->SOAP_ENV__Code, ""))
				{	soap_flag_SOAP_ENV__Code--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Reason && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Reason(soap, "SOAP-ENV:Reason", &a->SOAP_ENV__Reason, ""))
				{	soap_flag_SOAP_ENV__Reason--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Node && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "SOAP-ENV:Node", &a->SOAP_ENV__Node, "xsd:string"))
				{	soap_flag_SOAP_ENV__Node--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Role && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "SOAP-ENV:Role", &a->SOAP_ENV__Role, "xsd:string"))
				{	soap_flag_SOAP_ENV__Role--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Detail && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Detail(soap, "SOAP-ENV:Detail", &a->SOAP_ENV__Detail, ""))
				{	soap_flag_SOAP_ENV__Detail--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Fault *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_SOAP_ENV__Fault, 0, sizeof(struct SOAP_ENV__Fault), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct SOAP_ENV__Fault * SOAP_FMAC6 soap_new_SOAP_ENV__Fault(struct soap *soap, int n)
{	return soap_instantiate_SOAP_ENV__Fault(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_SOAP_ENV__Fault(struct soap *soap, struct SOAP_ENV__Fault *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct SOAP_ENV__Fault * SOAP_FMAC4 soap_instantiate_SOAP_ENV__Fault(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Fault(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_SOAP_ENV__Fault, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct SOAP_ENV__Fault;
		if (size)
			*size = sizeof(struct SOAP_ENV__Fault);
	}
	else
	{	cp->ptr = (void*)new struct SOAP_ENV__Fault[n];
		if (size)
			*size = n * sizeof(struct SOAP_ENV__Fault);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct SOAP_ENV__Fault*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Fault(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Fault %p -> %p\n", q, p));
	*(struct SOAP_ENV__Fault*)p = *(struct SOAP_ENV__Fault*)q;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Reason(struct soap *soap, const struct SOAP_ENV__Reason *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->SOAP_ENV__Text);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->SOAP_ENV__Text);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Reason(struct soap *soap, const struct SOAP_ENV__Reason *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Reason);
	if (soap_out_SOAP_ENV__Reason(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Reason(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Reason *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Reason), type);
	soap_out_string(soap, "SOAP-ENV:Text", -1, &a->SOAP_ENV__Text, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct SOAP_ENV__Reason * SOAP_FMAC4 soap_get_SOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Reason(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct SOAP_ENV__Reason * SOAP_FMAC4 soap_in_SOAP_ENV__Reason(struct soap *soap, const char *tag, struct SOAP_ENV__Reason *a, const char *type)
{
	short soap_flag_SOAP_ENV__Text = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct SOAP_ENV__Reason *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Reason, sizeof(struct SOAP_ENV__Reason), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Reason(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SOAP_ENV__Text && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "SOAP-ENV:Text", &a->SOAP_ENV__Text, "xsd:string"))
				{	soap_flag_SOAP_ENV__Text--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Reason *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_SOAP_ENV__Reason, 0, sizeof(struct SOAP_ENV__Reason), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct SOAP_ENV__Reason * SOAP_FMAC6 soap_new_SOAP_ENV__Reason(struct soap *soap, int n)
{	return soap_instantiate_SOAP_ENV__Reason(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_SOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct SOAP_ENV__Reason * SOAP_FMAC4 soap_instantiate_SOAP_ENV__Reason(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Reason(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_SOAP_ENV__Reason, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct SOAP_ENV__Reason;
		if (size)
			*size = sizeof(struct SOAP_ENV__Reason);
	}
	else
	{	cp->ptr = (void*)new struct SOAP_ENV__Reason[n];
		if (size)
			*size = n * sizeof(struct SOAP_ENV__Reason);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct SOAP_ENV__Reason*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Reason(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Reason %p -> %p\n", q, p));
	*(struct SOAP_ENV__Reason*)p = *(struct SOAP_ENV__Reason*)q;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Detail(struct soap *soap, const struct SOAP_ENV__Detail *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_markelement(soap, a->fault, a->__type);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__type = 0;
	a->fault = NULL;
	a->__any = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Detail(struct soap *soap, const struct SOAP_ENV__Detail *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Detail);
	if (soap_out_SOAP_ENV__Detail(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Detail(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Detail *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Detail), type);
	soap_putelement(soap, a->fault, "fault", -1, a->__type);
	soap_outliteral(soap, "-any", &a->__any);
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct SOAP_ENV__Detail * SOAP_FMAC4 soap_get_SOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Detail(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct SOAP_ENV__Detail * SOAP_FMAC4 soap_in_SOAP_ENV__Detail(struct soap *soap, const char *tag, struct SOAP_ENV__Detail *a, const char *type)
{
	short soap_flag_fault = 1, soap_flag___any = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct SOAP_ENV__Detail *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Detail, sizeof(struct SOAP_ENV__Detail), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Detail(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_fault && soap->error == SOAP_TAG_MISMATCH)
				if ((a->fault = soap_getelement(soap, &a->__type)))
				{	soap_flag_fault = 0;
					continue;
				}
			if (soap_flag___any && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-any", &a->__any))
				{	soap_flag___any--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Detail *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_SOAP_ENV__Detail, 0, sizeof(struct SOAP_ENV__Detail), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct SOAP_ENV__Detail * SOAP_FMAC6 soap_new_SOAP_ENV__Detail(struct soap *soap, int n)
{	return soap_instantiate_SOAP_ENV__Detail(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_SOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct SOAP_ENV__Detail * SOAP_FMAC4 soap_instantiate_SOAP_ENV__Detail(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Detail(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_SOAP_ENV__Detail, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct SOAP_ENV__Detail;
		if (size)
			*size = sizeof(struct SOAP_ENV__Detail);
	}
	else
	{	cp->ptr = (void*)new struct SOAP_ENV__Detail[n];
		if (size)
			*size = n * sizeof(struct SOAP_ENV__Detail);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct SOAP_ENV__Detail*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Detail(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Detail %p -> %p\n", q, p));
	*(struct SOAP_ENV__Detail*)p = *(struct SOAP_ENV__Detail*)q;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Code(struct soap *soap, const struct SOAP_ENV__Code *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize__QName(soap, &a->SOAP_ENV__Value);
	soap_serialize_PointerToSOAP_ENV__Code(soap, &a->SOAP_ENV__Subcode);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default__QName(soap, &a->SOAP_ENV__Value);
	a->SOAP_ENV__Subcode = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Code(struct soap *soap, const struct SOAP_ENV__Code *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Code);
	if (soap_out_SOAP_ENV__Code(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Code(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Code *a, const char *type)
{
	const char *soap_tmp_SOAP_ENV__Value = soap_QName2s(soap, a->SOAP_ENV__Value);
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Code), type);
	soap_out__QName(soap, "SOAP-ENV:Value", -1, (char*const*)&soap_tmp_SOAP_ENV__Value, "");
	soap_out_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Subcode", -1, &a->SOAP_ENV__Subcode, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct SOAP_ENV__Code * SOAP_FMAC4 soap_get_SOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Code(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct SOAP_ENV__Code * SOAP_FMAC4 soap_in_SOAP_ENV__Code(struct soap *soap, const char *tag, struct SOAP_ENV__Code *a, const char *type)
{
	short soap_flag_SOAP_ENV__Value = 1, soap_flag_SOAP_ENV__Subcode = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct SOAP_ENV__Code *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Code, sizeof(struct SOAP_ENV__Code), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Code(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SOAP_ENV__Value && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in__QName(soap, "SOAP-ENV:Value", &a->SOAP_ENV__Value, ""))
				{	soap_flag_SOAP_ENV__Value--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Subcode && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Subcode", &a->SOAP_ENV__Subcode, ""))
				{	soap_flag_SOAP_ENV__Subcode--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Code *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_SOAP_ENV__Code, 0, sizeof(struct SOAP_ENV__Code), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct SOAP_ENV__Code * SOAP_FMAC6 soap_new_SOAP_ENV__Code(struct soap *soap, int n)
{	return soap_instantiate_SOAP_ENV__Code(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_SOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct SOAP_ENV__Code * SOAP_FMAC4 soap_instantiate_SOAP_ENV__Code(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Code(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_SOAP_ENV__Code, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct SOAP_ENV__Code;
		if (size)
			*size = sizeof(struct SOAP_ENV__Code);
	}
	else
	{	cp->ptr = (void*)new struct SOAP_ENV__Code[n];
		if (size)
			*size = n * sizeof(struct SOAP_ENV__Code);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct SOAP_ENV__Code*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Code(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Code %p -> %p\n", q, p));
	*(struct SOAP_ENV__Code*)p = *(struct SOAP_ENV__Code*)q;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Header(struct soap *soap, const struct SOAP_ENV__Header *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	/* transient dummy skipped */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Header(struct soap *soap, struct SOAP_ENV__Header *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	/* transient dummy skipped */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Header(struct soap *soap, const struct SOAP_ENV__Header *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Header);
	if (soap_out_SOAP_ENV__Header(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Header(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Header *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Header), type);
	/* transient dummy skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct SOAP_ENV__Header * SOAP_FMAC4 soap_get_SOAP_ENV__Header(struct soap *soap, struct SOAP_ENV__Header *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Header(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct SOAP_ENV__Header * SOAP_FMAC4 soap_in_SOAP_ENV__Header(struct soap *soap, const char *tag, struct SOAP_ENV__Header *a, const char *type)
{;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct SOAP_ENV__Header *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Header, sizeof(struct SOAP_ENV__Header), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Header(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
		/* transient dummy skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Header *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_SOAP_ENV__Header, 0, sizeof(struct SOAP_ENV__Header), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct SOAP_ENV__Header * SOAP_FMAC6 soap_new_SOAP_ENV__Header(struct soap *soap, int n)
{	return soap_instantiate_SOAP_ENV__Header(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_SOAP_ENV__Header(struct soap *soap, struct SOAP_ENV__Header *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct SOAP_ENV__Header * SOAP_FMAC4 soap_instantiate_SOAP_ENV__Header(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Header(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_SOAP_ENV__Header, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct SOAP_ENV__Header;
		if (size)
			*size = sizeof(struct SOAP_ENV__Header);
	}
	else
	{	cp->ptr = (void*)new struct SOAP_ENV__Header[n];
		if (size)
			*size = n * sizeof(struct SOAP_ENV__Header);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct SOAP_ENV__Header*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Header(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Header %p -> %p\n", q, p));
	*(struct SOAP_ENV__Header*)p = *(struct SOAP_ENV__Header*)q;
}

#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__setgroupbarrier(struct soap *soap, const struct ns__setgroupbarrier *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->id, SOAP_TYPE_int);
	soap_embedded(soap, &a->state, SOAP_TYPE_int);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__setgroupbarrier(struct soap *soap, struct ns__setgroupbarrier *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->id);
	soap_default_int(soap, &a->state);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__setgroupbarrier(struct soap *soap, const struct ns__setgroupbarrier *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns__setgroupbarrier);
	if (soap_out_ns__setgroupbarrier(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__setgroupbarrier(struct soap *soap, const char *tag, int id, const struct ns__setgroupbarrier *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__setgroupbarrier), type);
	soap_out_int(soap, "id", -1, &a->id, "");
	soap_out_int(soap, "state", -1, &a->state, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct ns__setgroupbarrier * SOAP_FMAC4 soap_get_ns__setgroupbarrier(struct soap *soap, struct ns__setgroupbarrier *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__setgroupbarrier(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct ns__setgroupbarrier * SOAP_FMAC4 soap_in_ns__setgroupbarrier(struct soap *soap, const char *tag, struct ns__setgroupbarrier *a, const char *type)
{
	short soap_flag_id = 1, soap_flag_state = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct ns__setgroupbarrier *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__setgroupbarrier, sizeof(struct ns__setgroupbarrier), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns__setgroupbarrier(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_id && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "id", &a->id, "xsd:int"))
				{	soap_flag_id--;
					continue;
				}
			if (soap_flag_state && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "state", &a->state, "xsd:int"))
				{	soap_flag_state--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_id > 0 || soap_flag_state > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns__setgroupbarrier *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_ns__setgroupbarrier, 0, sizeof(struct ns__setgroupbarrier), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns__setgroupbarrier * SOAP_FMAC6 soap_new_ns__setgroupbarrier(struct soap *soap, int n)
{	return soap_instantiate_ns__setgroupbarrier(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns__setgroupbarrier(struct soap *soap, struct ns__setgroupbarrier *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns__setgroupbarrier * SOAP_FMAC4 soap_instantiate_ns__setgroupbarrier(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__setgroupbarrier(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns__setgroupbarrier, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns__setgroupbarrier;
		if (size)
			*size = sizeof(struct ns__setgroupbarrier);
	}
	else
	{	cp->ptr = (void*)new struct ns__setgroupbarrier[n];
		if (size)
			*size = n * sizeof(struct ns__setgroupbarrier);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns__setgroupbarrier*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns__setgroupbarrier(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns__setgroupbarrier %p -> %p\n", q, p));
	*(struct ns__setgroupbarrier*)p = *(struct ns__setgroupbarrier*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__setgroupbarrierResponse(struct soap *soap, const struct ns__setgroupbarrierResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToint(soap, &a->newstate);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__setgroupbarrierResponse(struct soap *soap, struct ns__setgroupbarrierResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->newstate = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__setgroupbarrierResponse(struct soap *soap, const struct ns__setgroupbarrierResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns__setgroupbarrierResponse);
	if (soap_out_ns__setgroupbarrierResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__setgroupbarrierResponse(struct soap *soap, const char *tag, int id, const struct ns__setgroupbarrierResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__setgroupbarrierResponse), type);
	if (a->newstate)
		soap_element_result(soap, "newstate");
	soap_out_PointerToint(soap, "newstate", -1, &a->newstate, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct ns__setgroupbarrierResponse * SOAP_FMAC4 soap_get_ns__setgroupbarrierResponse(struct soap *soap, struct ns__setgroupbarrierResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__setgroupbarrierResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct ns__setgroupbarrierResponse * SOAP_FMAC4 soap_in_ns__setgroupbarrierResponse(struct soap *soap, const char *tag, struct ns__setgroupbarrierResponse *a, const char *type)
{
	short soap_flag_newstate = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct ns__setgroupbarrierResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__setgroupbarrierResponse, sizeof(struct ns__setgroupbarrierResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns__setgroupbarrierResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_newstate && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "newstate", &a->newstate, "xsd:int"))
				{	soap_flag_newstate--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns__setgroupbarrierResponse *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_ns__setgroupbarrierResponse, 0, sizeof(struct ns__setgroupbarrierResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns__setgroupbarrierResponse * SOAP_FMAC6 soap_new_ns__setgroupbarrierResponse(struct soap *soap, int n)
{	return soap_instantiate_ns__setgroupbarrierResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns__setgroupbarrierResponse(struct soap *soap, struct ns__setgroupbarrierResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns__setgroupbarrierResponse * SOAP_FMAC4 soap_instantiate_ns__setgroupbarrierResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__setgroupbarrierResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns__setgroupbarrierResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns__setgroupbarrierResponse;
		if (size)
			*size = sizeof(struct ns__setgroupbarrierResponse);
	}
	else
	{	cp->ptr = (void*)new struct ns__setgroupbarrierResponse[n];
		if (size)
			*size = n * sizeof(struct ns__setgroupbarrierResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns__setgroupbarrierResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns__setgroupbarrierResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns__setgroupbarrierResponse %p -> %p\n", q, p));
	*(struct ns__setgroupbarrierResponse*)p = *(struct ns__setgroupbarrierResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__testgroupbarrier(struct soap *soap, const struct ns__testgroupbarrier *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->id, SOAP_TYPE_int);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__testgroupbarrier(struct soap *soap, struct ns__testgroupbarrier *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->id);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__testgroupbarrier(struct soap *soap, const struct ns__testgroupbarrier *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns__testgroupbarrier);
	if (soap_out_ns__testgroupbarrier(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__testgroupbarrier(struct soap *soap, const char *tag, int id, const struct ns__testgroupbarrier *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__testgroupbarrier), type);
	soap_out_int(soap, "id", -1, &a->id, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct ns__testgroupbarrier * SOAP_FMAC4 soap_get_ns__testgroupbarrier(struct soap *soap, struct ns__testgroupbarrier *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__testgroupbarrier(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct ns__testgroupbarrier * SOAP_FMAC4 soap_in_ns__testgroupbarrier(struct soap *soap, const char *tag, struct ns__testgroupbarrier *a, const char *type)
{
	short soap_flag_id = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct ns__testgroupbarrier *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__testgroupbarrier, sizeof(struct ns__testgroupbarrier), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns__testgroupbarrier(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_id && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "id", &a->id, "xsd:int"))
				{	soap_flag_id--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_id > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns__testgroupbarrier *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_ns__testgroupbarrier, 0, sizeof(struct ns__testgroupbarrier), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns__testgroupbarrier * SOAP_FMAC6 soap_new_ns__testgroupbarrier(struct soap *soap, int n)
{	return soap_instantiate_ns__testgroupbarrier(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns__testgroupbarrier(struct soap *soap, struct ns__testgroupbarrier *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns__testgroupbarrier * SOAP_FMAC4 soap_instantiate_ns__testgroupbarrier(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__testgroupbarrier(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns__testgroupbarrier, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns__testgroupbarrier;
		if (size)
			*size = sizeof(struct ns__testgroupbarrier);
	}
	else
	{	cp->ptr = (void*)new struct ns__testgroupbarrier[n];
		if (size)
			*size = n * sizeof(struct ns__testgroupbarrier);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns__testgroupbarrier*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns__testgroupbarrier(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns__testgroupbarrier %p -> %p\n", q, p));
	*(struct ns__testgroupbarrier*)p = *(struct ns__testgroupbarrier*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__testgroupbarrierResponse(struct soap *soap, const struct ns__testgroupbarrierResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToint(soap, &a->state);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__testgroupbarrierResponse(struct soap *soap, struct ns__testgroupbarrierResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->state = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__testgroupbarrierResponse(struct soap *soap, const struct ns__testgroupbarrierResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns__testgroupbarrierResponse);
	if (soap_out_ns__testgroupbarrierResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__testgroupbarrierResponse(struct soap *soap, const char *tag, int id, const struct ns__testgroupbarrierResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__testgroupbarrierResponse), type);
	if (a->state)
		soap_element_result(soap, "state");
	soap_out_PointerToint(soap, "state", -1, &a->state, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct ns__testgroupbarrierResponse * SOAP_FMAC4 soap_get_ns__testgroupbarrierResponse(struct soap *soap, struct ns__testgroupbarrierResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__testgroupbarrierResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct ns__testgroupbarrierResponse * SOAP_FMAC4 soap_in_ns__testgroupbarrierResponse(struct soap *soap, const char *tag, struct ns__testgroupbarrierResponse *a, const char *type)
{
	short soap_flag_state = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct ns__testgroupbarrierResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__testgroupbarrierResponse, sizeof(struct ns__testgroupbarrierResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns__testgroupbarrierResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_state && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "state", &a->state, "xsd:int"))
				{	soap_flag_state--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns__testgroupbarrierResponse *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_ns__testgroupbarrierResponse, 0, sizeof(struct ns__testgroupbarrierResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns__testgroupbarrierResponse * SOAP_FMAC6 soap_new_ns__testgroupbarrierResponse(struct soap *soap, int n)
{	return soap_instantiate_ns__testgroupbarrierResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns__testgroupbarrierResponse(struct soap *soap, struct ns__testgroupbarrierResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns__testgroupbarrierResponse * SOAP_FMAC4 soap_instantiate_ns__testgroupbarrierResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__testgroupbarrierResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns__testgroupbarrierResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns__testgroupbarrierResponse;
		if (size)
			*size = sizeof(struct ns__testgroupbarrierResponse);
	}
	else
	{	cp->ptr = (void*)new struct ns__testgroupbarrierResponse[n];
		if (size)
			*size = n * sizeof(struct ns__testgroupbarrierResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns__testgroupbarrierResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns__testgroupbarrierResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns__testgroupbarrierResponse %p -> %p\n", q, p));
	*(struct ns__testgroupbarrierResponse*)p = *(struct ns__testgroupbarrierResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__getobjnum(struct soap *soap, const struct ns__getobjnum *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->id, SOAP_TYPE_int);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__getobjnum(struct soap *soap, struct ns__getobjnum *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->id);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__getobjnum(struct soap *soap, const struct ns__getobjnum *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns__getobjnum);
	if (soap_out_ns__getobjnum(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__getobjnum(struct soap *soap, const char *tag, int id, const struct ns__getobjnum *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__getobjnum), type);
	soap_out_int(soap, "id", -1, &a->id, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct ns__getobjnum * SOAP_FMAC4 soap_get_ns__getobjnum(struct soap *soap, struct ns__getobjnum *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__getobjnum(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct ns__getobjnum * SOAP_FMAC4 soap_in_ns__getobjnum(struct soap *soap, const char *tag, struct ns__getobjnum *a, const char *type)
{
	short soap_flag_id = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct ns__getobjnum *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__getobjnum, sizeof(struct ns__getobjnum), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns__getobjnum(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_id && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "id", &a->id, "xsd:int"))
				{	soap_flag_id--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_id > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns__getobjnum *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_ns__getobjnum, 0, sizeof(struct ns__getobjnum), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns__getobjnum * SOAP_FMAC6 soap_new_ns__getobjnum(struct soap *soap, int n)
{	return soap_instantiate_ns__getobjnum(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns__getobjnum(struct soap *soap, struct ns__getobjnum *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns__getobjnum * SOAP_FMAC4 soap_instantiate_ns__getobjnum(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__getobjnum(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns__getobjnum, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns__getobjnum;
		if (size)
			*size = sizeof(struct ns__getobjnum);
	}
	else
	{	cp->ptr = (void*)new struct ns__getobjnum[n];
		if (size)
			*size = n * sizeof(struct ns__getobjnum);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns__getobjnum*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns__getobjnum(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns__getobjnum %p -> %p\n", q, p));
	*(struct ns__getobjnum*)p = *(struct ns__getobjnum*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__getobjnumResponse(struct soap *soap, const struct ns__getobjnumResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToint(soap, &a->objnum);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__getobjnumResponse(struct soap *soap, struct ns__getobjnumResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->objnum = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__getobjnumResponse(struct soap *soap, const struct ns__getobjnumResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns__getobjnumResponse);
	if (soap_out_ns__getobjnumResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__getobjnumResponse(struct soap *soap, const char *tag, int id, const struct ns__getobjnumResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__getobjnumResponse), type);
	if (a->objnum)
		soap_element_result(soap, "objnum");
	soap_out_PointerToint(soap, "objnum", -1, &a->objnum, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct ns__getobjnumResponse * SOAP_FMAC4 soap_get_ns__getobjnumResponse(struct soap *soap, struct ns__getobjnumResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__getobjnumResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct ns__getobjnumResponse * SOAP_FMAC4 soap_in_ns__getobjnumResponse(struct soap *soap, const char *tag, struct ns__getobjnumResponse *a, const char *type)
{
	short soap_flag_objnum = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct ns__getobjnumResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__getobjnumResponse, sizeof(struct ns__getobjnumResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns__getobjnumResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_objnum && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "objnum", &a->objnum, "xsd:int"))
				{	soap_flag_objnum--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns__getobjnumResponse *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_ns__getobjnumResponse, 0, sizeof(struct ns__getobjnumResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns__getobjnumResponse * SOAP_FMAC6 soap_new_ns__getobjnumResponse(struct soap *soap, int n)
{	return soap_instantiate_ns__getobjnumResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns__getobjnumResponse(struct soap *soap, struct ns__getobjnumResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns__getobjnumResponse * SOAP_FMAC4 soap_instantiate_ns__getobjnumResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__getobjnumResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns__getobjnumResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns__getobjnumResponse;
		if (size)
			*size = sizeof(struct ns__getobjnumResponse);
	}
	else
	{	cp->ptr = (void*)new struct ns__getobjnumResponse[n];
		if (size)
			*size = n * sizeof(struct ns__getobjnumResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns__getobjnumResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns__getobjnumResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns__getobjnumResponse %p -> %p\n", q, p));
	*(struct ns__getobjnumResponse*)p = *(struct ns__getobjnumResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__getnumobj(struct soap *soap, const struct ns__getnumobj *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->id, SOAP_TYPE_int);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__getnumobj(struct soap *soap, struct ns__getnumobj *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->id);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__getnumobj(struct soap *soap, const struct ns__getnumobj *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns__getnumobj);
	if (soap_out_ns__getnumobj(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__getnumobj(struct soap *soap, const char *tag, int id, const struct ns__getnumobj *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__getnumobj), type);
	soap_out_int(soap, "id", -1, &a->id, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct ns__getnumobj * SOAP_FMAC4 soap_get_ns__getnumobj(struct soap *soap, struct ns__getnumobj *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__getnumobj(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct ns__getnumobj * SOAP_FMAC4 soap_in_ns__getnumobj(struct soap *soap, const char *tag, struct ns__getnumobj *a, const char *type)
{
	short soap_flag_id = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct ns__getnumobj *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__getnumobj, sizeof(struct ns__getnumobj), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns__getnumobj(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_id && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "id", &a->id, "xsd:int"))
				{	soap_flag_id--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_id > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns__getnumobj *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_ns__getnumobj, 0, sizeof(struct ns__getnumobj), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns__getnumobj * SOAP_FMAC6 soap_new_ns__getnumobj(struct soap *soap, int n)
{	return soap_instantiate_ns__getnumobj(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns__getnumobj(struct soap *soap, struct ns__getnumobj *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns__getnumobj * SOAP_FMAC4 soap_instantiate_ns__getnumobj(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__getnumobj(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns__getnumobj, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns__getnumobj;
		if (size)
			*size = sizeof(struct ns__getnumobj);
	}
	else
	{	cp->ptr = (void*)new struct ns__getnumobj[n];
		if (size)
			*size = n * sizeof(struct ns__getnumobj);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns__getnumobj*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns__getnumobj(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns__getnumobj %p -> %p\n", q, p));
	*(struct ns__getnumobj*)p = *(struct ns__getnumobj*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__getnumobjResponse(struct soap *soap, const struct ns__getnumobjResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToint(soap, &a->numobj);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__getnumobjResponse(struct soap *soap, struct ns__getnumobjResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->numobj = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__getnumobjResponse(struct soap *soap, const struct ns__getnumobjResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns__getnumobjResponse);
	if (soap_out_ns__getnumobjResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__getnumobjResponse(struct soap *soap, const char *tag, int id, const struct ns__getnumobjResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__getnumobjResponse), type);
	if (a->numobj)
		soap_element_result(soap, "numobj");
	soap_out_PointerToint(soap, "numobj", -1, &a->numobj, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct ns__getnumobjResponse * SOAP_FMAC4 soap_get_ns__getnumobjResponse(struct soap *soap, struct ns__getnumobjResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__getnumobjResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct ns__getnumobjResponse * SOAP_FMAC4 soap_in_ns__getnumobjResponse(struct soap *soap, const char *tag, struct ns__getnumobjResponse *a, const char *type)
{
	short soap_flag_numobj = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct ns__getnumobjResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__getnumobjResponse, sizeof(struct ns__getnumobjResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns__getnumobjResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_numobj && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "numobj", &a->numobj, "xsd:int"))
				{	soap_flag_numobj--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns__getnumobjResponse *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_ns__getnumobjResponse, 0, sizeof(struct ns__getnumobjResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns__getnumobjResponse * SOAP_FMAC6 soap_new_ns__getnumobjResponse(struct soap *soap, int n)
{	return soap_instantiate_ns__getnumobjResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns__getnumobjResponse(struct soap *soap, struct ns__getnumobjResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns__getnumobjResponse * SOAP_FMAC4 soap_instantiate_ns__getnumobjResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__getnumobjResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns__getnumobjResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns__getnumobjResponse;
		if (size)
			*size = sizeof(struct ns__getnumobjResponse);
	}
	else
	{	cp->ptr = (void*)new struct ns__getnumobjResponse[n];
		if (size)
			*size = n * sizeof(struct ns__getnumobjResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns__getnumobjResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns__getnumobjResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns__getnumobjResponse %p -> %p\n", q, p));
	*(struct ns__getnumobjResponse*)p = *(struct ns__getnumobjResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__listparam(struct soap *soap, const struct ns__listparam *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->type);
	soap_embedded(soap, &a->id, SOAP_TYPE_int);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__listparam(struct soap *soap, struct ns__listparam *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->type);
	soap_default_int(soap, &a->id);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__listparam(struct soap *soap, const struct ns__listparam *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns__listparam);
	if (soap_out_ns__listparam(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__listparam(struct soap *soap, const char *tag, int id, const struct ns__listparam *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__listparam), type);
	soap_out_string(soap, "type", -1, &a->type, "");
	soap_out_int(soap, "id", -1, &a->id, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct ns__listparam * SOAP_FMAC4 soap_get_ns__listparam(struct soap *soap, struct ns__listparam *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__listparam(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct ns__listparam * SOAP_FMAC4 soap_in_ns__listparam(struct soap *soap, const char *tag, struct ns__listparam *a, const char *type)
{
	short soap_flag_type = 1, soap_flag_id = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct ns__listparam *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__listparam, sizeof(struct ns__listparam), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns__listparam(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_type && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "type", &a->type, "xsd:string"))
				{	soap_flag_type--;
					continue;
				}
			if (soap_flag_id && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "id", &a->id, "xsd:int"))
				{	soap_flag_id--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_id > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns__listparam *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_ns__listparam, 0, sizeof(struct ns__listparam), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns__listparam * SOAP_FMAC6 soap_new_ns__listparam(struct soap *soap, int n)
{	return soap_instantiate_ns__listparam(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns__listparam(struct soap *soap, struct ns__listparam *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns__listparam * SOAP_FMAC4 soap_instantiate_ns__listparam(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__listparam(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns__listparam, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns__listparam;
		if (size)
			*size = sizeof(struct ns__listparam);
	}
	else
	{	cp->ptr = (void*)new struct ns__listparam[n];
		if (size)
			*size = n * sizeof(struct ns__listparam);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns__listparam*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns__listparam(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns__listparam %p -> %p\n", q, p));
	*(struct ns__listparam*)p = *(struct ns__listparam*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__listparamResponse(struct soap *soap, const struct ns__listparamResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTostring(soap, &a->list);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__listparamResponse(struct soap *soap, struct ns__listparamResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->list = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__listparamResponse(struct soap *soap, const struct ns__listparamResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns__listparamResponse);
	if (soap_out_ns__listparamResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__listparamResponse(struct soap *soap, const char *tag, int id, const struct ns__listparamResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__listparamResponse), type);
	if (a->list)
		soap_element_result(soap, "list");
	soap_out_PointerTostring(soap, "list", -1, &a->list, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct ns__listparamResponse * SOAP_FMAC4 soap_get_ns__listparamResponse(struct soap *soap, struct ns__listparamResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__listparamResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct ns__listparamResponse * SOAP_FMAC4 soap_in_ns__listparamResponse(struct soap *soap, const char *tag, struct ns__listparamResponse *a, const char *type)
{
	short soap_flag_list = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct ns__listparamResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__listparamResponse, sizeof(struct ns__listparamResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns__listparamResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_list && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTostring(soap, "list", &a->list, "xsd:string"))
				{	soap_flag_list--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns__listparamResponse *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_ns__listparamResponse, 0, sizeof(struct ns__listparamResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns__listparamResponse * SOAP_FMAC6 soap_new_ns__listparamResponse(struct soap *soap, int n)
{	return soap_instantiate_ns__listparamResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns__listparamResponse(struct soap *soap, struct ns__listparamResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns__listparamResponse * SOAP_FMAC4 soap_instantiate_ns__listparamResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__listparamResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns__listparamResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns__listparamResponse;
		if (size)
			*size = sizeof(struct ns__listparamResponse);
	}
	else
	{	cp->ptr = (void*)new struct ns__listparamResponse[n];
		if (size)
			*size = n * sizeof(struct ns__listparamResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns__listparamResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns__listparamResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns__listparamResponse %p -> %p\n", q, p));
	*(struct ns__listparamResponse*)p = *(struct ns__listparamResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__deleteparam(struct soap *soap, const struct ns__deleteparam *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->name);
	soap_embedded(soap, &a->id, SOAP_TYPE_int);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__deleteparam(struct soap *soap, struct ns__deleteparam *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->name);
	soap_default_int(soap, &a->id);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__deleteparam(struct soap *soap, const struct ns__deleteparam *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns__deleteparam);
	if (soap_out_ns__deleteparam(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__deleteparam(struct soap *soap, const char *tag, int id, const struct ns__deleteparam *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__deleteparam), type);
	soap_out_string(soap, "name", -1, &a->name, "");
	soap_out_int(soap, "id", -1, &a->id, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct ns__deleteparam * SOAP_FMAC4 soap_get_ns__deleteparam(struct soap *soap, struct ns__deleteparam *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__deleteparam(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct ns__deleteparam * SOAP_FMAC4 soap_in_ns__deleteparam(struct soap *soap, const char *tag, struct ns__deleteparam *a, const char *type)
{
	short soap_flag_name = 1, soap_flag_id = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct ns__deleteparam *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__deleteparam, sizeof(struct ns__deleteparam), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns__deleteparam(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_name && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "name", &a->name, "xsd:string"))
				{	soap_flag_name--;
					continue;
				}
			if (soap_flag_id && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "id", &a->id, "xsd:int"))
				{	soap_flag_id--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_id > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns__deleteparam *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_ns__deleteparam, 0, sizeof(struct ns__deleteparam), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns__deleteparam * SOAP_FMAC6 soap_new_ns__deleteparam(struct soap *soap, int n)
{	return soap_instantiate_ns__deleteparam(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns__deleteparam(struct soap *soap, struct ns__deleteparam *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns__deleteparam * SOAP_FMAC4 soap_instantiate_ns__deleteparam(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__deleteparam(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns__deleteparam, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns__deleteparam;
		if (size)
			*size = sizeof(struct ns__deleteparam);
	}
	else
	{	cp->ptr = (void*)new struct ns__deleteparam[n];
		if (size)
			*size = n * sizeof(struct ns__deleteparam);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns__deleteparam*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns__deleteparam(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns__deleteparam %p -> %p\n", q, p));
	*(struct ns__deleteparam*)p = *(struct ns__deleteparam*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__deleteparamResponse(struct soap *soap, const struct ns__deleteparamResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToint(soap, &a->status);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__deleteparamResponse(struct soap *soap, struct ns__deleteparamResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->status = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__deleteparamResponse(struct soap *soap, const struct ns__deleteparamResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns__deleteparamResponse);
	if (soap_out_ns__deleteparamResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__deleteparamResponse(struct soap *soap, const char *tag, int id, const struct ns__deleteparamResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__deleteparamResponse), type);
	if (a->status)
		soap_element_result(soap, "status");
	soap_out_PointerToint(soap, "status", -1, &a->status, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct ns__deleteparamResponse * SOAP_FMAC4 soap_get_ns__deleteparamResponse(struct soap *soap, struct ns__deleteparamResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__deleteparamResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct ns__deleteparamResponse * SOAP_FMAC4 soap_in_ns__deleteparamResponse(struct soap *soap, const char *tag, struct ns__deleteparamResponse *a, const char *type)
{
	short soap_flag_status = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct ns__deleteparamResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__deleteparamResponse, sizeof(struct ns__deleteparamResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns__deleteparamResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_status && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "status", &a->status, "xsd:int"))
				{	soap_flag_status--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns__deleteparamResponse *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_ns__deleteparamResponse, 0, sizeof(struct ns__deleteparamResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns__deleteparamResponse * SOAP_FMAC6 soap_new_ns__deleteparamResponse(struct soap *soap, int n)
{	return soap_instantiate_ns__deleteparamResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns__deleteparamResponse(struct soap *soap, struct ns__deleteparamResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns__deleteparamResponse * SOAP_FMAC4 soap_instantiate_ns__deleteparamResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__deleteparamResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns__deleteparamResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns__deleteparamResponse;
		if (size)
			*size = sizeof(struct ns__deleteparamResponse);
	}
	else
	{	cp->ptr = (void*)new struct ns__deleteparamResponse[n];
		if (size)
			*size = n * sizeof(struct ns__deleteparamResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns__deleteparamResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns__deleteparamResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns__deleteparamResponse %p -> %p\n", q, p));
	*(struct ns__deleteparamResponse*)p = *(struct ns__deleteparamResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__deletemetadata(struct soap *soap, const struct ns__deletemetadata *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->id, SOAP_TYPE_int);
	soap_serialize_string(soap, &a->name);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__deletemetadata(struct soap *soap, struct ns__deletemetadata *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->id);
	soap_default_string(soap, &a->name);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__deletemetadata(struct soap *soap, const struct ns__deletemetadata *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns__deletemetadata);
	if (soap_out_ns__deletemetadata(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__deletemetadata(struct soap *soap, const char *tag, int id, const struct ns__deletemetadata *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__deletemetadata), type);
	soap_out_int(soap, "id", -1, &a->id, "");
	soap_out_string(soap, "name", -1, &a->name, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct ns__deletemetadata * SOAP_FMAC4 soap_get_ns__deletemetadata(struct soap *soap, struct ns__deletemetadata *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__deletemetadata(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct ns__deletemetadata * SOAP_FMAC4 soap_in_ns__deletemetadata(struct soap *soap, const char *tag, struct ns__deletemetadata *a, const char *type)
{
	short soap_flag_id = 1, soap_flag_name = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct ns__deletemetadata *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__deletemetadata, sizeof(struct ns__deletemetadata), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns__deletemetadata(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_id && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "id", &a->id, "xsd:int"))
				{	soap_flag_id--;
					continue;
				}
			if (soap_flag_name && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "name", &a->name, "xsd:string"))
				{	soap_flag_name--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_id > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns__deletemetadata *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_ns__deletemetadata, 0, sizeof(struct ns__deletemetadata), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns__deletemetadata * SOAP_FMAC6 soap_new_ns__deletemetadata(struct soap *soap, int n)
{	return soap_instantiate_ns__deletemetadata(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns__deletemetadata(struct soap *soap, struct ns__deletemetadata *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns__deletemetadata * SOAP_FMAC4 soap_instantiate_ns__deletemetadata(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__deletemetadata(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns__deletemetadata, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns__deletemetadata;
		if (size)
			*size = sizeof(struct ns__deletemetadata);
	}
	else
	{	cp->ptr = (void*)new struct ns__deletemetadata[n];
		if (size)
			*size = n * sizeof(struct ns__deletemetadata);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns__deletemetadata*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns__deletemetadata(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns__deletemetadata %p -> %p\n", q, p));
	*(struct ns__deletemetadata*)p = *(struct ns__deletemetadata*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__deletemetadataResponse(struct soap *soap, const struct ns__deletemetadataResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToint(soap, &a->status);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__deletemetadataResponse(struct soap *soap, struct ns__deletemetadataResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->status = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__deletemetadataResponse(struct soap *soap, const struct ns__deletemetadataResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns__deletemetadataResponse);
	if (soap_out_ns__deletemetadataResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__deletemetadataResponse(struct soap *soap, const char *tag, int id, const struct ns__deletemetadataResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__deletemetadataResponse), type);
	if (a->status)
		soap_element_result(soap, "status");
	soap_out_PointerToint(soap, "status", -1, &a->status, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct ns__deletemetadataResponse * SOAP_FMAC4 soap_get_ns__deletemetadataResponse(struct soap *soap, struct ns__deletemetadataResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__deletemetadataResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct ns__deletemetadataResponse * SOAP_FMAC4 soap_in_ns__deletemetadataResponse(struct soap *soap, const char *tag, struct ns__deletemetadataResponse *a, const char *type)
{
	short soap_flag_status = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct ns__deletemetadataResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__deletemetadataResponse, sizeof(struct ns__deletemetadataResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns__deletemetadataResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_status && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "status", &a->status, "xsd:int"))
				{	soap_flag_status--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns__deletemetadataResponse *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_ns__deletemetadataResponse, 0, sizeof(struct ns__deletemetadataResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns__deletemetadataResponse * SOAP_FMAC6 soap_new_ns__deletemetadataResponse(struct soap *soap, int n)
{	return soap_instantiate_ns__deletemetadataResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns__deletemetadataResponse(struct soap *soap, struct ns__deletemetadataResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns__deletemetadataResponse * SOAP_FMAC4 soap_instantiate_ns__deletemetadataResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__deletemetadataResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns__deletemetadataResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns__deletemetadataResponse;
		if (size)
			*size = sizeof(struct ns__deletemetadataResponse);
	}
	else
	{	cp->ptr = (void*)new struct ns__deletemetadataResponse[n];
		if (size)
			*size = n * sizeof(struct ns__deletemetadataResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns__deletemetadataResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns__deletemetadataResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns__deletemetadataResponse %p -> %p\n", q, p));
	*(struct ns__deletemetadataResponse*)p = *(struct ns__deletemetadataResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__listmetadata(struct soap *soap, const struct ns__listmetadata *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->id, SOAP_TYPE_int);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__listmetadata(struct soap *soap, struct ns__listmetadata *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->id);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__listmetadata(struct soap *soap, const struct ns__listmetadata *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns__listmetadata);
	if (soap_out_ns__listmetadata(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__listmetadata(struct soap *soap, const char *tag, int id, const struct ns__listmetadata *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__listmetadata), type);
	soap_out_int(soap, "id", -1, &a->id, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct ns__listmetadata * SOAP_FMAC4 soap_get_ns__listmetadata(struct soap *soap, struct ns__listmetadata *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__listmetadata(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct ns__listmetadata * SOAP_FMAC4 soap_in_ns__listmetadata(struct soap *soap, const char *tag, struct ns__listmetadata *a, const char *type)
{
	short soap_flag_id = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct ns__listmetadata *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__listmetadata, sizeof(struct ns__listmetadata), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns__listmetadata(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_id && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "id", &a->id, "xsd:int"))
				{	soap_flag_id--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_id > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns__listmetadata *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_ns__listmetadata, 0, sizeof(struct ns__listmetadata), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns__listmetadata * SOAP_FMAC6 soap_new_ns__listmetadata(struct soap *soap, int n)
{	return soap_instantiate_ns__listmetadata(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns__listmetadata(struct soap *soap, struct ns__listmetadata *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns__listmetadata * SOAP_FMAC4 soap_instantiate_ns__listmetadata(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__listmetadata(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns__listmetadata, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns__listmetadata;
		if (size)
			*size = sizeof(struct ns__listmetadata);
	}
	else
	{	cp->ptr = (void*)new struct ns__listmetadata[n];
		if (size)
			*size = n * sizeof(struct ns__listmetadata);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns__listmetadata*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns__listmetadata(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns__listmetadata %p -> %p\n", q, p));
	*(struct ns__listmetadata*)p = *(struct ns__listmetadata*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__listmetadataResponse(struct soap *soap, const struct ns__listmetadataResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTostring(soap, &a->list);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__listmetadataResponse(struct soap *soap, struct ns__listmetadataResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->list = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__listmetadataResponse(struct soap *soap, const struct ns__listmetadataResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns__listmetadataResponse);
	if (soap_out_ns__listmetadataResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__listmetadataResponse(struct soap *soap, const char *tag, int id, const struct ns__listmetadataResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__listmetadataResponse), type);
	if (a->list)
		soap_element_result(soap, "list");
	soap_out_PointerTostring(soap, "list", -1, &a->list, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct ns__listmetadataResponse * SOAP_FMAC4 soap_get_ns__listmetadataResponse(struct soap *soap, struct ns__listmetadataResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__listmetadataResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct ns__listmetadataResponse * SOAP_FMAC4 soap_in_ns__listmetadataResponse(struct soap *soap, const char *tag, struct ns__listmetadataResponse *a, const char *type)
{
	short soap_flag_list = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct ns__listmetadataResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__listmetadataResponse, sizeof(struct ns__listmetadataResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns__listmetadataResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_list && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTostring(soap, "list", &a->list, "xsd:string"))
				{	soap_flag_list--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns__listmetadataResponse *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_ns__listmetadataResponse, 0, sizeof(struct ns__listmetadataResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns__listmetadataResponse * SOAP_FMAC6 soap_new_ns__listmetadataResponse(struct soap *soap, int n)
{	return soap_instantiate_ns__listmetadataResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns__listmetadataResponse(struct soap *soap, struct ns__listmetadataResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns__listmetadataResponse * SOAP_FMAC4 soap_instantiate_ns__listmetadataResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__listmetadataResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns__listmetadataResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns__listmetadataResponse;
		if (size)
			*size = sizeof(struct ns__listmetadataResponse);
	}
	else
	{	cp->ptr = (void*)new struct ns__listmetadataResponse[n];
		if (size)
			*size = n * sizeof(struct ns__listmetadataResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns__listmetadataResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns__listmetadataResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns__listmetadataResponse %p -> %p\n", q, p));
	*(struct ns__listmetadataResponse*)p = *(struct ns__listmetadataResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__setmetadata(struct soap *soap, const struct ns__setmetadata *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->id, SOAP_TYPE_int);
	soap_serialize_string(soap, &a->name);
	soap_serialize_string(soap, &a->property);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__setmetadata(struct soap *soap, struct ns__setmetadata *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->id);
	soap_default_string(soap, &a->name);
	soap_default_string(soap, &a->property);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__setmetadata(struct soap *soap, const struct ns__setmetadata *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns__setmetadata);
	if (soap_out_ns__setmetadata(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__setmetadata(struct soap *soap, const char *tag, int id, const struct ns__setmetadata *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__setmetadata), type);
	soap_out_int(soap, "id", -1, &a->id, "");
	soap_out_string(soap, "name", -1, &a->name, "");
	soap_out_string(soap, "property", -1, &a->property, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct ns__setmetadata * SOAP_FMAC4 soap_get_ns__setmetadata(struct soap *soap, struct ns__setmetadata *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__setmetadata(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct ns__setmetadata * SOAP_FMAC4 soap_in_ns__setmetadata(struct soap *soap, const char *tag, struct ns__setmetadata *a, const char *type)
{
	short soap_flag_id = 1, soap_flag_name = 1, soap_flag_property = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct ns__setmetadata *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__setmetadata, sizeof(struct ns__setmetadata), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns__setmetadata(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_id && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "id", &a->id, "xsd:int"))
				{	soap_flag_id--;
					continue;
				}
			if (soap_flag_name && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "name", &a->name, "xsd:string"))
				{	soap_flag_name--;
					continue;
				}
			if (soap_flag_property && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "property", &a->property, "xsd:string"))
				{	soap_flag_property--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_id > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns__setmetadata *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_ns__setmetadata, 0, sizeof(struct ns__setmetadata), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns__setmetadata * SOAP_FMAC6 soap_new_ns__setmetadata(struct soap *soap, int n)
{	return soap_instantiate_ns__setmetadata(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns__setmetadata(struct soap *soap, struct ns__setmetadata *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns__setmetadata * SOAP_FMAC4 soap_instantiate_ns__setmetadata(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__setmetadata(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns__setmetadata, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns__setmetadata;
		if (size)
			*size = sizeof(struct ns__setmetadata);
	}
	else
	{	cp->ptr = (void*)new struct ns__setmetadata[n];
		if (size)
			*size = n * sizeof(struct ns__setmetadata);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns__setmetadata*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns__setmetadata(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns__setmetadata %p -> %p\n", q, p));
	*(struct ns__setmetadata*)p = *(struct ns__setmetadata*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__setmetadataResponse(struct soap *soap, const struct ns__setmetadataResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToint(soap, &a->status);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__setmetadataResponse(struct soap *soap, struct ns__setmetadataResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->status = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__setmetadataResponse(struct soap *soap, const struct ns__setmetadataResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns__setmetadataResponse);
	if (soap_out_ns__setmetadataResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__setmetadataResponse(struct soap *soap, const char *tag, int id, const struct ns__setmetadataResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__setmetadataResponse), type);
	if (a->status)
		soap_element_result(soap, "status");
	soap_out_PointerToint(soap, "status", -1, &a->status, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct ns__setmetadataResponse * SOAP_FMAC4 soap_get_ns__setmetadataResponse(struct soap *soap, struct ns__setmetadataResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__setmetadataResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct ns__setmetadataResponse * SOAP_FMAC4 soap_in_ns__setmetadataResponse(struct soap *soap, const char *tag, struct ns__setmetadataResponse *a, const char *type)
{
	short soap_flag_status = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct ns__setmetadataResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__setmetadataResponse, sizeof(struct ns__setmetadataResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns__setmetadataResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_status && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "status", &a->status, "xsd:int"))
				{	soap_flag_status--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns__setmetadataResponse *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_ns__setmetadataResponse, 0, sizeof(struct ns__setmetadataResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns__setmetadataResponse * SOAP_FMAC6 soap_new_ns__setmetadataResponse(struct soap *soap, int n)
{	return soap_instantiate_ns__setmetadataResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns__setmetadataResponse(struct soap *soap, struct ns__setmetadataResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns__setmetadataResponse * SOAP_FMAC4 soap_instantiate_ns__setmetadataResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__setmetadataResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns__setmetadataResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns__setmetadataResponse;
		if (size)
			*size = sizeof(struct ns__setmetadataResponse);
	}
	else
	{	cp->ptr = (void*)new struct ns__setmetadataResponse[n];
		if (size)
			*size = n * sizeof(struct ns__setmetadataResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns__setmetadataResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns__setmetadataResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns__setmetadataResponse %p -> %p\n", q, p));
	*(struct ns__setmetadataResponse*)p = *(struct ns__setmetadataResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__setparammmat3d(struct soap *soap, const struct ns__setparammmat3d *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->id, SOAP_TYPE_int);
	soap_serialize_string(soap, &a->name);
	soap_embedded(soap, &a->value, SOAP_TYPE_fdata);
	soap_serialize_fdata(soap, &a->value);
	soap_embedded(soap, &a->n, SOAP_TYPE_int);
	soap_embedded(soap, &a->p, SOAP_TYPE_int);
	soap_embedded(soap, &a->q, SOAP_TYPE_int);
	soap_embedded(soap, &a->nr, SOAP_TYPE_int);
	soap_embedded(soap, &a->nc, SOAP_TYPE_int);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__setparammmat3d(struct soap *soap, struct ns__setparammmat3d *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->id);
	soap_default_string(soap, &a->name);
	soap_default_fdata(soap, &a->value);
	soap_default_int(soap, &a->n);
	soap_default_int(soap, &a->p);
	soap_default_int(soap, &a->q);
	soap_default_int(soap, &a->nr);
	soap_default_int(soap, &a->nc);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__setparammmat3d(struct soap *soap, const struct ns__setparammmat3d *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns__setparammmat3d);
	if (soap_out_ns__setparammmat3d(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__setparammmat3d(struct soap *soap, const char *tag, int id, const struct ns__setparammmat3d *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__setparammmat3d), type);
	soap_out_int(soap, "id", -1, &a->id, "");
	soap_out_string(soap, "name", -1, &a->name, "");
	soap_out_fdata(soap, "value", -1, &a->value, "");
	soap_out_int(soap, "n", -1, &a->n, "");
	soap_out_int(soap, "p", -1, &a->p, "");
	soap_out_int(soap, "q", -1, &a->q, "");
	soap_out_int(soap, "nr", -1, &a->nr, "");
	soap_out_int(soap, "nc", -1, &a->nc, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct ns__setparammmat3d * SOAP_FMAC4 soap_get_ns__setparammmat3d(struct soap *soap, struct ns__setparammmat3d *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__setparammmat3d(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct ns__setparammmat3d * SOAP_FMAC4 soap_in_ns__setparammmat3d(struct soap *soap, const char *tag, struct ns__setparammmat3d *a, const char *type)
{
	short soap_flag_id = 1, soap_flag_name = 1, soap_flag_value = 1, soap_flag_n = 1, soap_flag_p = 1, soap_flag_q = 1, soap_flag_nr = 1, soap_flag_nc = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct ns__setparammmat3d *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__setparammmat3d, sizeof(struct ns__setparammmat3d), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns__setparammmat3d(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_id && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "id", &a->id, "xsd:int"))
				{	soap_flag_id--;
					continue;
				}
			if (soap_flag_name && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "name", &a->name, "xsd:string"))
				{	soap_flag_name--;
					continue;
				}
			if (soap_flag_value && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_fdata(soap, "value", &a->value, "xsd:double"))
				{	soap_flag_value--;
					continue;
				}
			if (soap_flag_n && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "n", &a->n, "xsd:int"))
				{	soap_flag_n--;
					continue;
				}
			if (soap_flag_p && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "p", &a->p, "xsd:int"))
				{	soap_flag_p--;
					continue;
				}
			if (soap_flag_q && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "q", &a->q, "xsd:int"))
				{	soap_flag_q--;
					continue;
				}
			if (soap_flag_nr && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "nr", &a->nr, "xsd:int"))
				{	soap_flag_nr--;
					continue;
				}
			if (soap_flag_nc && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "nc", &a->nc, "xsd:int"))
				{	soap_flag_nc--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_id > 0 || soap_flag_value > 0 || soap_flag_n > 0 || soap_flag_p > 0 || soap_flag_q > 0 || soap_flag_nr > 0 || soap_flag_nc > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns__setparammmat3d *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_ns__setparammmat3d, 0, sizeof(struct ns__setparammmat3d), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns__setparammmat3d * SOAP_FMAC6 soap_new_ns__setparammmat3d(struct soap *soap, int n)
{	return soap_instantiate_ns__setparammmat3d(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns__setparammmat3d(struct soap *soap, struct ns__setparammmat3d *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns__setparammmat3d * SOAP_FMAC4 soap_instantiate_ns__setparammmat3d(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__setparammmat3d(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns__setparammmat3d, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns__setparammmat3d;
		if (size)
			*size = sizeof(struct ns__setparammmat3d);
	}
	else
	{	cp->ptr = (void*)new struct ns__setparammmat3d[n];
		if (size)
			*size = n * sizeof(struct ns__setparammmat3d);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns__setparammmat3d*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns__setparammmat3d(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns__setparammmat3d %p -> %p\n", q, p));
	*(struct ns__setparammmat3d*)p = *(struct ns__setparammmat3d*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__setparammmat3dResponse(struct soap *soap, const struct ns__setparammmat3dResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToint(soap, &a->status);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__setparammmat3dResponse(struct soap *soap, struct ns__setparammmat3dResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->status = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__setparammmat3dResponse(struct soap *soap, const struct ns__setparammmat3dResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns__setparammmat3dResponse);
	if (soap_out_ns__setparammmat3dResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__setparammmat3dResponse(struct soap *soap, const char *tag, int id, const struct ns__setparammmat3dResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__setparammmat3dResponse), type);
	if (a->status)
		soap_element_result(soap, "status");
	soap_out_PointerToint(soap, "status", -1, &a->status, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct ns__setparammmat3dResponse * SOAP_FMAC4 soap_get_ns__setparammmat3dResponse(struct soap *soap, struct ns__setparammmat3dResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__setparammmat3dResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct ns__setparammmat3dResponse * SOAP_FMAC4 soap_in_ns__setparammmat3dResponse(struct soap *soap, const char *tag, struct ns__setparammmat3dResponse *a, const char *type)
{
	short soap_flag_status = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct ns__setparammmat3dResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__setparammmat3dResponse, sizeof(struct ns__setparammmat3dResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns__setparammmat3dResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_status && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "status", &a->status, "xsd:int"))
				{	soap_flag_status--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns__setparammmat3dResponse *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_ns__setparammmat3dResponse, 0, sizeof(struct ns__setparammmat3dResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns__setparammmat3dResponse * SOAP_FMAC6 soap_new_ns__setparammmat3dResponse(struct soap *soap, int n)
{	return soap_instantiate_ns__setparammmat3dResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns__setparammmat3dResponse(struct soap *soap, struct ns__setparammmat3dResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns__setparammmat3dResponse * SOAP_FMAC4 soap_instantiate_ns__setparammmat3dResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__setparammmat3dResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns__setparammmat3dResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns__setparammmat3dResponse;
		if (size)
			*size = sizeof(struct ns__setparammmat3dResponse);
	}
	else
	{	cp->ptr = (void*)new struct ns__setparammmat3dResponse[n];
		if (size)
			*size = n * sizeof(struct ns__setparammmat3dResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns__setparammmat3dResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns__setparammmat3dResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns__setparammmat3dResponse %p -> %p\n", q, p));
	*(struct ns__setparammmat3dResponse*)p = *(struct ns__setparammmat3dResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__setparamstring(struct soap *soap, const struct ns__setparamstring *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->id, SOAP_TYPE_int);
	soap_serialize_string(soap, &a->name);
	soap_serialize_string(soap, &a->value);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__setparamstring(struct soap *soap, struct ns__setparamstring *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->id);
	soap_default_string(soap, &a->name);
	soap_default_string(soap, &a->value);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__setparamstring(struct soap *soap, const struct ns__setparamstring *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns__setparamstring);
	if (soap_out_ns__setparamstring(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__setparamstring(struct soap *soap, const char *tag, int id, const struct ns__setparamstring *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__setparamstring), type);
	soap_out_int(soap, "id", -1, &a->id, "");
	soap_out_string(soap, "name", -1, &a->name, "");
	soap_out_string(soap, "value", -1, &a->value, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct ns__setparamstring * SOAP_FMAC4 soap_get_ns__setparamstring(struct soap *soap, struct ns__setparamstring *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__setparamstring(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct ns__setparamstring * SOAP_FMAC4 soap_in_ns__setparamstring(struct soap *soap, const char *tag, struct ns__setparamstring *a, const char *type)
{
	short soap_flag_id = 1, soap_flag_name = 1, soap_flag_value = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct ns__setparamstring *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__setparamstring, sizeof(struct ns__setparamstring), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns__setparamstring(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_id && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "id", &a->id, "xsd:int"))
				{	soap_flag_id--;
					continue;
				}
			if (soap_flag_name && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "name", &a->name, "xsd:string"))
				{	soap_flag_name--;
					continue;
				}
			if (soap_flag_value && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "value", &a->value, "xsd:string"))
				{	soap_flag_value--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_id > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns__setparamstring *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_ns__setparamstring, 0, sizeof(struct ns__setparamstring), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns__setparamstring * SOAP_FMAC6 soap_new_ns__setparamstring(struct soap *soap, int n)
{	return soap_instantiate_ns__setparamstring(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns__setparamstring(struct soap *soap, struct ns__setparamstring *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns__setparamstring * SOAP_FMAC4 soap_instantiate_ns__setparamstring(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__setparamstring(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns__setparamstring, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns__setparamstring;
		if (size)
			*size = sizeof(struct ns__setparamstring);
	}
	else
	{	cp->ptr = (void*)new struct ns__setparamstring[n];
		if (size)
			*size = n * sizeof(struct ns__setparamstring);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns__setparamstring*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns__setparamstring(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns__setparamstring %p -> %p\n", q, p));
	*(struct ns__setparamstring*)p = *(struct ns__setparamstring*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__setparamstringResponse(struct soap *soap, const struct ns__setparamstringResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToint(soap, &a->status);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__setparamstringResponse(struct soap *soap, struct ns__setparamstringResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->status = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__setparamstringResponse(struct soap *soap, const struct ns__setparamstringResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns__setparamstringResponse);
	if (soap_out_ns__setparamstringResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__setparamstringResponse(struct soap *soap, const char *tag, int id, const struct ns__setparamstringResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__setparamstringResponse), type);
	if (a->status)
		soap_element_result(soap, "status");
	soap_out_PointerToint(soap, "status", -1, &a->status, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct ns__setparamstringResponse * SOAP_FMAC4 soap_get_ns__setparamstringResponse(struct soap *soap, struct ns__setparamstringResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__setparamstringResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct ns__setparamstringResponse * SOAP_FMAC4 soap_in_ns__setparamstringResponse(struct soap *soap, const char *tag, struct ns__setparamstringResponse *a, const char *type)
{
	short soap_flag_status = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct ns__setparamstringResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__setparamstringResponse, sizeof(struct ns__setparamstringResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns__setparamstringResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_status && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "status", &a->status, "xsd:int"))
				{	soap_flag_status--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns__setparamstringResponse *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_ns__setparamstringResponse, 0, sizeof(struct ns__setparamstringResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns__setparamstringResponse * SOAP_FMAC6 soap_new_ns__setparamstringResponse(struct soap *soap, int n)
{	return soap_instantiate_ns__setparamstringResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns__setparamstringResponse(struct soap *soap, struct ns__setparamstringResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns__setparamstringResponse * SOAP_FMAC4 soap_instantiate_ns__setparamstringResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__setparamstringResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns__setparamstringResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns__setparamstringResponse;
		if (size)
			*size = sizeof(struct ns__setparamstringResponse);
	}
	else
	{	cp->ptr = (void*)new struct ns__setparamstringResponse[n];
		if (size)
			*size = n * sizeof(struct ns__setparamstringResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns__setparamstringResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns__setparamstringResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns__setparamstringResponse %p -> %p\n", q, p));
	*(struct ns__setparamstringResponse*)p = *(struct ns__setparamstringResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__setparammat(struct soap *soap, const struct ns__setparammat *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->id, SOAP_TYPE_int);
	soap_serialize_string(soap, &a->name);
	soap_embedded(soap, &a->value, SOAP_TYPE_fdata);
	soap_serialize_fdata(soap, &a->value);
	soap_embedded(soap, &a->nr, SOAP_TYPE_int);
	soap_embedded(soap, &a->nc, SOAP_TYPE_int);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__setparammat(struct soap *soap, struct ns__setparammat *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->id);
	soap_default_string(soap, &a->name);
	soap_default_fdata(soap, &a->value);
	soap_default_int(soap, &a->nr);
	soap_default_int(soap, &a->nc);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__setparammat(struct soap *soap, const struct ns__setparammat *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns__setparammat);
	if (soap_out_ns__setparammat(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__setparammat(struct soap *soap, const char *tag, int id, const struct ns__setparammat *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__setparammat), type);
	soap_out_int(soap, "id", -1, &a->id, "");
	soap_out_string(soap, "name", -1, &a->name, "");
	soap_out_fdata(soap, "value", -1, &a->value, "");
	soap_out_int(soap, "nr", -1, &a->nr, "");
	soap_out_int(soap, "nc", -1, &a->nc, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct ns__setparammat * SOAP_FMAC4 soap_get_ns__setparammat(struct soap *soap, struct ns__setparammat *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__setparammat(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct ns__setparammat * SOAP_FMAC4 soap_in_ns__setparammat(struct soap *soap, const char *tag, struct ns__setparammat *a, const char *type)
{
	short soap_flag_id = 1, soap_flag_name = 1, soap_flag_value = 1, soap_flag_nr = 1, soap_flag_nc = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct ns__setparammat *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__setparammat, sizeof(struct ns__setparammat), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns__setparammat(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_id && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "id", &a->id, "xsd:int"))
				{	soap_flag_id--;
					continue;
				}
			if (soap_flag_name && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "name", &a->name, "xsd:string"))
				{	soap_flag_name--;
					continue;
				}
			if (soap_flag_value && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_fdata(soap, "value", &a->value, "xsd:double"))
				{	soap_flag_value--;
					continue;
				}
			if (soap_flag_nr && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "nr", &a->nr, "xsd:int"))
				{	soap_flag_nr--;
					continue;
				}
			if (soap_flag_nc && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "nc", &a->nc, "xsd:int"))
				{	soap_flag_nc--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_id > 0 || soap_flag_value > 0 || soap_flag_nr > 0 || soap_flag_nc > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns__setparammat *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_ns__setparammat, 0, sizeof(struct ns__setparammat), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns__setparammat * SOAP_FMAC6 soap_new_ns__setparammat(struct soap *soap, int n)
{	return soap_instantiate_ns__setparammat(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns__setparammat(struct soap *soap, struct ns__setparammat *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns__setparammat * SOAP_FMAC4 soap_instantiate_ns__setparammat(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__setparammat(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns__setparammat, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns__setparammat;
		if (size)
			*size = sizeof(struct ns__setparammat);
	}
	else
	{	cp->ptr = (void*)new struct ns__setparammat[n];
		if (size)
			*size = n * sizeof(struct ns__setparammat);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns__setparammat*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns__setparammat(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns__setparammat %p -> %p\n", q, p));
	*(struct ns__setparammat*)p = *(struct ns__setparammat*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__setparammatResponse(struct soap *soap, const struct ns__setparammatResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToint(soap, &a->status);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__setparammatResponse(struct soap *soap, struct ns__setparammatResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->status = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__setparammatResponse(struct soap *soap, const struct ns__setparammatResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns__setparammatResponse);
	if (soap_out_ns__setparammatResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__setparammatResponse(struct soap *soap, const char *tag, int id, const struct ns__setparammatResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__setparammatResponse), type);
	if (a->status)
		soap_element_result(soap, "status");
	soap_out_PointerToint(soap, "status", -1, &a->status, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct ns__setparammatResponse * SOAP_FMAC4 soap_get_ns__setparammatResponse(struct soap *soap, struct ns__setparammatResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__setparammatResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct ns__setparammatResponse * SOAP_FMAC4 soap_in_ns__setparammatResponse(struct soap *soap, const char *tag, struct ns__setparammatResponse *a, const char *type)
{
	short soap_flag_status = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct ns__setparammatResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__setparammatResponse, sizeof(struct ns__setparammatResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns__setparammatResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_status && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "status", &a->status, "xsd:int"))
				{	soap_flag_status--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns__setparammatResponse *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_ns__setparammatResponse, 0, sizeof(struct ns__setparammatResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns__setparammatResponse * SOAP_FMAC6 soap_new_ns__setparammatResponse(struct soap *soap, int n)
{	return soap_instantiate_ns__setparammatResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns__setparammatResponse(struct soap *soap, struct ns__setparammatResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns__setparammatResponse * SOAP_FMAC4 soap_instantiate_ns__setparammatResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__setparammatResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns__setparammatResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns__setparammatResponse;
		if (size)
			*size = sizeof(struct ns__setparammatResponse);
	}
	else
	{	cp->ptr = (void*)new struct ns__setparammatResponse[n];
		if (size)
			*size = n * sizeof(struct ns__setparammatResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns__setparammatResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns__setparammatResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns__setparammatResponse %p -> %p\n", q, p));
	*(struct ns__setparammatResponse*)p = *(struct ns__setparammatResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__setparamvec(struct soap *soap, const struct ns__setparamvec *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->id, SOAP_TYPE_int);
	soap_serialize_string(soap, &a->name);
	soap_embedded(soap, &a->value, SOAP_TYPE_fdata);
	soap_serialize_fdata(soap, &a->value);
	soap_embedded(soap, &a->n, SOAP_TYPE_int);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__setparamvec(struct soap *soap, struct ns__setparamvec *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->id);
	soap_default_string(soap, &a->name);
	soap_default_fdata(soap, &a->value);
	soap_default_int(soap, &a->n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__setparamvec(struct soap *soap, const struct ns__setparamvec *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns__setparamvec);
	if (soap_out_ns__setparamvec(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__setparamvec(struct soap *soap, const char *tag, int id, const struct ns__setparamvec *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__setparamvec), type);
	soap_out_int(soap, "id", -1, &a->id, "");
	soap_out_string(soap, "name", -1, &a->name, "");
	soap_out_fdata(soap, "value", -1, &a->value, "");
	soap_out_int(soap, "n", -1, &a->n, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct ns__setparamvec * SOAP_FMAC4 soap_get_ns__setparamvec(struct soap *soap, struct ns__setparamvec *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__setparamvec(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct ns__setparamvec * SOAP_FMAC4 soap_in_ns__setparamvec(struct soap *soap, const char *tag, struct ns__setparamvec *a, const char *type)
{
	short soap_flag_id = 1, soap_flag_name = 1, soap_flag_value = 1, soap_flag_n = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct ns__setparamvec *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__setparamvec, sizeof(struct ns__setparamvec), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns__setparamvec(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_id && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "id", &a->id, "xsd:int"))
				{	soap_flag_id--;
					continue;
				}
			if (soap_flag_name && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "name", &a->name, "xsd:string"))
				{	soap_flag_name--;
					continue;
				}
			if (soap_flag_value && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_fdata(soap, "value", &a->value, "xsd:double"))
				{	soap_flag_value--;
					continue;
				}
			if (soap_flag_n && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "n", &a->n, "xsd:int"))
				{	soap_flag_n--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_id > 0 || soap_flag_value > 0 || soap_flag_n > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns__setparamvec *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_ns__setparamvec, 0, sizeof(struct ns__setparamvec), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns__setparamvec * SOAP_FMAC6 soap_new_ns__setparamvec(struct soap *soap, int n)
{	return soap_instantiate_ns__setparamvec(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns__setparamvec(struct soap *soap, struct ns__setparamvec *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns__setparamvec * SOAP_FMAC4 soap_instantiate_ns__setparamvec(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__setparamvec(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns__setparamvec, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns__setparamvec;
		if (size)
			*size = sizeof(struct ns__setparamvec);
	}
	else
	{	cp->ptr = (void*)new struct ns__setparamvec[n];
		if (size)
			*size = n * sizeof(struct ns__setparamvec);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns__setparamvec*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns__setparamvec(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns__setparamvec %p -> %p\n", q, p));
	*(struct ns__setparamvec*)p = *(struct ns__setparamvec*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__setparamvecResponse(struct soap *soap, const struct ns__setparamvecResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToint(soap, &a->status);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__setparamvecResponse(struct soap *soap, struct ns__setparamvecResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->status = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__setparamvecResponse(struct soap *soap, const struct ns__setparamvecResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns__setparamvecResponse);
	if (soap_out_ns__setparamvecResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__setparamvecResponse(struct soap *soap, const char *tag, int id, const struct ns__setparamvecResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__setparamvecResponse), type);
	if (a->status)
		soap_element_result(soap, "status");
	soap_out_PointerToint(soap, "status", -1, &a->status, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct ns__setparamvecResponse * SOAP_FMAC4 soap_get_ns__setparamvecResponse(struct soap *soap, struct ns__setparamvecResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__setparamvecResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct ns__setparamvecResponse * SOAP_FMAC4 soap_in_ns__setparamvecResponse(struct soap *soap, const char *tag, struct ns__setparamvecResponse *a, const char *type)
{
	short soap_flag_status = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct ns__setparamvecResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__setparamvecResponse, sizeof(struct ns__setparamvecResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns__setparamvecResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_status && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "status", &a->status, "xsd:int"))
				{	soap_flag_status--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns__setparamvecResponse *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_ns__setparamvecResponse, 0, sizeof(struct ns__setparamvecResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns__setparamvecResponse * SOAP_FMAC6 soap_new_ns__setparamvecResponse(struct soap *soap, int n)
{	return soap_instantiate_ns__setparamvecResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns__setparamvecResponse(struct soap *soap, struct ns__setparamvecResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns__setparamvecResponse * SOAP_FMAC4 soap_instantiate_ns__setparamvecResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__setparamvecResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns__setparamvecResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns__setparamvecResponse;
		if (size)
			*size = sizeof(struct ns__setparamvecResponse);
	}
	else
	{	cp->ptr = (void*)new struct ns__setparamvecResponse[n];
		if (size)
			*size = n * sizeof(struct ns__setparamvecResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns__setparamvecResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns__setparamvecResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns__setparamvecResponse %p -> %p\n", q, p));
	*(struct ns__setparamvecResponse*)p = *(struct ns__setparamvecResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__setparamint(struct soap *soap, const struct ns__setparamint *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->id, SOAP_TYPE_int);
	soap_serialize_string(soap, &a->name);
	soap_embedded(soap, &a->value, SOAP_TYPE_int);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__setparamint(struct soap *soap, struct ns__setparamint *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->id);
	soap_default_string(soap, &a->name);
	soap_default_int(soap, &a->value);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__setparamint(struct soap *soap, const struct ns__setparamint *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns__setparamint);
	if (soap_out_ns__setparamint(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__setparamint(struct soap *soap, const char *tag, int id, const struct ns__setparamint *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__setparamint), type);
	soap_out_int(soap, "id", -1, &a->id, "");
	soap_out_string(soap, "name", -1, &a->name, "");
	soap_out_int(soap, "value", -1, &a->value, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct ns__setparamint * SOAP_FMAC4 soap_get_ns__setparamint(struct soap *soap, struct ns__setparamint *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__setparamint(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct ns__setparamint * SOAP_FMAC4 soap_in_ns__setparamint(struct soap *soap, const char *tag, struct ns__setparamint *a, const char *type)
{
	short soap_flag_id = 1, soap_flag_name = 1, soap_flag_value = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct ns__setparamint *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__setparamint, sizeof(struct ns__setparamint), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns__setparamint(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_id && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "id", &a->id, "xsd:int"))
				{	soap_flag_id--;
					continue;
				}
			if (soap_flag_name && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "name", &a->name, "xsd:string"))
				{	soap_flag_name--;
					continue;
				}
			if (soap_flag_value && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "value", &a->value, "xsd:int"))
				{	soap_flag_value--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_id > 0 || soap_flag_value > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns__setparamint *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_ns__setparamint, 0, sizeof(struct ns__setparamint), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns__setparamint * SOAP_FMAC6 soap_new_ns__setparamint(struct soap *soap, int n)
{	return soap_instantiate_ns__setparamint(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns__setparamint(struct soap *soap, struct ns__setparamint *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns__setparamint * SOAP_FMAC4 soap_instantiate_ns__setparamint(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__setparamint(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns__setparamint, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns__setparamint;
		if (size)
			*size = sizeof(struct ns__setparamint);
	}
	else
	{	cp->ptr = (void*)new struct ns__setparamint[n];
		if (size)
			*size = n * sizeof(struct ns__setparamint);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns__setparamint*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns__setparamint(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns__setparamint %p -> %p\n", q, p));
	*(struct ns__setparamint*)p = *(struct ns__setparamint*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__setparamintResponse(struct soap *soap, const struct ns__setparamintResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToint(soap, &a->status);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__setparamintResponse(struct soap *soap, struct ns__setparamintResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->status = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__setparamintResponse(struct soap *soap, const struct ns__setparamintResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns__setparamintResponse);
	if (soap_out_ns__setparamintResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__setparamintResponse(struct soap *soap, const char *tag, int id, const struct ns__setparamintResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__setparamintResponse), type);
	if (a->status)
		soap_element_result(soap, "status");
	soap_out_PointerToint(soap, "status", -1, &a->status, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct ns__setparamintResponse * SOAP_FMAC4 soap_get_ns__setparamintResponse(struct soap *soap, struct ns__setparamintResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__setparamintResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct ns__setparamintResponse * SOAP_FMAC4 soap_in_ns__setparamintResponse(struct soap *soap, const char *tag, struct ns__setparamintResponse *a, const char *type)
{
	short soap_flag_status = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct ns__setparamintResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__setparamintResponse, sizeof(struct ns__setparamintResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns__setparamintResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_status && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "status", &a->status, "xsd:int"))
				{	soap_flag_status--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns__setparamintResponse *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_ns__setparamintResponse, 0, sizeof(struct ns__setparamintResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns__setparamintResponse * SOAP_FMAC6 soap_new_ns__setparamintResponse(struct soap *soap, int n)
{	return soap_instantiate_ns__setparamintResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns__setparamintResponse(struct soap *soap, struct ns__setparamintResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns__setparamintResponse * SOAP_FMAC4 soap_instantiate_ns__setparamintResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__setparamintResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns__setparamintResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns__setparamintResponse;
		if (size)
			*size = sizeof(struct ns__setparamintResponse);
	}
	else
	{	cp->ptr = (void*)new struct ns__setparamintResponse[n];
		if (size)
			*size = n * sizeof(struct ns__setparamintResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns__setparamintResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns__setparamintResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns__setparamintResponse %p -> %p\n", q, p));
	*(struct ns__setparamintResponse*)p = *(struct ns__setparamintResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__setparamdouble(struct soap *soap, const struct ns__setparamdouble *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->id, SOAP_TYPE_int);
	soap_serialize_string(soap, &a->name);
	soap_embedded(soap, &a->value, SOAP_TYPE_double);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__setparamdouble(struct soap *soap, struct ns__setparamdouble *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->id);
	soap_default_string(soap, &a->name);
	soap_default_double(soap, &a->value);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__setparamdouble(struct soap *soap, const struct ns__setparamdouble *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns__setparamdouble);
	if (soap_out_ns__setparamdouble(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__setparamdouble(struct soap *soap, const char *tag, int id, const struct ns__setparamdouble *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__setparamdouble), type);
	soap_out_int(soap, "id", -1, &a->id, "");
	soap_out_string(soap, "name", -1, &a->name, "");
	soap_out_double(soap, "value", -1, &a->value, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct ns__setparamdouble * SOAP_FMAC4 soap_get_ns__setparamdouble(struct soap *soap, struct ns__setparamdouble *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__setparamdouble(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct ns__setparamdouble * SOAP_FMAC4 soap_in_ns__setparamdouble(struct soap *soap, const char *tag, struct ns__setparamdouble *a, const char *type)
{
	short soap_flag_id = 1, soap_flag_name = 1, soap_flag_value = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct ns__setparamdouble *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__setparamdouble, sizeof(struct ns__setparamdouble), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns__setparamdouble(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_id && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "id", &a->id, "xsd:int"))
				{	soap_flag_id--;
					continue;
				}
			if (soap_flag_name && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "name", &a->name, "xsd:string"))
				{	soap_flag_name--;
					continue;
				}
			if (soap_flag_value && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "value", &a->value, "xsd:double"))
				{	soap_flag_value--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_id > 0 || soap_flag_value > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns__setparamdouble *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_ns__setparamdouble, 0, sizeof(struct ns__setparamdouble), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns__setparamdouble * SOAP_FMAC6 soap_new_ns__setparamdouble(struct soap *soap, int n)
{	return soap_instantiate_ns__setparamdouble(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns__setparamdouble(struct soap *soap, struct ns__setparamdouble *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns__setparamdouble * SOAP_FMAC4 soap_instantiate_ns__setparamdouble(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__setparamdouble(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns__setparamdouble, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns__setparamdouble;
		if (size)
			*size = sizeof(struct ns__setparamdouble);
	}
	else
	{	cp->ptr = (void*)new struct ns__setparamdouble[n];
		if (size)
			*size = n * sizeof(struct ns__setparamdouble);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns__setparamdouble*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns__setparamdouble(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns__setparamdouble %p -> %p\n", q, p));
	*(struct ns__setparamdouble*)p = *(struct ns__setparamdouble*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__setparamdoubleResponse(struct soap *soap, const struct ns__setparamdoubleResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToint(soap, &a->status);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__setparamdoubleResponse(struct soap *soap, struct ns__setparamdoubleResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->status = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__setparamdoubleResponse(struct soap *soap, const struct ns__setparamdoubleResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns__setparamdoubleResponse);
	if (soap_out_ns__setparamdoubleResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__setparamdoubleResponse(struct soap *soap, const char *tag, int id, const struct ns__setparamdoubleResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__setparamdoubleResponse), type);
	if (a->status)
		soap_element_result(soap, "status");
	soap_out_PointerToint(soap, "status", -1, &a->status, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct ns__setparamdoubleResponse * SOAP_FMAC4 soap_get_ns__setparamdoubleResponse(struct soap *soap, struct ns__setparamdoubleResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__setparamdoubleResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct ns__setparamdoubleResponse * SOAP_FMAC4 soap_in_ns__setparamdoubleResponse(struct soap *soap, const char *tag, struct ns__setparamdoubleResponse *a, const char *type)
{
	short soap_flag_status = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct ns__setparamdoubleResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__setparamdoubleResponse, sizeof(struct ns__setparamdoubleResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns__setparamdoubleResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_status && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "status", &a->status, "xsd:int"))
				{	soap_flag_status--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns__setparamdoubleResponse *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_ns__setparamdoubleResponse, 0, sizeof(struct ns__setparamdoubleResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns__setparamdoubleResponse * SOAP_FMAC6 soap_new_ns__setparamdoubleResponse(struct soap *soap, int n)
{	return soap_instantiate_ns__setparamdoubleResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns__setparamdoubleResponse(struct soap *soap, struct ns__setparamdoubleResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns__setparamdoubleResponse * SOAP_FMAC4 soap_instantiate_ns__setparamdoubleResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__setparamdoubleResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns__setparamdoubleResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns__setparamdoubleResponse;
		if (size)
			*size = sizeof(struct ns__setparamdoubleResponse);
	}
	else
	{	cp->ptr = (void*)new struct ns__setparamdoubleResponse[n];
		if (size)
			*size = n * sizeof(struct ns__setparamdoubleResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns__setparamdoubleResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns__setparamdoubleResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns__setparamdoubleResponse %p -> %p\n", q, p));
	*(struct ns__setparamdoubleResponse*)p = *(struct ns__setparamdoubleResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__getmetadata(struct soap *soap, const struct ns__getmetadata *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->id, SOAP_TYPE_int);
	soap_serialize_string(soap, &a->name);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__getmetadata(struct soap *soap, struct ns__getmetadata *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->id);
	soap_default_string(soap, &a->name);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__getmetadata(struct soap *soap, const struct ns__getmetadata *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns__getmetadata);
	if (soap_out_ns__getmetadata(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__getmetadata(struct soap *soap, const char *tag, int id, const struct ns__getmetadata *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__getmetadata), type);
	soap_out_int(soap, "id", -1, &a->id, "");
	soap_out_string(soap, "name", -1, &a->name, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct ns__getmetadata * SOAP_FMAC4 soap_get_ns__getmetadata(struct soap *soap, struct ns__getmetadata *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__getmetadata(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct ns__getmetadata * SOAP_FMAC4 soap_in_ns__getmetadata(struct soap *soap, const char *tag, struct ns__getmetadata *a, const char *type)
{
	short soap_flag_id = 1, soap_flag_name = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct ns__getmetadata *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__getmetadata, sizeof(struct ns__getmetadata), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns__getmetadata(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_id && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "id", &a->id, "xsd:int"))
				{	soap_flag_id--;
					continue;
				}
			if (soap_flag_name && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "name", &a->name, "xsd:string"))
				{	soap_flag_name--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_id > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns__getmetadata *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_ns__getmetadata, 0, sizeof(struct ns__getmetadata), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns__getmetadata * SOAP_FMAC6 soap_new_ns__getmetadata(struct soap *soap, int n)
{	return soap_instantiate_ns__getmetadata(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns__getmetadata(struct soap *soap, struct ns__getmetadata *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns__getmetadata * SOAP_FMAC4 soap_instantiate_ns__getmetadata(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__getmetadata(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns__getmetadata, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns__getmetadata;
		if (size)
			*size = sizeof(struct ns__getmetadata);
	}
	else
	{	cp->ptr = (void*)new struct ns__getmetadata[n];
		if (size)
			*size = n * sizeof(struct ns__getmetadata);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns__getmetadata*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns__getmetadata(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns__getmetadata %p -> %p\n", q, p));
	*(struct ns__getmetadata*)p = *(struct ns__getmetadata*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__getmetadataResponse(struct soap *soap, const struct ns__getmetadataResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTostring(soap, &a->property);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__getmetadataResponse(struct soap *soap, struct ns__getmetadataResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->property = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__getmetadataResponse(struct soap *soap, const struct ns__getmetadataResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns__getmetadataResponse);
	if (soap_out_ns__getmetadataResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__getmetadataResponse(struct soap *soap, const char *tag, int id, const struct ns__getmetadataResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__getmetadataResponse), type);
	if (a->property)
		soap_element_result(soap, "property");
	soap_out_PointerTostring(soap, "property", -1, &a->property, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct ns__getmetadataResponse * SOAP_FMAC4 soap_get_ns__getmetadataResponse(struct soap *soap, struct ns__getmetadataResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__getmetadataResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct ns__getmetadataResponse * SOAP_FMAC4 soap_in_ns__getmetadataResponse(struct soap *soap, const char *tag, struct ns__getmetadataResponse *a, const char *type)
{
	short soap_flag_property = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct ns__getmetadataResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__getmetadataResponse, sizeof(struct ns__getmetadataResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns__getmetadataResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_property && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTostring(soap, "property", &a->property, "xsd:string"))
				{	soap_flag_property--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns__getmetadataResponse *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_ns__getmetadataResponse, 0, sizeof(struct ns__getmetadataResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns__getmetadataResponse * SOAP_FMAC6 soap_new_ns__getmetadataResponse(struct soap *soap, int n)
{	return soap_instantiate_ns__getmetadataResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns__getmetadataResponse(struct soap *soap, struct ns__getmetadataResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns__getmetadataResponse * SOAP_FMAC4 soap_instantiate_ns__getmetadataResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__getmetadataResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns__getmetadataResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns__getmetadataResponse;
		if (size)
			*size = sizeof(struct ns__getmetadataResponse);
	}
	else
	{	cp->ptr = (void*)new struct ns__getmetadataResponse[n];
		if (size)
			*size = n * sizeof(struct ns__getmetadataResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns__getmetadataResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns__getmetadataResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns__getmetadataResponse %p -> %p\n", q, p));
	*(struct ns__getmetadataResponse*)p = *(struct ns__getmetadataResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__getparammmat3d(struct soap *soap, const struct ns__getparammmat3d *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->id, SOAP_TYPE_int);
	soap_serialize_string(soap, &a->name);
	soap_embedded(soap, &a->n, SOAP_TYPE_int);
	soap_embedded(soap, &a->p, SOAP_TYPE_int);
	soap_embedded(soap, &a->q, SOAP_TYPE_int);
	soap_embedded(soap, &a->nr, SOAP_TYPE_int);
	soap_embedded(soap, &a->nc, SOAP_TYPE_int);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__getparammmat3d(struct soap *soap, struct ns__getparammmat3d *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->id);
	soap_default_string(soap, &a->name);
	soap_default_int(soap, &a->n);
	soap_default_int(soap, &a->p);
	soap_default_int(soap, &a->q);
	soap_default_int(soap, &a->nr);
	soap_default_int(soap, &a->nc);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__getparammmat3d(struct soap *soap, const struct ns__getparammmat3d *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns__getparammmat3d);
	if (soap_out_ns__getparammmat3d(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__getparammmat3d(struct soap *soap, const char *tag, int id, const struct ns__getparammmat3d *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__getparammmat3d), type);
	soap_out_int(soap, "id", -1, &a->id, "");
	soap_out_string(soap, "name", -1, &a->name, "");
	soap_out_int(soap, "n", -1, &a->n, "");
	soap_out_int(soap, "p", -1, &a->p, "");
	soap_out_int(soap, "q", -1, &a->q, "");
	soap_out_int(soap, "nr", -1, &a->nr, "");
	soap_out_int(soap, "nc", -1, &a->nc, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct ns__getparammmat3d * SOAP_FMAC4 soap_get_ns__getparammmat3d(struct soap *soap, struct ns__getparammmat3d *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__getparammmat3d(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct ns__getparammmat3d * SOAP_FMAC4 soap_in_ns__getparammmat3d(struct soap *soap, const char *tag, struct ns__getparammmat3d *a, const char *type)
{
	short soap_flag_id = 1, soap_flag_name = 1, soap_flag_n = 1, soap_flag_p = 1, soap_flag_q = 1, soap_flag_nr = 1, soap_flag_nc = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct ns__getparammmat3d *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__getparammmat3d, sizeof(struct ns__getparammmat3d), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns__getparammmat3d(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_id && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "id", &a->id, "xsd:int"))
				{	soap_flag_id--;
					continue;
				}
			if (soap_flag_name && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "name", &a->name, "xsd:string"))
				{	soap_flag_name--;
					continue;
				}
			if (soap_flag_n && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "n", &a->n, "xsd:int"))
				{	soap_flag_n--;
					continue;
				}
			if (soap_flag_p && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "p", &a->p, "xsd:int"))
				{	soap_flag_p--;
					continue;
				}
			if (soap_flag_q && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "q", &a->q, "xsd:int"))
				{	soap_flag_q--;
					continue;
				}
			if (soap_flag_nr && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "nr", &a->nr, "xsd:int"))
				{	soap_flag_nr--;
					continue;
				}
			if (soap_flag_nc && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "nc", &a->nc, "xsd:int"))
				{	soap_flag_nc--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_id > 0 || soap_flag_n > 0 || soap_flag_p > 0 || soap_flag_q > 0 || soap_flag_nr > 0 || soap_flag_nc > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns__getparammmat3d *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_ns__getparammmat3d, 0, sizeof(struct ns__getparammmat3d), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns__getparammmat3d * SOAP_FMAC6 soap_new_ns__getparammmat3d(struct soap *soap, int n)
{	return soap_instantiate_ns__getparammmat3d(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns__getparammmat3d(struct soap *soap, struct ns__getparammmat3d *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns__getparammmat3d * SOAP_FMAC4 soap_instantiate_ns__getparammmat3d(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__getparammmat3d(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns__getparammmat3d, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns__getparammmat3d;
		if (size)
			*size = sizeof(struct ns__getparammmat3d);
	}
	else
	{	cp->ptr = (void*)new struct ns__getparammmat3d[n];
		if (size)
			*size = n * sizeof(struct ns__getparammmat3d);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns__getparammmat3d*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns__getparammmat3d(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns__getparammmat3d %p -> %p\n", q, p));
	*(struct ns__getparammmat3d*)p = *(struct ns__getparammmat3d*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__getparammmat3dResponse(struct soap *soap, const struct ns__getparammmat3dResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToPointerTofdata(soap, &a->mmat3d);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__getparammmat3dResponse(struct soap *soap, struct ns__getparammmat3dResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->mmat3d = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__getparammmat3dResponse(struct soap *soap, const struct ns__getparammmat3dResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns__getparammmat3dResponse);
	if (soap_out_ns__getparammmat3dResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__getparammmat3dResponse(struct soap *soap, const char *tag, int id, const struct ns__getparammmat3dResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__getparammmat3dResponse), type);
	if (a->mmat3d)
		soap_element_result(soap, "mmat3d");
	soap_out_PointerToPointerTofdata(soap, "mmat3d", -1, &a->mmat3d, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct ns__getparammmat3dResponse * SOAP_FMAC4 soap_get_ns__getparammmat3dResponse(struct soap *soap, struct ns__getparammmat3dResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__getparammmat3dResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct ns__getparammmat3dResponse * SOAP_FMAC4 soap_in_ns__getparammmat3dResponse(struct soap *soap, const char *tag, struct ns__getparammmat3dResponse *a, const char *type)
{
	short soap_flag_mmat3d = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct ns__getparammmat3dResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__getparammmat3dResponse, sizeof(struct ns__getparammmat3dResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns__getparammmat3dResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_mmat3d && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToPointerTofdata(soap, "mmat3d", &a->mmat3d, "xsd:double"))
				{	soap_flag_mmat3d--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns__getparammmat3dResponse *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_ns__getparammmat3dResponse, 0, sizeof(struct ns__getparammmat3dResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns__getparammmat3dResponse * SOAP_FMAC6 soap_new_ns__getparammmat3dResponse(struct soap *soap, int n)
{	return soap_instantiate_ns__getparammmat3dResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns__getparammmat3dResponse(struct soap *soap, struct ns__getparammmat3dResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns__getparammmat3dResponse * SOAP_FMAC4 soap_instantiate_ns__getparammmat3dResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__getparammmat3dResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns__getparammmat3dResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns__getparammmat3dResponse;
		if (size)
			*size = sizeof(struct ns__getparammmat3dResponse);
	}
	else
	{	cp->ptr = (void*)new struct ns__getparammmat3dResponse[n];
		if (size)
			*size = n * sizeof(struct ns__getparammmat3dResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns__getparammmat3dResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns__getparammmat3dResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns__getparammmat3dResponse %p -> %p\n", q, p));
	*(struct ns__getparammmat3dResponse*)p = *(struct ns__getparammmat3dResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__getparamstring(struct soap *soap, const struct ns__getparamstring *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->id, SOAP_TYPE_int);
	soap_serialize_string(soap, &a->name);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__getparamstring(struct soap *soap, struct ns__getparamstring *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->id);
	soap_default_string(soap, &a->name);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__getparamstring(struct soap *soap, const struct ns__getparamstring *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns__getparamstring);
	if (soap_out_ns__getparamstring(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__getparamstring(struct soap *soap, const char *tag, int id, const struct ns__getparamstring *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__getparamstring), type);
	soap_out_int(soap, "id", -1, &a->id, "");
	soap_out_string(soap, "name", -1, &a->name, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct ns__getparamstring * SOAP_FMAC4 soap_get_ns__getparamstring(struct soap *soap, struct ns__getparamstring *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__getparamstring(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct ns__getparamstring * SOAP_FMAC4 soap_in_ns__getparamstring(struct soap *soap, const char *tag, struct ns__getparamstring *a, const char *type)
{
	short soap_flag_id = 1, soap_flag_name = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct ns__getparamstring *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__getparamstring, sizeof(struct ns__getparamstring), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns__getparamstring(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_id && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "id", &a->id, "xsd:int"))
				{	soap_flag_id--;
					continue;
				}
			if (soap_flag_name && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "name", &a->name, "xsd:string"))
				{	soap_flag_name--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_id > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns__getparamstring *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_ns__getparamstring, 0, sizeof(struct ns__getparamstring), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns__getparamstring * SOAP_FMAC6 soap_new_ns__getparamstring(struct soap *soap, int n)
{	return soap_instantiate_ns__getparamstring(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns__getparamstring(struct soap *soap, struct ns__getparamstring *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns__getparamstring * SOAP_FMAC4 soap_instantiate_ns__getparamstring(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__getparamstring(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns__getparamstring, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns__getparamstring;
		if (size)
			*size = sizeof(struct ns__getparamstring);
	}
	else
	{	cp->ptr = (void*)new struct ns__getparamstring[n];
		if (size)
			*size = n * sizeof(struct ns__getparamstring);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns__getparamstring*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns__getparamstring(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns__getparamstring %p -> %p\n", q, p));
	*(struct ns__getparamstring*)p = *(struct ns__getparamstring*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__getparamstringResponse(struct soap *soap, const struct ns__getparamstringResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTostring(soap, &a->value);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__getparamstringResponse(struct soap *soap, struct ns__getparamstringResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->value = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__getparamstringResponse(struct soap *soap, const struct ns__getparamstringResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns__getparamstringResponse);
	if (soap_out_ns__getparamstringResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__getparamstringResponse(struct soap *soap, const char *tag, int id, const struct ns__getparamstringResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__getparamstringResponse), type);
	if (a->value)
		soap_element_result(soap, "value");
	soap_out_PointerTostring(soap, "value", -1, &a->value, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct ns__getparamstringResponse * SOAP_FMAC4 soap_get_ns__getparamstringResponse(struct soap *soap, struct ns__getparamstringResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__getparamstringResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct ns__getparamstringResponse * SOAP_FMAC4 soap_in_ns__getparamstringResponse(struct soap *soap, const char *tag, struct ns__getparamstringResponse *a, const char *type)
{
	short soap_flag_value = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct ns__getparamstringResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__getparamstringResponse, sizeof(struct ns__getparamstringResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns__getparamstringResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_value && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTostring(soap, "value", &a->value, "xsd:string"))
				{	soap_flag_value--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns__getparamstringResponse *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_ns__getparamstringResponse, 0, sizeof(struct ns__getparamstringResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns__getparamstringResponse * SOAP_FMAC6 soap_new_ns__getparamstringResponse(struct soap *soap, int n)
{	return soap_instantiate_ns__getparamstringResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns__getparamstringResponse(struct soap *soap, struct ns__getparamstringResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns__getparamstringResponse * SOAP_FMAC4 soap_instantiate_ns__getparamstringResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__getparamstringResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns__getparamstringResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns__getparamstringResponse;
		if (size)
			*size = sizeof(struct ns__getparamstringResponse);
	}
	else
	{	cp->ptr = (void*)new struct ns__getparamstringResponse[n];
		if (size)
			*size = n * sizeof(struct ns__getparamstringResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns__getparamstringResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns__getparamstringResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns__getparamstringResponse %p -> %p\n", q, p));
	*(struct ns__getparamstringResponse*)p = *(struct ns__getparamstringResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__getparammat(struct soap *soap, const struct ns__getparammat *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->id, SOAP_TYPE_int);
	soap_serialize_string(soap, &a->name);
	soap_embedded(soap, &a->nr, SOAP_TYPE_int);
	soap_embedded(soap, &a->nc, SOAP_TYPE_int);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__getparammat(struct soap *soap, struct ns__getparammat *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->id);
	soap_default_string(soap, &a->name);
	soap_default_int(soap, &a->nr);
	soap_default_int(soap, &a->nc);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__getparammat(struct soap *soap, const struct ns__getparammat *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns__getparammat);
	if (soap_out_ns__getparammat(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__getparammat(struct soap *soap, const char *tag, int id, const struct ns__getparammat *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__getparammat), type);
	soap_out_int(soap, "id", -1, &a->id, "");
	soap_out_string(soap, "name", -1, &a->name, "");
	soap_out_int(soap, "nr", -1, &a->nr, "");
	soap_out_int(soap, "nc", -1, &a->nc, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct ns__getparammat * SOAP_FMAC4 soap_get_ns__getparammat(struct soap *soap, struct ns__getparammat *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__getparammat(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct ns__getparammat * SOAP_FMAC4 soap_in_ns__getparammat(struct soap *soap, const char *tag, struct ns__getparammat *a, const char *type)
{
	short soap_flag_id = 1, soap_flag_name = 1, soap_flag_nr = 1, soap_flag_nc = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct ns__getparammat *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__getparammat, sizeof(struct ns__getparammat), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns__getparammat(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_id && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "id", &a->id, "xsd:int"))
				{	soap_flag_id--;
					continue;
				}
			if (soap_flag_name && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "name", &a->name, "xsd:string"))
				{	soap_flag_name--;
					continue;
				}
			if (soap_flag_nr && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "nr", &a->nr, "xsd:int"))
				{	soap_flag_nr--;
					continue;
				}
			if (soap_flag_nc && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "nc", &a->nc, "xsd:int"))
				{	soap_flag_nc--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_id > 0 || soap_flag_nr > 0 || soap_flag_nc > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns__getparammat *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_ns__getparammat, 0, sizeof(struct ns__getparammat), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns__getparammat * SOAP_FMAC6 soap_new_ns__getparammat(struct soap *soap, int n)
{	return soap_instantiate_ns__getparammat(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns__getparammat(struct soap *soap, struct ns__getparammat *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns__getparammat * SOAP_FMAC4 soap_instantiate_ns__getparammat(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__getparammat(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns__getparammat, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns__getparammat;
		if (size)
			*size = sizeof(struct ns__getparammat);
	}
	else
	{	cp->ptr = (void*)new struct ns__getparammat[n];
		if (size)
			*size = n * sizeof(struct ns__getparammat);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns__getparammat*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns__getparammat(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns__getparammat %p -> %p\n", q, p));
	*(struct ns__getparammat*)p = *(struct ns__getparammat*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__getparammatResponse(struct soap *soap, const struct ns__getparammatResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToPointerTofdata(soap, &a->dval);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__getparammatResponse(struct soap *soap, struct ns__getparammatResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->dval = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__getparammatResponse(struct soap *soap, const struct ns__getparammatResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns__getparammatResponse);
	if (soap_out_ns__getparammatResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__getparammatResponse(struct soap *soap, const char *tag, int id, const struct ns__getparammatResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__getparammatResponse), type);
	if (a->dval)
		soap_element_result(soap, "dval");
	soap_out_PointerToPointerTofdata(soap, "dval", -1, &a->dval, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct ns__getparammatResponse * SOAP_FMAC4 soap_get_ns__getparammatResponse(struct soap *soap, struct ns__getparammatResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__getparammatResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct ns__getparammatResponse * SOAP_FMAC4 soap_in_ns__getparammatResponse(struct soap *soap, const char *tag, struct ns__getparammatResponse *a, const char *type)
{
	short soap_flag_dval = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct ns__getparammatResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__getparammatResponse, sizeof(struct ns__getparammatResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns__getparammatResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_dval && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToPointerTofdata(soap, "dval", &a->dval, "xsd:double"))
				{	soap_flag_dval--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns__getparammatResponse *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_ns__getparammatResponse, 0, sizeof(struct ns__getparammatResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns__getparammatResponse * SOAP_FMAC6 soap_new_ns__getparammatResponse(struct soap *soap, int n)
{	return soap_instantiate_ns__getparammatResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns__getparammatResponse(struct soap *soap, struct ns__getparammatResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns__getparammatResponse * SOAP_FMAC4 soap_instantiate_ns__getparammatResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__getparammatResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns__getparammatResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns__getparammatResponse;
		if (size)
			*size = sizeof(struct ns__getparammatResponse);
	}
	else
	{	cp->ptr = (void*)new struct ns__getparammatResponse[n];
		if (size)
			*size = n * sizeof(struct ns__getparammatResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns__getparammatResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns__getparammatResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns__getparammatResponse %p -> %p\n", q, p));
	*(struct ns__getparammatResponse*)p = *(struct ns__getparammatResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__getparamvec(struct soap *soap, const struct ns__getparamvec *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->id, SOAP_TYPE_int);
	soap_serialize_string(soap, &a->name);
	soap_embedded(soap, &a->n, SOAP_TYPE_int);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__getparamvec(struct soap *soap, struct ns__getparamvec *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->id);
	soap_default_string(soap, &a->name);
	soap_default_int(soap, &a->n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__getparamvec(struct soap *soap, const struct ns__getparamvec *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns__getparamvec);
	if (soap_out_ns__getparamvec(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__getparamvec(struct soap *soap, const char *tag, int id, const struct ns__getparamvec *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__getparamvec), type);
	soap_out_int(soap, "id", -1, &a->id, "");
	soap_out_string(soap, "name", -1, &a->name, "");
	soap_out_int(soap, "n", -1, &a->n, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct ns__getparamvec * SOAP_FMAC4 soap_get_ns__getparamvec(struct soap *soap, struct ns__getparamvec *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__getparamvec(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct ns__getparamvec * SOAP_FMAC4 soap_in_ns__getparamvec(struct soap *soap, const char *tag, struct ns__getparamvec *a, const char *type)
{
	short soap_flag_id = 1, soap_flag_name = 1, soap_flag_n = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct ns__getparamvec *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__getparamvec, sizeof(struct ns__getparamvec), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns__getparamvec(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_id && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "id", &a->id, "xsd:int"))
				{	soap_flag_id--;
					continue;
				}
			if (soap_flag_name && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "name", &a->name, "xsd:string"))
				{	soap_flag_name--;
					continue;
				}
			if (soap_flag_n && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "n", &a->n, "xsd:int"))
				{	soap_flag_n--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_id > 0 || soap_flag_n > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns__getparamvec *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_ns__getparamvec, 0, sizeof(struct ns__getparamvec), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns__getparamvec * SOAP_FMAC6 soap_new_ns__getparamvec(struct soap *soap, int n)
{	return soap_instantiate_ns__getparamvec(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns__getparamvec(struct soap *soap, struct ns__getparamvec *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns__getparamvec * SOAP_FMAC4 soap_instantiate_ns__getparamvec(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__getparamvec(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns__getparamvec, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns__getparamvec;
		if (size)
			*size = sizeof(struct ns__getparamvec);
	}
	else
	{	cp->ptr = (void*)new struct ns__getparamvec[n];
		if (size)
			*size = n * sizeof(struct ns__getparamvec);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns__getparamvec*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns__getparamvec(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns__getparamvec %p -> %p\n", q, p));
	*(struct ns__getparamvec*)p = *(struct ns__getparamvec*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__getparamvecResponse(struct soap *soap, const struct ns__getparamvecResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToPointerTofdata(soap, &a->dval);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__getparamvecResponse(struct soap *soap, struct ns__getparamvecResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->dval = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__getparamvecResponse(struct soap *soap, const struct ns__getparamvecResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns__getparamvecResponse);
	if (soap_out_ns__getparamvecResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__getparamvecResponse(struct soap *soap, const char *tag, int id, const struct ns__getparamvecResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__getparamvecResponse), type);
	if (a->dval)
		soap_element_result(soap, "dval");
	soap_out_PointerToPointerTofdata(soap, "dval", -1, &a->dval, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct ns__getparamvecResponse * SOAP_FMAC4 soap_get_ns__getparamvecResponse(struct soap *soap, struct ns__getparamvecResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__getparamvecResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct ns__getparamvecResponse * SOAP_FMAC4 soap_in_ns__getparamvecResponse(struct soap *soap, const char *tag, struct ns__getparamvecResponse *a, const char *type)
{
	short soap_flag_dval = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct ns__getparamvecResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__getparamvecResponse, sizeof(struct ns__getparamvecResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns__getparamvecResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_dval && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToPointerTofdata(soap, "dval", &a->dval, "xsd:double"))
				{	soap_flag_dval--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns__getparamvecResponse *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_ns__getparamvecResponse, 0, sizeof(struct ns__getparamvecResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns__getparamvecResponse * SOAP_FMAC6 soap_new_ns__getparamvecResponse(struct soap *soap, int n)
{	return soap_instantiate_ns__getparamvecResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns__getparamvecResponse(struct soap *soap, struct ns__getparamvecResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns__getparamvecResponse * SOAP_FMAC4 soap_instantiate_ns__getparamvecResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__getparamvecResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns__getparamvecResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns__getparamvecResponse;
		if (size)
			*size = sizeof(struct ns__getparamvecResponse);
	}
	else
	{	cp->ptr = (void*)new struct ns__getparamvecResponse[n];
		if (size)
			*size = n * sizeof(struct ns__getparamvecResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns__getparamvecResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns__getparamvecResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns__getparamvecResponse %p -> %p\n", q, p));
	*(struct ns__getparamvecResponse*)p = *(struct ns__getparamvecResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__getparamint(struct soap *soap, const struct ns__getparamint *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->id, SOAP_TYPE_int);
	soap_serialize_string(soap, &a->name);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__getparamint(struct soap *soap, struct ns__getparamint *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->id);
	soap_default_string(soap, &a->name);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__getparamint(struct soap *soap, const struct ns__getparamint *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns__getparamint);
	if (soap_out_ns__getparamint(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__getparamint(struct soap *soap, const char *tag, int id, const struct ns__getparamint *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__getparamint), type);
	soap_out_int(soap, "id", -1, &a->id, "");
	soap_out_string(soap, "name", -1, &a->name, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct ns__getparamint * SOAP_FMAC4 soap_get_ns__getparamint(struct soap *soap, struct ns__getparamint *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__getparamint(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct ns__getparamint * SOAP_FMAC4 soap_in_ns__getparamint(struct soap *soap, const char *tag, struct ns__getparamint *a, const char *type)
{
	short soap_flag_id = 1, soap_flag_name = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct ns__getparamint *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__getparamint, sizeof(struct ns__getparamint), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns__getparamint(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_id && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "id", &a->id, "xsd:int"))
				{	soap_flag_id--;
					continue;
				}
			if (soap_flag_name && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "name", &a->name, "xsd:string"))
				{	soap_flag_name--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_id > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns__getparamint *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_ns__getparamint, 0, sizeof(struct ns__getparamint), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns__getparamint * SOAP_FMAC6 soap_new_ns__getparamint(struct soap *soap, int n)
{	return soap_instantiate_ns__getparamint(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns__getparamint(struct soap *soap, struct ns__getparamint *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns__getparamint * SOAP_FMAC4 soap_instantiate_ns__getparamint(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__getparamint(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns__getparamint, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns__getparamint;
		if (size)
			*size = sizeof(struct ns__getparamint);
	}
	else
	{	cp->ptr = (void*)new struct ns__getparamint[n];
		if (size)
			*size = n * sizeof(struct ns__getparamint);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns__getparamint*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns__getparamint(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns__getparamint %p -> %p\n", q, p));
	*(struct ns__getparamint*)p = *(struct ns__getparamint*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__getparamintResponse(struct soap *soap, const struct ns__getparamintResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToint(soap, &a->value);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__getparamintResponse(struct soap *soap, struct ns__getparamintResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->value = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__getparamintResponse(struct soap *soap, const struct ns__getparamintResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns__getparamintResponse);
	if (soap_out_ns__getparamintResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__getparamintResponse(struct soap *soap, const char *tag, int id, const struct ns__getparamintResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__getparamintResponse), type);
	if (a->value)
		soap_element_result(soap, "value");
	soap_out_PointerToint(soap, "value", -1, &a->value, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct ns__getparamintResponse * SOAP_FMAC4 soap_get_ns__getparamintResponse(struct soap *soap, struct ns__getparamintResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__getparamintResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct ns__getparamintResponse * SOAP_FMAC4 soap_in_ns__getparamintResponse(struct soap *soap, const char *tag, struct ns__getparamintResponse *a, const char *type)
{
	short soap_flag_value = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct ns__getparamintResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__getparamintResponse, sizeof(struct ns__getparamintResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns__getparamintResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_value && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "value", &a->value, "xsd:int"))
				{	soap_flag_value--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns__getparamintResponse *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_ns__getparamintResponse, 0, sizeof(struct ns__getparamintResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns__getparamintResponse * SOAP_FMAC6 soap_new_ns__getparamintResponse(struct soap *soap, int n)
{	return soap_instantiate_ns__getparamintResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns__getparamintResponse(struct soap *soap, struct ns__getparamintResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns__getparamintResponse * SOAP_FMAC4 soap_instantiate_ns__getparamintResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__getparamintResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns__getparamintResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns__getparamintResponse;
		if (size)
			*size = sizeof(struct ns__getparamintResponse);
	}
	else
	{	cp->ptr = (void*)new struct ns__getparamintResponse[n];
		if (size)
			*size = n * sizeof(struct ns__getparamintResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns__getparamintResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns__getparamintResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns__getparamintResponse %p -> %p\n", q, p));
	*(struct ns__getparamintResponse*)p = *(struct ns__getparamintResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__getparamdouble(struct soap *soap, const struct ns__getparamdouble *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->id, SOAP_TYPE_int);
	soap_serialize_string(soap, &a->name);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__getparamdouble(struct soap *soap, struct ns__getparamdouble *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->id);
	soap_default_string(soap, &a->name);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__getparamdouble(struct soap *soap, const struct ns__getparamdouble *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns__getparamdouble);
	if (soap_out_ns__getparamdouble(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__getparamdouble(struct soap *soap, const char *tag, int id, const struct ns__getparamdouble *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__getparamdouble), type);
	soap_out_int(soap, "id", -1, &a->id, "");
	soap_out_string(soap, "name", -1, &a->name, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct ns__getparamdouble * SOAP_FMAC4 soap_get_ns__getparamdouble(struct soap *soap, struct ns__getparamdouble *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__getparamdouble(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct ns__getparamdouble * SOAP_FMAC4 soap_in_ns__getparamdouble(struct soap *soap, const char *tag, struct ns__getparamdouble *a, const char *type)
{
	short soap_flag_id = 1, soap_flag_name = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct ns__getparamdouble *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__getparamdouble, sizeof(struct ns__getparamdouble), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns__getparamdouble(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_id && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "id", &a->id, "xsd:int"))
				{	soap_flag_id--;
					continue;
				}
			if (soap_flag_name && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "name", &a->name, "xsd:string"))
				{	soap_flag_name--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_id > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns__getparamdouble *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_ns__getparamdouble, 0, sizeof(struct ns__getparamdouble), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns__getparamdouble * SOAP_FMAC6 soap_new_ns__getparamdouble(struct soap *soap, int n)
{	return soap_instantiate_ns__getparamdouble(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns__getparamdouble(struct soap *soap, struct ns__getparamdouble *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns__getparamdouble * SOAP_FMAC4 soap_instantiate_ns__getparamdouble(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__getparamdouble(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns__getparamdouble, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns__getparamdouble;
		if (size)
			*size = sizeof(struct ns__getparamdouble);
	}
	else
	{	cp->ptr = (void*)new struct ns__getparamdouble[n];
		if (size)
			*size = n * sizeof(struct ns__getparamdouble);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns__getparamdouble*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns__getparamdouble(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns__getparamdouble %p -> %p\n", q, p));
	*(struct ns__getparamdouble*)p = *(struct ns__getparamdouble*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__getparamdoubleResponse(struct soap *soap, const struct ns__getparamdoubleResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTodouble(soap, &a->value);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__getparamdoubleResponse(struct soap *soap, struct ns__getparamdoubleResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->value = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__getparamdoubleResponse(struct soap *soap, const struct ns__getparamdoubleResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns__getparamdoubleResponse);
	if (soap_out_ns__getparamdoubleResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__getparamdoubleResponse(struct soap *soap, const char *tag, int id, const struct ns__getparamdoubleResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__getparamdoubleResponse), type);
	if (a->value)
		soap_element_result(soap, "value");
	soap_out_PointerTodouble(soap, "value", -1, &a->value, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct ns__getparamdoubleResponse * SOAP_FMAC4 soap_get_ns__getparamdoubleResponse(struct soap *soap, struct ns__getparamdoubleResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__getparamdoubleResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct ns__getparamdoubleResponse * SOAP_FMAC4 soap_in_ns__getparamdoubleResponse(struct soap *soap, const char *tag, struct ns__getparamdoubleResponse *a, const char *type)
{
	short soap_flag_value = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct ns__getparamdoubleResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__getparamdoubleResponse, sizeof(struct ns__getparamdoubleResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns__getparamdoubleResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_value && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTodouble(soap, "value", &a->value, "xsd:double"))
				{	soap_flag_value--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns__getparamdoubleResponse *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_ns__getparamdoubleResponse, 0, sizeof(struct ns__getparamdoubleResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns__getparamdoubleResponse * SOAP_FMAC6 soap_new_ns__getparamdoubleResponse(struct soap *soap, int n)
{	return soap_instantiate_ns__getparamdoubleResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns__getparamdoubleResponse(struct soap *soap, struct ns__getparamdoubleResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns__getparamdoubleResponse * SOAP_FMAC4 soap_instantiate_ns__getparamdoubleResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__getparamdoubleResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns__getparamdoubleResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns__getparamdoubleResponse;
		if (size)
			*size = sizeof(struct ns__getparamdoubleResponse);
	}
	else
	{	cp->ptr = (void*)new struct ns__getparamdoubleResponse[n];
		if (size)
			*size = n * sizeof(struct ns__getparamdoubleResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns__getparamdoubleResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns__getparamdoubleResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns__getparamdoubleResponse %p -> %p\n", q, p));
	*(struct ns__getparamdoubleResponse*)p = *(struct ns__getparamdoubleResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__addmetadata(struct soap *soap, const struct ns__addmetadata *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->id, SOAP_TYPE_int);
	soap_serialize_string(soap, &a->name);
	soap_serialize_string(soap, &a->property);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__addmetadata(struct soap *soap, struct ns__addmetadata *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->id);
	soap_default_string(soap, &a->name);
	soap_default_string(soap, &a->property);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__addmetadata(struct soap *soap, const struct ns__addmetadata *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns__addmetadata);
	if (soap_out_ns__addmetadata(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__addmetadata(struct soap *soap, const char *tag, int id, const struct ns__addmetadata *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__addmetadata), type);
	soap_out_int(soap, "id", -1, &a->id, "");
	soap_out_string(soap, "name", -1, &a->name, "");
	soap_out_string(soap, "property", -1, &a->property, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct ns__addmetadata * SOAP_FMAC4 soap_get_ns__addmetadata(struct soap *soap, struct ns__addmetadata *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__addmetadata(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct ns__addmetadata * SOAP_FMAC4 soap_in_ns__addmetadata(struct soap *soap, const char *tag, struct ns__addmetadata *a, const char *type)
{
	short soap_flag_id = 1, soap_flag_name = 1, soap_flag_property = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct ns__addmetadata *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__addmetadata, sizeof(struct ns__addmetadata), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns__addmetadata(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_id && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "id", &a->id, "xsd:int"))
				{	soap_flag_id--;
					continue;
				}
			if (soap_flag_name && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "name", &a->name, "xsd:string"))
				{	soap_flag_name--;
					continue;
				}
			if (soap_flag_property && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "property", &a->property, "xsd:string"))
				{	soap_flag_property--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_id > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns__addmetadata *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_ns__addmetadata, 0, sizeof(struct ns__addmetadata), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns__addmetadata * SOAP_FMAC6 soap_new_ns__addmetadata(struct soap *soap, int n)
{	return soap_instantiate_ns__addmetadata(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns__addmetadata(struct soap *soap, struct ns__addmetadata *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns__addmetadata * SOAP_FMAC4 soap_instantiate_ns__addmetadata(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__addmetadata(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns__addmetadata, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns__addmetadata;
		if (size)
			*size = sizeof(struct ns__addmetadata);
	}
	else
	{	cp->ptr = (void*)new struct ns__addmetadata[n];
		if (size)
			*size = n * sizeof(struct ns__addmetadata);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns__addmetadata*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns__addmetadata(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns__addmetadata %p -> %p\n", q, p));
	*(struct ns__addmetadata*)p = *(struct ns__addmetadata*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__addmetadataResponse(struct soap *soap, const struct ns__addmetadataResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToint(soap, &a->status);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__addmetadataResponse(struct soap *soap, struct ns__addmetadataResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->status = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__addmetadataResponse(struct soap *soap, const struct ns__addmetadataResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns__addmetadataResponse);
	if (soap_out_ns__addmetadataResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__addmetadataResponse(struct soap *soap, const char *tag, int id, const struct ns__addmetadataResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__addmetadataResponse), type);
	if (a->status)
		soap_element_result(soap, "status");
	soap_out_PointerToint(soap, "status", -1, &a->status, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct ns__addmetadataResponse * SOAP_FMAC4 soap_get_ns__addmetadataResponse(struct soap *soap, struct ns__addmetadataResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__addmetadataResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct ns__addmetadataResponse * SOAP_FMAC4 soap_in_ns__addmetadataResponse(struct soap *soap, const char *tag, struct ns__addmetadataResponse *a, const char *type)
{
	short soap_flag_status = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct ns__addmetadataResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__addmetadataResponse, sizeof(struct ns__addmetadataResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns__addmetadataResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_status && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "status", &a->status, "xsd:int"))
				{	soap_flag_status--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns__addmetadataResponse *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_ns__addmetadataResponse, 0, sizeof(struct ns__addmetadataResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns__addmetadataResponse * SOAP_FMAC6 soap_new_ns__addmetadataResponse(struct soap *soap, int n)
{	return soap_instantiate_ns__addmetadataResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns__addmetadataResponse(struct soap *soap, struct ns__addmetadataResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns__addmetadataResponse * SOAP_FMAC4 soap_instantiate_ns__addmetadataResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__addmetadataResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns__addmetadataResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns__addmetadataResponse;
		if (size)
			*size = sizeof(struct ns__addmetadataResponse);
	}
	else
	{	cp->ptr = (void*)new struct ns__addmetadataResponse[n];
		if (size)
			*size = n * sizeof(struct ns__addmetadataResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns__addmetadataResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns__addmetadataResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns__addmetadataResponse %p -> %p\n", q, p));
	*(struct ns__addmetadataResponse*)p = *(struct ns__addmetadataResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__addparammmat3d(struct soap *soap, const struct ns__addparammmat3d *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->id, SOAP_TYPE_int);
	soap_serialize_string(soap, &a->name);
	soap_embedded(soap, &a->value, SOAP_TYPE_fdata);
	soap_serialize_fdata(soap, &a->value);
	soap_embedded(soap, &a->n, SOAP_TYPE_int);
	soap_embedded(soap, &a->p, SOAP_TYPE_int);
	soap_embedded(soap, &a->q, SOAP_TYPE_int);
	soap_embedded(soap, &a->nr, SOAP_TYPE_int);
	soap_embedded(soap, &a->nc, SOAP_TYPE_int);
	soap_embedded(soap, &a->iflag, SOAP_TYPE_int);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__addparammmat3d(struct soap *soap, struct ns__addparammmat3d *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->id);
	soap_default_string(soap, &a->name);
	soap_default_fdata(soap, &a->value);
	soap_default_int(soap, &a->n);
	soap_default_int(soap, &a->p);
	soap_default_int(soap, &a->q);
	soap_default_int(soap, &a->nr);
	soap_default_int(soap, &a->nc);
	soap_default_int(soap, &a->iflag);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__addparammmat3d(struct soap *soap, const struct ns__addparammmat3d *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns__addparammmat3d);
	if (soap_out_ns__addparammmat3d(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__addparammmat3d(struct soap *soap, const char *tag, int id, const struct ns__addparammmat3d *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__addparammmat3d), type);
	soap_out_int(soap, "id", -1, &a->id, "");
	soap_out_string(soap, "name", -1, &a->name, "");
	soap_out_fdata(soap, "value", -1, &a->value, "");
	soap_out_int(soap, "n", -1, &a->n, "");
	soap_out_int(soap, "p", -1, &a->p, "");
	soap_out_int(soap, "q", -1, &a->q, "");
	soap_out_int(soap, "nr", -1, &a->nr, "");
	soap_out_int(soap, "nc", -1, &a->nc, "");
	soap_out_int(soap, "iflag", -1, &a->iflag, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct ns__addparammmat3d * SOAP_FMAC4 soap_get_ns__addparammmat3d(struct soap *soap, struct ns__addparammmat3d *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__addparammmat3d(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct ns__addparammmat3d * SOAP_FMAC4 soap_in_ns__addparammmat3d(struct soap *soap, const char *tag, struct ns__addparammmat3d *a, const char *type)
{
	short soap_flag_id = 1, soap_flag_name = 1, soap_flag_value = 1, soap_flag_n = 1, soap_flag_p = 1, soap_flag_q = 1, soap_flag_nr = 1, soap_flag_nc = 1, soap_flag_iflag = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct ns__addparammmat3d *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__addparammmat3d, sizeof(struct ns__addparammmat3d), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns__addparammmat3d(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_id && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "id", &a->id, "xsd:int"))
				{	soap_flag_id--;
					continue;
				}
			if (soap_flag_name && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "name", &a->name, "xsd:string"))
				{	soap_flag_name--;
					continue;
				}
			if (soap_flag_value && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_fdata(soap, "value", &a->value, "xsd:double"))
				{	soap_flag_value--;
					continue;
				}
			if (soap_flag_n && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "n", &a->n, "xsd:int"))
				{	soap_flag_n--;
					continue;
				}
			if (soap_flag_p && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "p", &a->p, "xsd:int"))
				{	soap_flag_p--;
					continue;
				}
			if (soap_flag_q && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "q", &a->q, "xsd:int"))
				{	soap_flag_q--;
					continue;
				}
			if (soap_flag_nr && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "nr", &a->nr, "xsd:int"))
				{	soap_flag_nr--;
					continue;
				}
			if (soap_flag_nc && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "nc", &a->nc, "xsd:int"))
				{	soap_flag_nc--;
					continue;
				}
			if (soap_flag_iflag && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "iflag", &a->iflag, "xsd:int"))
				{	soap_flag_iflag--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_id > 0 || soap_flag_value > 0 || soap_flag_n > 0 || soap_flag_p > 0 || soap_flag_q > 0 || soap_flag_nr > 0 || soap_flag_nc > 0 || soap_flag_iflag > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns__addparammmat3d *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_ns__addparammmat3d, 0, sizeof(struct ns__addparammmat3d), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns__addparammmat3d * SOAP_FMAC6 soap_new_ns__addparammmat3d(struct soap *soap, int n)
{	return soap_instantiate_ns__addparammmat3d(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns__addparammmat3d(struct soap *soap, struct ns__addparammmat3d *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns__addparammmat3d * SOAP_FMAC4 soap_instantiate_ns__addparammmat3d(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__addparammmat3d(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns__addparammmat3d, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns__addparammmat3d;
		if (size)
			*size = sizeof(struct ns__addparammmat3d);
	}
	else
	{	cp->ptr = (void*)new struct ns__addparammmat3d[n];
		if (size)
			*size = n * sizeof(struct ns__addparammmat3d);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns__addparammmat3d*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns__addparammmat3d(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns__addparammmat3d %p -> %p\n", q, p));
	*(struct ns__addparammmat3d*)p = *(struct ns__addparammmat3d*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__addparammmat3dResponse(struct soap *soap, const struct ns__addparammmat3dResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToint(soap, &a->status);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__addparammmat3dResponse(struct soap *soap, struct ns__addparammmat3dResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->status = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__addparammmat3dResponse(struct soap *soap, const struct ns__addparammmat3dResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns__addparammmat3dResponse);
	if (soap_out_ns__addparammmat3dResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__addparammmat3dResponse(struct soap *soap, const char *tag, int id, const struct ns__addparammmat3dResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__addparammmat3dResponse), type);
	if (a->status)
		soap_element_result(soap, "status");
	soap_out_PointerToint(soap, "status", -1, &a->status, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct ns__addparammmat3dResponse * SOAP_FMAC4 soap_get_ns__addparammmat3dResponse(struct soap *soap, struct ns__addparammmat3dResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__addparammmat3dResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct ns__addparammmat3dResponse * SOAP_FMAC4 soap_in_ns__addparammmat3dResponse(struct soap *soap, const char *tag, struct ns__addparammmat3dResponse *a, const char *type)
{
	short soap_flag_status = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct ns__addparammmat3dResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__addparammmat3dResponse, sizeof(struct ns__addparammmat3dResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns__addparammmat3dResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_status && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "status", &a->status, "xsd:int"))
				{	soap_flag_status--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns__addparammmat3dResponse *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_ns__addparammmat3dResponse, 0, sizeof(struct ns__addparammmat3dResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns__addparammmat3dResponse * SOAP_FMAC6 soap_new_ns__addparammmat3dResponse(struct soap *soap, int n)
{	return soap_instantiate_ns__addparammmat3dResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns__addparammmat3dResponse(struct soap *soap, struct ns__addparammmat3dResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns__addparammmat3dResponse * SOAP_FMAC4 soap_instantiate_ns__addparammmat3dResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__addparammmat3dResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns__addparammmat3dResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns__addparammmat3dResponse;
		if (size)
			*size = sizeof(struct ns__addparammmat3dResponse);
	}
	else
	{	cp->ptr = (void*)new struct ns__addparammmat3dResponse[n];
		if (size)
			*size = n * sizeof(struct ns__addparammmat3dResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns__addparammmat3dResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns__addparammmat3dResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns__addparammmat3dResponse %p -> %p\n", q, p));
	*(struct ns__addparammmat3dResponse*)p = *(struct ns__addparammmat3dResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__addparamstring(struct soap *soap, const struct ns__addparamstring *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->id, SOAP_TYPE_int);
	soap_serialize_string(soap, &a->name);
	soap_serialize_string(soap, &a->value);
	soap_embedded(soap, &a->iflag, SOAP_TYPE_int);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__addparamstring(struct soap *soap, struct ns__addparamstring *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->id);
	soap_default_string(soap, &a->name);
	soap_default_string(soap, &a->value);
	soap_default_int(soap, &a->iflag);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__addparamstring(struct soap *soap, const struct ns__addparamstring *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns__addparamstring);
	if (soap_out_ns__addparamstring(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__addparamstring(struct soap *soap, const char *tag, int id, const struct ns__addparamstring *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__addparamstring), type);
	soap_out_int(soap, "id", -1, &a->id, "");
	soap_out_string(soap, "name", -1, &a->name, "");
	soap_out_string(soap, "value", -1, &a->value, "");
	soap_out_int(soap, "iflag", -1, &a->iflag, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct ns__addparamstring * SOAP_FMAC4 soap_get_ns__addparamstring(struct soap *soap, struct ns__addparamstring *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__addparamstring(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct ns__addparamstring * SOAP_FMAC4 soap_in_ns__addparamstring(struct soap *soap, const char *tag, struct ns__addparamstring *a, const char *type)
{
	short soap_flag_id = 1, soap_flag_name = 1, soap_flag_value = 1, soap_flag_iflag = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct ns__addparamstring *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__addparamstring, sizeof(struct ns__addparamstring), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns__addparamstring(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_id && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "id", &a->id, "xsd:int"))
				{	soap_flag_id--;
					continue;
				}
			if (soap_flag_name && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "name", &a->name, "xsd:string"))
				{	soap_flag_name--;
					continue;
				}
			if (soap_flag_value && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "value", &a->value, "xsd:string"))
				{	soap_flag_value--;
					continue;
				}
			if (soap_flag_iflag && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "iflag", &a->iflag, "xsd:int"))
				{	soap_flag_iflag--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_id > 0 || soap_flag_iflag > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns__addparamstring *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_ns__addparamstring, 0, sizeof(struct ns__addparamstring), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns__addparamstring * SOAP_FMAC6 soap_new_ns__addparamstring(struct soap *soap, int n)
{	return soap_instantiate_ns__addparamstring(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns__addparamstring(struct soap *soap, struct ns__addparamstring *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns__addparamstring * SOAP_FMAC4 soap_instantiate_ns__addparamstring(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__addparamstring(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns__addparamstring, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns__addparamstring;
		if (size)
			*size = sizeof(struct ns__addparamstring);
	}
	else
	{	cp->ptr = (void*)new struct ns__addparamstring[n];
		if (size)
			*size = n * sizeof(struct ns__addparamstring);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns__addparamstring*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns__addparamstring(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns__addparamstring %p -> %p\n", q, p));
	*(struct ns__addparamstring*)p = *(struct ns__addparamstring*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__addparamstringResponse(struct soap *soap, const struct ns__addparamstringResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToint(soap, &a->status);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__addparamstringResponse(struct soap *soap, struct ns__addparamstringResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->status = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__addparamstringResponse(struct soap *soap, const struct ns__addparamstringResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns__addparamstringResponse);
	if (soap_out_ns__addparamstringResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__addparamstringResponse(struct soap *soap, const char *tag, int id, const struct ns__addparamstringResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__addparamstringResponse), type);
	if (a->status)
		soap_element_result(soap, "status");
	soap_out_PointerToint(soap, "status", -1, &a->status, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct ns__addparamstringResponse * SOAP_FMAC4 soap_get_ns__addparamstringResponse(struct soap *soap, struct ns__addparamstringResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__addparamstringResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct ns__addparamstringResponse * SOAP_FMAC4 soap_in_ns__addparamstringResponse(struct soap *soap, const char *tag, struct ns__addparamstringResponse *a, const char *type)
{
	short soap_flag_status = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct ns__addparamstringResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__addparamstringResponse, sizeof(struct ns__addparamstringResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns__addparamstringResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_status && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "status", &a->status, "xsd:int"))
				{	soap_flag_status--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns__addparamstringResponse *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_ns__addparamstringResponse, 0, sizeof(struct ns__addparamstringResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns__addparamstringResponse * SOAP_FMAC6 soap_new_ns__addparamstringResponse(struct soap *soap, int n)
{	return soap_instantiate_ns__addparamstringResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns__addparamstringResponse(struct soap *soap, struct ns__addparamstringResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns__addparamstringResponse * SOAP_FMAC4 soap_instantiate_ns__addparamstringResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__addparamstringResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns__addparamstringResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns__addparamstringResponse;
		if (size)
			*size = sizeof(struct ns__addparamstringResponse);
	}
	else
	{	cp->ptr = (void*)new struct ns__addparamstringResponse[n];
		if (size)
			*size = n * sizeof(struct ns__addparamstringResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns__addparamstringResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns__addparamstringResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns__addparamstringResponse %p -> %p\n", q, p));
	*(struct ns__addparamstringResponse*)p = *(struct ns__addparamstringResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__addparammat(struct soap *soap, const struct ns__addparammat *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->id, SOAP_TYPE_int);
	soap_serialize_string(soap, &a->name);
	soap_embedded(soap, &a->value, SOAP_TYPE_fdata);
	soap_serialize_fdata(soap, &a->value);
	soap_embedded(soap, &a->nr, SOAP_TYPE_int);
	soap_embedded(soap, &a->nc, SOAP_TYPE_int);
	soap_embedded(soap, &a->iflag, SOAP_TYPE_int);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__addparammat(struct soap *soap, struct ns__addparammat *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->id);
	soap_default_string(soap, &a->name);
	soap_default_fdata(soap, &a->value);
	soap_default_int(soap, &a->nr);
	soap_default_int(soap, &a->nc);
	soap_default_int(soap, &a->iflag);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__addparammat(struct soap *soap, const struct ns__addparammat *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns__addparammat);
	if (soap_out_ns__addparammat(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__addparammat(struct soap *soap, const char *tag, int id, const struct ns__addparammat *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__addparammat), type);
	soap_out_int(soap, "id", -1, &a->id, "");
	soap_out_string(soap, "name", -1, &a->name, "");
	soap_out_fdata(soap, "value", -1, &a->value, "");
	soap_out_int(soap, "nr", -1, &a->nr, "");
	soap_out_int(soap, "nc", -1, &a->nc, "");
	soap_out_int(soap, "iflag", -1, &a->iflag, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct ns__addparammat * SOAP_FMAC4 soap_get_ns__addparammat(struct soap *soap, struct ns__addparammat *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__addparammat(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct ns__addparammat * SOAP_FMAC4 soap_in_ns__addparammat(struct soap *soap, const char *tag, struct ns__addparammat *a, const char *type)
{
	short soap_flag_id = 1, soap_flag_name = 1, soap_flag_value = 1, soap_flag_nr = 1, soap_flag_nc = 1, soap_flag_iflag = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct ns__addparammat *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__addparammat, sizeof(struct ns__addparammat), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns__addparammat(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_id && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "id", &a->id, "xsd:int"))
				{	soap_flag_id--;
					continue;
				}
			if (soap_flag_name && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "name", &a->name, "xsd:string"))
				{	soap_flag_name--;
					continue;
				}
			if (soap_flag_value && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_fdata(soap, "value", &a->value, "xsd:double"))
				{	soap_flag_value--;
					continue;
				}
			if (soap_flag_nr && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "nr", &a->nr, "xsd:int"))
				{	soap_flag_nr--;
					continue;
				}
			if (soap_flag_nc && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "nc", &a->nc, "xsd:int"))
				{	soap_flag_nc--;
					continue;
				}
			if (soap_flag_iflag && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "iflag", &a->iflag, "xsd:int"))
				{	soap_flag_iflag--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_id > 0 || soap_flag_value > 0 || soap_flag_nr > 0 || soap_flag_nc > 0 || soap_flag_iflag > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns__addparammat *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_ns__addparammat, 0, sizeof(struct ns__addparammat), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns__addparammat * SOAP_FMAC6 soap_new_ns__addparammat(struct soap *soap, int n)
{	return soap_instantiate_ns__addparammat(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns__addparammat(struct soap *soap, struct ns__addparammat *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns__addparammat * SOAP_FMAC4 soap_instantiate_ns__addparammat(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__addparammat(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns__addparammat, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns__addparammat;
		if (size)
			*size = sizeof(struct ns__addparammat);
	}
	else
	{	cp->ptr = (void*)new struct ns__addparammat[n];
		if (size)
			*size = n * sizeof(struct ns__addparammat);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns__addparammat*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns__addparammat(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns__addparammat %p -> %p\n", q, p));
	*(struct ns__addparammat*)p = *(struct ns__addparammat*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__addparammatResponse(struct soap *soap, const struct ns__addparammatResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToint(soap, &a->status);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__addparammatResponse(struct soap *soap, struct ns__addparammatResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->status = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__addparammatResponse(struct soap *soap, const struct ns__addparammatResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns__addparammatResponse);
	if (soap_out_ns__addparammatResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__addparammatResponse(struct soap *soap, const char *tag, int id, const struct ns__addparammatResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__addparammatResponse), type);
	if (a->status)
		soap_element_result(soap, "status");
	soap_out_PointerToint(soap, "status", -1, &a->status, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct ns__addparammatResponse * SOAP_FMAC4 soap_get_ns__addparammatResponse(struct soap *soap, struct ns__addparammatResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__addparammatResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct ns__addparammatResponse * SOAP_FMAC4 soap_in_ns__addparammatResponse(struct soap *soap, const char *tag, struct ns__addparammatResponse *a, const char *type)
{
	short soap_flag_status = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct ns__addparammatResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__addparammatResponse, sizeof(struct ns__addparammatResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns__addparammatResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_status && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "status", &a->status, "xsd:int"))
				{	soap_flag_status--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns__addparammatResponse *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_ns__addparammatResponse, 0, sizeof(struct ns__addparammatResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns__addparammatResponse * SOAP_FMAC6 soap_new_ns__addparammatResponse(struct soap *soap, int n)
{	return soap_instantiate_ns__addparammatResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns__addparammatResponse(struct soap *soap, struct ns__addparammatResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns__addparammatResponse * SOAP_FMAC4 soap_instantiate_ns__addparammatResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__addparammatResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns__addparammatResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns__addparammatResponse;
		if (size)
			*size = sizeof(struct ns__addparammatResponse);
	}
	else
	{	cp->ptr = (void*)new struct ns__addparammatResponse[n];
		if (size)
			*size = n * sizeof(struct ns__addparammatResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns__addparammatResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns__addparammatResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns__addparammatResponse %p -> %p\n", q, p));
	*(struct ns__addparammatResponse*)p = *(struct ns__addparammatResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__addparamvec(struct soap *soap, const struct ns__addparamvec *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->id, SOAP_TYPE_int);
	soap_serialize_string(soap, &a->name);
	soap_embedded(soap, &a->value, SOAP_TYPE_fdata);
	soap_serialize_fdata(soap, &a->value);
	soap_embedded(soap, &a->n, SOAP_TYPE_int);
	soap_embedded(soap, &a->iflag, SOAP_TYPE_int);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__addparamvec(struct soap *soap, struct ns__addparamvec *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->id);
	soap_default_string(soap, &a->name);
	soap_default_fdata(soap, &a->value);
	soap_default_int(soap, &a->n);
	soap_default_int(soap, &a->iflag);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__addparamvec(struct soap *soap, const struct ns__addparamvec *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns__addparamvec);
	if (soap_out_ns__addparamvec(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__addparamvec(struct soap *soap, const char *tag, int id, const struct ns__addparamvec *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__addparamvec), type);
	soap_out_int(soap, "id", -1, &a->id, "");
	soap_out_string(soap, "name", -1, &a->name, "");
	soap_out_fdata(soap, "value", -1, &a->value, "");
	soap_out_int(soap, "n", -1, &a->n, "");
	soap_out_int(soap, "iflag", -1, &a->iflag, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct ns__addparamvec * SOAP_FMAC4 soap_get_ns__addparamvec(struct soap *soap, struct ns__addparamvec *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__addparamvec(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct ns__addparamvec * SOAP_FMAC4 soap_in_ns__addparamvec(struct soap *soap, const char *tag, struct ns__addparamvec *a, const char *type)
{
	short soap_flag_id = 1, soap_flag_name = 1, soap_flag_value = 1, soap_flag_n = 1, soap_flag_iflag = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct ns__addparamvec *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__addparamvec, sizeof(struct ns__addparamvec), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns__addparamvec(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_id && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "id", &a->id, "xsd:int"))
				{	soap_flag_id--;
					continue;
				}
			if (soap_flag_name && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "name", &a->name, "xsd:string"))
				{	soap_flag_name--;
					continue;
				}
			if (soap_flag_value && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_fdata(soap, "value", &a->value, "xsd:double"))
				{	soap_flag_value--;
					continue;
				}
			if (soap_flag_n && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "n", &a->n, "xsd:int"))
				{	soap_flag_n--;
					continue;
				}
			if (soap_flag_iflag && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "iflag", &a->iflag, "xsd:int"))
				{	soap_flag_iflag--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_id > 0 || soap_flag_value > 0 || soap_flag_n > 0 || soap_flag_iflag > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns__addparamvec *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_ns__addparamvec, 0, sizeof(struct ns__addparamvec), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns__addparamvec * SOAP_FMAC6 soap_new_ns__addparamvec(struct soap *soap, int n)
{	return soap_instantiate_ns__addparamvec(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns__addparamvec(struct soap *soap, struct ns__addparamvec *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns__addparamvec * SOAP_FMAC4 soap_instantiate_ns__addparamvec(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__addparamvec(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns__addparamvec, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns__addparamvec;
		if (size)
			*size = sizeof(struct ns__addparamvec);
	}
	else
	{	cp->ptr = (void*)new struct ns__addparamvec[n];
		if (size)
			*size = n * sizeof(struct ns__addparamvec);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns__addparamvec*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns__addparamvec(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns__addparamvec %p -> %p\n", q, p));
	*(struct ns__addparamvec*)p = *(struct ns__addparamvec*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__addparamvecResponse(struct soap *soap, const struct ns__addparamvecResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToint(soap, &a->status);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__addparamvecResponse(struct soap *soap, struct ns__addparamvecResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->status = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__addparamvecResponse(struct soap *soap, const struct ns__addparamvecResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns__addparamvecResponse);
	if (soap_out_ns__addparamvecResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__addparamvecResponse(struct soap *soap, const char *tag, int id, const struct ns__addparamvecResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__addparamvecResponse), type);
	if (a->status)
		soap_element_result(soap, "status");
	soap_out_PointerToint(soap, "status", -1, &a->status, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct ns__addparamvecResponse * SOAP_FMAC4 soap_get_ns__addparamvecResponse(struct soap *soap, struct ns__addparamvecResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__addparamvecResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct ns__addparamvecResponse * SOAP_FMAC4 soap_in_ns__addparamvecResponse(struct soap *soap, const char *tag, struct ns__addparamvecResponse *a, const char *type)
{
	short soap_flag_status = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct ns__addparamvecResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__addparamvecResponse, sizeof(struct ns__addparamvecResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns__addparamvecResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_status && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "status", &a->status, "xsd:int"))
				{	soap_flag_status--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns__addparamvecResponse *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_ns__addparamvecResponse, 0, sizeof(struct ns__addparamvecResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns__addparamvecResponse * SOAP_FMAC6 soap_new_ns__addparamvecResponse(struct soap *soap, int n)
{	return soap_instantiate_ns__addparamvecResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns__addparamvecResponse(struct soap *soap, struct ns__addparamvecResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns__addparamvecResponse * SOAP_FMAC4 soap_instantiate_ns__addparamvecResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__addparamvecResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns__addparamvecResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns__addparamvecResponse;
		if (size)
			*size = sizeof(struct ns__addparamvecResponse);
	}
	else
	{	cp->ptr = (void*)new struct ns__addparamvecResponse[n];
		if (size)
			*size = n * sizeof(struct ns__addparamvecResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns__addparamvecResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns__addparamvecResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns__addparamvecResponse %p -> %p\n", q, p));
	*(struct ns__addparamvecResponse*)p = *(struct ns__addparamvecResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__addparamint(struct soap *soap, const struct ns__addparamint *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->id, SOAP_TYPE_int);
	soap_serialize_string(soap, &a->name);
	soap_embedded(soap, &a->value, SOAP_TYPE_int);
	soap_embedded(soap, &a->iflag, SOAP_TYPE_int);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__addparamint(struct soap *soap, struct ns__addparamint *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->id);
	soap_default_string(soap, &a->name);
	soap_default_int(soap, &a->value);
	soap_default_int(soap, &a->iflag);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__addparamint(struct soap *soap, const struct ns__addparamint *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns__addparamint);
	if (soap_out_ns__addparamint(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__addparamint(struct soap *soap, const char *tag, int id, const struct ns__addparamint *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__addparamint), type);
	soap_out_int(soap, "id", -1, &a->id, "");
	soap_out_string(soap, "name", -1, &a->name, "");
	soap_out_int(soap, "value", -1, &a->value, "");
	soap_out_int(soap, "iflag", -1, &a->iflag, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct ns__addparamint * SOAP_FMAC4 soap_get_ns__addparamint(struct soap *soap, struct ns__addparamint *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__addparamint(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct ns__addparamint * SOAP_FMAC4 soap_in_ns__addparamint(struct soap *soap, const char *tag, struct ns__addparamint *a, const char *type)
{
	short soap_flag_id = 1, soap_flag_name = 1, soap_flag_value = 1, soap_flag_iflag = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct ns__addparamint *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__addparamint, sizeof(struct ns__addparamint), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns__addparamint(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_id && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "id", &a->id, "xsd:int"))
				{	soap_flag_id--;
					continue;
				}
			if (soap_flag_name && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "name", &a->name, "xsd:string"))
				{	soap_flag_name--;
					continue;
				}
			if (soap_flag_value && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "value", &a->value, "xsd:int"))
				{	soap_flag_value--;
					continue;
				}
			if (soap_flag_iflag && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "iflag", &a->iflag, "xsd:int"))
				{	soap_flag_iflag--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_id > 0 || soap_flag_value > 0 || soap_flag_iflag > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns__addparamint *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_ns__addparamint, 0, sizeof(struct ns__addparamint), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns__addparamint * SOAP_FMAC6 soap_new_ns__addparamint(struct soap *soap, int n)
{	return soap_instantiate_ns__addparamint(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns__addparamint(struct soap *soap, struct ns__addparamint *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns__addparamint * SOAP_FMAC4 soap_instantiate_ns__addparamint(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__addparamint(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns__addparamint, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns__addparamint;
		if (size)
			*size = sizeof(struct ns__addparamint);
	}
	else
	{	cp->ptr = (void*)new struct ns__addparamint[n];
		if (size)
			*size = n * sizeof(struct ns__addparamint);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns__addparamint*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns__addparamint(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns__addparamint %p -> %p\n", q, p));
	*(struct ns__addparamint*)p = *(struct ns__addparamint*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__addparamintResponse(struct soap *soap, const struct ns__addparamintResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToint(soap, &a->status);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__addparamintResponse(struct soap *soap, struct ns__addparamintResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->status = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__addparamintResponse(struct soap *soap, const struct ns__addparamintResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns__addparamintResponse);
	if (soap_out_ns__addparamintResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__addparamintResponse(struct soap *soap, const char *tag, int id, const struct ns__addparamintResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__addparamintResponse), type);
	if (a->status)
		soap_element_result(soap, "status");
	soap_out_PointerToint(soap, "status", -1, &a->status, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct ns__addparamintResponse * SOAP_FMAC4 soap_get_ns__addparamintResponse(struct soap *soap, struct ns__addparamintResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__addparamintResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct ns__addparamintResponse * SOAP_FMAC4 soap_in_ns__addparamintResponse(struct soap *soap, const char *tag, struct ns__addparamintResponse *a, const char *type)
{
	short soap_flag_status = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct ns__addparamintResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__addparamintResponse, sizeof(struct ns__addparamintResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns__addparamintResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_status && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "status", &a->status, "xsd:int"))
				{	soap_flag_status--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns__addparamintResponse *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_ns__addparamintResponse, 0, sizeof(struct ns__addparamintResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns__addparamintResponse * SOAP_FMAC6 soap_new_ns__addparamintResponse(struct soap *soap, int n)
{	return soap_instantiate_ns__addparamintResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns__addparamintResponse(struct soap *soap, struct ns__addparamintResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns__addparamintResponse * SOAP_FMAC4 soap_instantiate_ns__addparamintResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__addparamintResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns__addparamintResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns__addparamintResponse;
		if (size)
			*size = sizeof(struct ns__addparamintResponse);
	}
	else
	{	cp->ptr = (void*)new struct ns__addparamintResponse[n];
		if (size)
			*size = n * sizeof(struct ns__addparamintResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns__addparamintResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns__addparamintResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns__addparamintResponse %p -> %p\n", q, p));
	*(struct ns__addparamintResponse*)p = *(struct ns__addparamintResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__addparamdouble(struct soap *soap, const struct ns__addparamdouble *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->id, SOAP_TYPE_int);
	soap_serialize_string(soap, &a->name);
	soap_embedded(soap, &a->value, SOAP_TYPE_double);
	soap_embedded(soap, &a->iflag, SOAP_TYPE_int);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__addparamdouble(struct soap *soap, struct ns__addparamdouble *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->id);
	soap_default_string(soap, &a->name);
	soap_default_double(soap, &a->value);
	soap_default_int(soap, &a->iflag);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__addparamdouble(struct soap *soap, const struct ns__addparamdouble *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns__addparamdouble);
	if (soap_out_ns__addparamdouble(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__addparamdouble(struct soap *soap, const char *tag, int id, const struct ns__addparamdouble *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__addparamdouble), type);
	soap_out_int(soap, "id", -1, &a->id, "");
	soap_out_string(soap, "name", -1, &a->name, "");
	soap_out_double(soap, "value", -1, &a->value, "");
	soap_out_int(soap, "iflag", -1, &a->iflag, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct ns__addparamdouble * SOAP_FMAC4 soap_get_ns__addparamdouble(struct soap *soap, struct ns__addparamdouble *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__addparamdouble(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct ns__addparamdouble * SOAP_FMAC4 soap_in_ns__addparamdouble(struct soap *soap, const char *tag, struct ns__addparamdouble *a, const char *type)
{
	short soap_flag_id = 1, soap_flag_name = 1, soap_flag_value = 1, soap_flag_iflag = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct ns__addparamdouble *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__addparamdouble, sizeof(struct ns__addparamdouble), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns__addparamdouble(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_id && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "id", &a->id, "xsd:int"))
				{	soap_flag_id--;
					continue;
				}
			if (soap_flag_name && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "name", &a->name, "xsd:string"))
				{	soap_flag_name--;
					continue;
				}
			if (soap_flag_value && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "value", &a->value, "xsd:double"))
				{	soap_flag_value--;
					continue;
				}
			if (soap_flag_iflag && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "iflag", &a->iflag, "xsd:int"))
				{	soap_flag_iflag--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_id > 0 || soap_flag_value > 0 || soap_flag_iflag > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns__addparamdouble *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_ns__addparamdouble, 0, sizeof(struct ns__addparamdouble), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns__addparamdouble * SOAP_FMAC6 soap_new_ns__addparamdouble(struct soap *soap, int n)
{	return soap_instantiate_ns__addparamdouble(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns__addparamdouble(struct soap *soap, struct ns__addparamdouble *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns__addparamdouble * SOAP_FMAC4 soap_instantiate_ns__addparamdouble(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__addparamdouble(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns__addparamdouble, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns__addparamdouble;
		if (size)
			*size = sizeof(struct ns__addparamdouble);
	}
	else
	{	cp->ptr = (void*)new struct ns__addparamdouble[n];
		if (size)
			*size = n * sizeof(struct ns__addparamdouble);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns__addparamdouble*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns__addparamdouble(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns__addparamdouble %p -> %p\n", q, p));
	*(struct ns__addparamdouble*)p = *(struct ns__addparamdouble*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__addparamdoubleResponse(struct soap *soap, const struct ns__addparamdoubleResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToint(soap, &a->status);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__addparamdoubleResponse(struct soap *soap, struct ns__addparamdoubleResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->status = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__addparamdoubleResponse(struct soap *soap, const struct ns__addparamdoubleResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns__addparamdoubleResponse);
	if (soap_out_ns__addparamdoubleResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__addparamdoubleResponse(struct soap *soap, const char *tag, int id, const struct ns__addparamdoubleResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__addparamdoubleResponse), type);
	if (a->status)
		soap_element_result(soap, "status");
	soap_out_PointerToint(soap, "status", -1, &a->status, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct ns__addparamdoubleResponse * SOAP_FMAC4 soap_get_ns__addparamdoubleResponse(struct soap *soap, struct ns__addparamdoubleResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__addparamdoubleResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct ns__addparamdoubleResponse * SOAP_FMAC4 soap_in_ns__addparamdoubleResponse(struct soap *soap, const char *tag, struct ns__addparamdoubleResponse *a, const char *type)
{
	short soap_flag_status = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct ns__addparamdoubleResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__addparamdoubleResponse, sizeof(struct ns__addparamdoubleResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns__addparamdoubleResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_status && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "status", &a->status, "xsd:int"))
				{	soap_flag_status--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns__addparamdoubleResponse *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_ns__addparamdoubleResponse, 0, sizeof(struct ns__addparamdoubleResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns__addparamdoubleResponse * SOAP_FMAC6 soap_new_ns__addparamdoubleResponse(struct soap *soap, int n)
{	return soap_instantiate_ns__addparamdoubleResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns__addparamdoubleResponse(struct soap *soap, struct ns__addparamdoubleResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns__addparamdoubleResponse * SOAP_FMAC4 soap_instantiate_ns__addparamdoubleResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__addparamdoubleResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns__addparamdoubleResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns__addparamdoubleResponse;
		if (size)
			*size = sizeof(struct ns__addparamdoubleResponse);
	}
	else
	{	cp->ptr = (void*)new struct ns__addparamdoubleResponse[n];
		if (size)
			*size = n * sizeof(struct ns__addparamdoubleResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns__addparamdoubleResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns__addparamdoubleResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns__addparamdoubleResponse %p -> %p\n", q, p));
	*(struct ns__addparamdoubleResponse*)p = *(struct ns__addparamdoubleResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__exitiome(struct soap *soap, const struct ns__exitiome *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->id, SOAP_TYPE_int);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__exitiome(struct soap *soap, struct ns__exitiome *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->id);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__exitiome(struct soap *soap, const struct ns__exitiome *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns__exitiome);
	if (soap_out_ns__exitiome(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__exitiome(struct soap *soap, const char *tag, int id, const struct ns__exitiome *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__exitiome), type);
	soap_out_int(soap, "id", -1, &a->id, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct ns__exitiome * SOAP_FMAC4 soap_get_ns__exitiome(struct soap *soap, struct ns__exitiome *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__exitiome(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct ns__exitiome * SOAP_FMAC4 soap_in_ns__exitiome(struct soap *soap, const char *tag, struct ns__exitiome *a, const char *type)
{
	short soap_flag_id = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct ns__exitiome *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__exitiome, sizeof(struct ns__exitiome), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns__exitiome(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_id && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "id", &a->id, "xsd:int"))
				{	soap_flag_id--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_id > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns__exitiome *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_ns__exitiome, 0, sizeof(struct ns__exitiome), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns__exitiome * SOAP_FMAC6 soap_new_ns__exitiome(struct soap *soap, int n)
{	return soap_instantiate_ns__exitiome(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns__exitiome(struct soap *soap, struct ns__exitiome *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns__exitiome * SOAP_FMAC4 soap_instantiate_ns__exitiome(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__exitiome(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns__exitiome, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns__exitiome;
		if (size)
			*size = sizeof(struct ns__exitiome);
	}
	else
	{	cp->ptr = (void*)new struct ns__exitiome[n];
		if (size)
			*size = n * sizeof(struct ns__exitiome);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns__exitiome*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns__exitiome(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns__exitiome %p -> %p\n", q, p));
	*(struct ns__exitiome*)p = *(struct ns__exitiome*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__exitiomeResponse(struct soap *soap, const struct ns__exitiomeResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToint(soap, &a->status);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__exitiomeResponse(struct soap *soap, struct ns__exitiomeResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->status = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__exitiomeResponse(struct soap *soap, const struct ns__exitiomeResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns__exitiomeResponse);
	if (soap_out_ns__exitiomeResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__exitiomeResponse(struct soap *soap, const char *tag, int id, const struct ns__exitiomeResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__exitiomeResponse), type);
	if (a->status)
		soap_element_result(soap, "status");
	soap_out_PointerToint(soap, "status", -1, &a->status, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct ns__exitiomeResponse * SOAP_FMAC4 soap_get_ns__exitiomeResponse(struct soap *soap, struct ns__exitiomeResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__exitiomeResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct ns__exitiomeResponse * SOAP_FMAC4 soap_in_ns__exitiomeResponse(struct soap *soap, const char *tag, struct ns__exitiomeResponse *a, const char *type)
{
	short soap_flag_status = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct ns__exitiomeResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__exitiomeResponse, sizeof(struct ns__exitiomeResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns__exitiomeResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_status && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "status", &a->status, "xsd:int"))
				{	soap_flag_status--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns__exitiomeResponse *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_ns__exitiomeResponse, 0, sizeof(struct ns__exitiomeResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns__exitiomeResponse * SOAP_FMAC6 soap_new_ns__exitiomeResponse(struct soap *soap, int n)
{	return soap_instantiate_ns__exitiomeResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns__exitiomeResponse(struct soap *soap, struct ns__exitiomeResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns__exitiomeResponse * SOAP_FMAC4 soap_instantiate_ns__exitiomeResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__exitiomeResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns__exitiomeResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns__exitiomeResponse;
		if (size)
			*size = sizeof(struct ns__exitiomeResponse);
	}
	else
	{	cp->ptr = (void*)new struct ns__exitiomeResponse[n];
		if (size)
			*size = n * sizeof(struct ns__exitiomeResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns__exitiomeResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns__exitiomeResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns__exitiomeResponse %p -> %p\n", q, p));
	*(struct ns__exitiomeResponse*)p = *(struct ns__exitiomeResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__readsimulation(struct soap *soap, const struct ns__readsimulation *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->id, SOAP_TYPE_int);
	soap_serialize_string(soap, &a->filename);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__readsimulation(struct soap *soap, struct ns__readsimulation *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->id);
	soap_default_string(soap, &a->filename);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__readsimulation(struct soap *soap, const struct ns__readsimulation *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns__readsimulation);
	if (soap_out_ns__readsimulation(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__readsimulation(struct soap *soap, const char *tag, int id, const struct ns__readsimulation *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__readsimulation), type);
	soap_out_int(soap, "id", -1, &a->id, "");
	soap_out_string(soap, "filename", -1, &a->filename, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct ns__readsimulation * SOAP_FMAC4 soap_get_ns__readsimulation(struct soap *soap, struct ns__readsimulation *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__readsimulation(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct ns__readsimulation * SOAP_FMAC4 soap_in_ns__readsimulation(struct soap *soap, const char *tag, struct ns__readsimulation *a, const char *type)
{
	short soap_flag_id = 1, soap_flag_filename = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct ns__readsimulation *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__readsimulation, sizeof(struct ns__readsimulation), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns__readsimulation(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_id && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "id", &a->id, "xsd:int"))
				{	soap_flag_id--;
					continue;
				}
			if (soap_flag_filename && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "filename", &a->filename, "xsd:string"))
				{	soap_flag_filename--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_id > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns__readsimulation *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_ns__readsimulation, 0, sizeof(struct ns__readsimulation), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns__readsimulation * SOAP_FMAC6 soap_new_ns__readsimulation(struct soap *soap, int n)
{	return soap_instantiate_ns__readsimulation(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns__readsimulation(struct soap *soap, struct ns__readsimulation *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns__readsimulation * SOAP_FMAC4 soap_instantiate_ns__readsimulation(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__readsimulation(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns__readsimulation, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns__readsimulation;
		if (size)
			*size = sizeof(struct ns__readsimulation);
	}
	else
	{	cp->ptr = (void*)new struct ns__readsimulation[n];
		if (size)
			*size = n * sizeof(struct ns__readsimulation);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns__readsimulation*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns__readsimulation(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns__readsimulation %p -> %p\n", q, p));
	*(struct ns__readsimulation*)p = *(struct ns__readsimulation*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__readsimulationResponse(struct soap *soap, const struct ns__readsimulationResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToint(soap, &a->status);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__readsimulationResponse(struct soap *soap, struct ns__readsimulationResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->status = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__readsimulationResponse(struct soap *soap, const struct ns__readsimulationResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns__readsimulationResponse);
	if (soap_out_ns__readsimulationResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__readsimulationResponse(struct soap *soap, const char *tag, int id, const struct ns__readsimulationResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__readsimulationResponse), type);
	if (a->status)
		soap_element_result(soap, "status");
	soap_out_PointerToint(soap, "status", -1, &a->status, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct ns__readsimulationResponse * SOAP_FMAC4 soap_get_ns__readsimulationResponse(struct soap *soap, struct ns__readsimulationResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__readsimulationResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct ns__readsimulationResponse * SOAP_FMAC4 soap_in_ns__readsimulationResponse(struct soap *soap, const char *tag, struct ns__readsimulationResponse *a, const char *type)
{
	short soap_flag_status = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct ns__readsimulationResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__readsimulationResponse, sizeof(struct ns__readsimulationResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns__readsimulationResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_status && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "status", &a->status, "xsd:int"))
				{	soap_flag_status--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns__readsimulationResponse *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_ns__readsimulationResponse, 0, sizeof(struct ns__readsimulationResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns__readsimulationResponse * SOAP_FMAC6 soap_new_ns__readsimulationResponse(struct soap *soap, int n)
{	return soap_instantiate_ns__readsimulationResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns__readsimulationResponse(struct soap *soap, struct ns__readsimulationResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns__readsimulationResponse * SOAP_FMAC4 soap_instantiate_ns__readsimulationResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__readsimulationResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns__readsimulationResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns__readsimulationResponse;
		if (size)
			*size = sizeof(struct ns__readsimulationResponse);
	}
	else
	{	cp->ptr = (void*)new struct ns__readsimulationResponse[n];
		if (size)
			*size = n * sizeof(struct ns__readsimulationResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns__readsimulationResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns__readsimulationResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns__readsimulationResponse %p -> %p\n", q, p));
	*(struct ns__readsimulationResponse*)p = *(struct ns__readsimulationResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__writesimulation(struct soap *soap, const struct ns__writesimulation *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->id, SOAP_TYPE_int);
	soap_serialize_string(soap, &a->filename);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__writesimulation(struct soap *soap, struct ns__writesimulation *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->id);
	soap_default_string(soap, &a->filename);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__writesimulation(struct soap *soap, const struct ns__writesimulation *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns__writesimulation);
	if (soap_out_ns__writesimulation(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__writesimulation(struct soap *soap, const char *tag, int id, const struct ns__writesimulation *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__writesimulation), type);
	soap_out_int(soap, "id", -1, &a->id, "");
	soap_out_string(soap, "filename", -1, &a->filename, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct ns__writesimulation * SOAP_FMAC4 soap_get_ns__writesimulation(struct soap *soap, struct ns__writesimulation *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__writesimulation(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct ns__writesimulation * SOAP_FMAC4 soap_in_ns__writesimulation(struct soap *soap, const char *tag, struct ns__writesimulation *a, const char *type)
{
	short soap_flag_id = 1, soap_flag_filename = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct ns__writesimulation *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__writesimulation, sizeof(struct ns__writesimulation), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns__writesimulation(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_id && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "id", &a->id, "xsd:int"))
				{	soap_flag_id--;
					continue;
				}
			if (soap_flag_filename && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "filename", &a->filename, "xsd:string"))
				{	soap_flag_filename--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_id > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns__writesimulation *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_ns__writesimulation, 0, sizeof(struct ns__writesimulation), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns__writesimulation * SOAP_FMAC6 soap_new_ns__writesimulation(struct soap *soap, int n)
{	return soap_instantiate_ns__writesimulation(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns__writesimulation(struct soap *soap, struct ns__writesimulation *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns__writesimulation * SOAP_FMAC4 soap_instantiate_ns__writesimulation(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__writesimulation(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns__writesimulation, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns__writesimulation;
		if (size)
			*size = sizeof(struct ns__writesimulation);
	}
	else
	{	cp->ptr = (void*)new struct ns__writesimulation[n];
		if (size)
			*size = n * sizeof(struct ns__writesimulation);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns__writesimulation*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns__writesimulation(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns__writesimulation %p -> %p\n", q, p));
	*(struct ns__writesimulation*)p = *(struct ns__writesimulation*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__writesimulationResponse(struct soap *soap, const struct ns__writesimulationResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTostring(soap, &a->filecontent);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__writesimulationResponse(struct soap *soap, struct ns__writesimulationResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->filecontent = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__writesimulationResponse(struct soap *soap, const struct ns__writesimulationResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns__writesimulationResponse);
	if (soap_out_ns__writesimulationResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__writesimulationResponse(struct soap *soap, const char *tag, int id, const struct ns__writesimulationResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__writesimulationResponse), type);
	if (a->filecontent)
		soap_element_result(soap, "filecontent");
	soap_out_PointerTostring(soap, "filecontent", -1, &a->filecontent, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct ns__writesimulationResponse * SOAP_FMAC4 soap_get_ns__writesimulationResponse(struct soap *soap, struct ns__writesimulationResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__writesimulationResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct ns__writesimulationResponse * SOAP_FMAC4 soap_in_ns__writesimulationResponse(struct soap *soap, const char *tag, struct ns__writesimulationResponse *a, const char *type)
{
	short soap_flag_filecontent = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct ns__writesimulationResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__writesimulationResponse, sizeof(struct ns__writesimulationResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns__writesimulationResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_filecontent && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTostring(soap, "filecontent", &a->filecontent, "xsd:string"))
				{	soap_flag_filecontent--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns__writesimulationResponse *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_ns__writesimulationResponse, 0, sizeof(struct ns__writesimulationResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns__writesimulationResponse * SOAP_FMAC6 soap_new_ns__writesimulationResponse(struct soap *soap, int n)
{	return soap_instantiate_ns__writesimulationResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns__writesimulationResponse(struct soap *soap, struct ns__writesimulationResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns__writesimulationResponse * SOAP_FMAC4 soap_instantiate_ns__writesimulationResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__writesimulationResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns__writesimulationResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns__writesimulationResponse;
		if (size)
			*size = sizeof(struct ns__writesimulationResponse);
	}
	else
	{	cp->ptr = (void*)new struct ns__writesimulationResponse[n];
		if (size)
			*size = n * sizeof(struct ns__writesimulationResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns__writesimulationResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns__writesimulationResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns__writesimulationResponse %p -> %p\n", q, p));
	*(struct ns__writesimulationResponse*)p = *(struct ns__writesimulationResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__readlocalsimulation(struct soap *soap, const struct ns__readlocalsimulation *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->id, SOAP_TYPE_int);
	soap_serialize_string(soap, &a->filename);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__readlocalsimulation(struct soap *soap, struct ns__readlocalsimulation *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->id);
	soap_default_string(soap, &a->filename);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__readlocalsimulation(struct soap *soap, const struct ns__readlocalsimulation *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns__readlocalsimulation);
	if (soap_out_ns__readlocalsimulation(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__readlocalsimulation(struct soap *soap, const char *tag, int id, const struct ns__readlocalsimulation *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__readlocalsimulation), type);
	soap_out_int(soap, "id", -1, &a->id, "");
	soap_out_string(soap, "filename", -1, &a->filename, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct ns__readlocalsimulation * SOAP_FMAC4 soap_get_ns__readlocalsimulation(struct soap *soap, struct ns__readlocalsimulation *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__readlocalsimulation(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct ns__readlocalsimulation * SOAP_FMAC4 soap_in_ns__readlocalsimulation(struct soap *soap, const char *tag, struct ns__readlocalsimulation *a, const char *type)
{
	short soap_flag_id = 1, soap_flag_filename = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct ns__readlocalsimulation *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__readlocalsimulation, sizeof(struct ns__readlocalsimulation), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns__readlocalsimulation(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_id && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "id", &a->id, "xsd:int"))
				{	soap_flag_id--;
					continue;
				}
			if (soap_flag_filename && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "filename", &a->filename, "xsd:string"))
				{	soap_flag_filename--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_id > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns__readlocalsimulation *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_ns__readlocalsimulation, 0, sizeof(struct ns__readlocalsimulation), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns__readlocalsimulation * SOAP_FMAC6 soap_new_ns__readlocalsimulation(struct soap *soap, int n)
{	return soap_instantiate_ns__readlocalsimulation(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns__readlocalsimulation(struct soap *soap, struct ns__readlocalsimulation *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns__readlocalsimulation * SOAP_FMAC4 soap_instantiate_ns__readlocalsimulation(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__readlocalsimulation(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns__readlocalsimulation, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns__readlocalsimulation;
		if (size)
			*size = sizeof(struct ns__readlocalsimulation);
	}
	else
	{	cp->ptr = (void*)new struct ns__readlocalsimulation[n];
		if (size)
			*size = n * sizeof(struct ns__readlocalsimulation);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns__readlocalsimulation*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns__readlocalsimulation(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns__readlocalsimulation %p -> %p\n", q, p));
	*(struct ns__readlocalsimulation*)p = *(struct ns__readlocalsimulation*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__readlocalsimulationResponse(struct soap *soap, const struct ns__readlocalsimulationResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToint(soap, &a->status);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__readlocalsimulationResponse(struct soap *soap, struct ns__readlocalsimulationResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->status = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__readlocalsimulationResponse(struct soap *soap, const struct ns__readlocalsimulationResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns__readlocalsimulationResponse);
	if (soap_out_ns__readlocalsimulationResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__readlocalsimulationResponse(struct soap *soap, const char *tag, int id, const struct ns__readlocalsimulationResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__readlocalsimulationResponse), type);
	if (a->status)
		soap_element_result(soap, "status");
	soap_out_PointerToint(soap, "status", -1, &a->status, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct ns__readlocalsimulationResponse * SOAP_FMAC4 soap_get_ns__readlocalsimulationResponse(struct soap *soap, struct ns__readlocalsimulationResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__readlocalsimulationResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct ns__readlocalsimulationResponse * SOAP_FMAC4 soap_in_ns__readlocalsimulationResponse(struct soap *soap, const char *tag, struct ns__readlocalsimulationResponse *a, const char *type)
{
	short soap_flag_status = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct ns__readlocalsimulationResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__readlocalsimulationResponse, sizeof(struct ns__readlocalsimulationResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns__readlocalsimulationResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_status && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "status", &a->status, "xsd:int"))
				{	soap_flag_status--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns__readlocalsimulationResponse *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_ns__readlocalsimulationResponse, 0, sizeof(struct ns__readlocalsimulationResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns__readlocalsimulationResponse * SOAP_FMAC6 soap_new_ns__readlocalsimulationResponse(struct soap *soap, int n)
{	return soap_instantiate_ns__readlocalsimulationResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns__readlocalsimulationResponse(struct soap *soap, struct ns__readlocalsimulationResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns__readlocalsimulationResponse * SOAP_FMAC4 soap_instantiate_ns__readlocalsimulationResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__readlocalsimulationResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns__readlocalsimulationResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns__readlocalsimulationResponse;
		if (size)
			*size = sizeof(struct ns__readlocalsimulationResponse);
	}
	else
	{	cp->ptr = (void*)new struct ns__readlocalsimulationResponse[n];
		if (size)
			*size = n * sizeof(struct ns__readlocalsimulationResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns__readlocalsimulationResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns__readlocalsimulationResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns__readlocalsimulationResponse %p -> %p\n", q, p));
	*(struct ns__readlocalsimulationResponse*)p = *(struct ns__readlocalsimulationResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__writelocalsimulation(struct soap *soap, const struct ns__writelocalsimulation *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->id, SOAP_TYPE_int);
	soap_serialize_string(soap, &a->filename);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__writelocalsimulation(struct soap *soap, struct ns__writelocalsimulation *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->id);
	soap_default_string(soap, &a->filename);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__writelocalsimulation(struct soap *soap, const struct ns__writelocalsimulation *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns__writelocalsimulation);
	if (soap_out_ns__writelocalsimulation(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__writelocalsimulation(struct soap *soap, const char *tag, int id, const struct ns__writelocalsimulation *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__writelocalsimulation), type);
	soap_out_int(soap, "id", -1, &a->id, "");
	soap_out_string(soap, "filename", -1, &a->filename, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct ns__writelocalsimulation * SOAP_FMAC4 soap_get_ns__writelocalsimulation(struct soap *soap, struct ns__writelocalsimulation *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__writelocalsimulation(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct ns__writelocalsimulation * SOAP_FMAC4 soap_in_ns__writelocalsimulation(struct soap *soap, const char *tag, struct ns__writelocalsimulation *a, const char *type)
{
	short soap_flag_id = 1, soap_flag_filename = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct ns__writelocalsimulation *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__writelocalsimulation, sizeof(struct ns__writelocalsimulation), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns__writelocalsimulation(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_id && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "id", &a->id, "xsd:int"))
				{	soap_flag_id--;
					continue;
				}
			if (soap_flag_filename && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "filename", &a->filename, "xsd:string"))
				{	soap_flag_filename--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_id > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns__writelocalsimulation *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_ns__writelocalsimulation, 0, sizeof(struct ns__writelocalsimulation), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns__writelocalsimulation * SOAP_FMAC6 soap_new_ns__writelocalsimulation(struct soap *soap, int n)
{	return soap_instantiate_ns__writelocalsimulation(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns__writelocalsimulation(struct soap *soap, struct ns__writelocalsimulation *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns__writelocalsimulation * SOAP_FMAC4 soap_instantiate_ns__writelocalsimulation(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__writelocalsimulation(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns__writelocalsimulation, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns__writelocalsimulation;
		if (size)
			*size = sizeof(struct ns__writelocalsimulation);
	}
	else
	{	cp->ptr = (void*)new struct ns__writelocalsimulation[n];
		if (size)
			*size = n * sizeof(struct ns__writelocalsimulation);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns__writelocalsimulation*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns__writelocalsimulation(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns__writelocalsimulation %p -> %p\n", q, p));
	*(struct ns__writelocalsimulation*)p = *(struct ns__writelocalsimulation*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__writelocalsimulationResponse(struct soap *soap, const struct ns__writelocalsimulationResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTostring(soap, &a->filecontent);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__writelocalsimulationResponse(struct soap *soap, struct ns__writelocalsimulationResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->filecontent = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__writelocalsimulationResponse(struct soap *soap, const struct ns__writelocalsimulationResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns__writelocalsimulationResponse);
	if (soap_out_ns__writelocalsimulationResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__writelocalsimulationResponse(struct soap *soap, const char *tag, int id, const struct ns__writelocalsimulationResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__writelocalsimulationResponse), type);
	if (a->filecontent)
		soap_element_result(soap, "filecontent");
	soap_out_PointerTostring(soap, "filecontent", -1, &a->filecontent, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct ns__writelocalsimulationResponse * SOAP_FMAC4 soap_get_ns__writelocalsimulationResponse(struct soap *soap, struct ns__writelocalsimulationResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__writelocalsimulationResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct ns__writelocalsimulationResponse * SOAP_FMAC4 soap_in_ns__writelocalsimulationResponse(struct soap *soap, const char *tag, struct ns__writelocalsimulationResponse *a, const char *type)
{
	short soap_flag_filecontent = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct ns__writelocalsimulationResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__writelocalsimulationResponse, sizeof(struct ns__writelocalsimulationResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns__writelocalsimulationResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_filecontent && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTostring(soap, "filecontent", &a->filecontent, "xsd:string"))
				{	soap_flag_filecontent--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns__writelocalsimulationResponse *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_ns__writelocalsimulationResponse, 0, sizeof(struct ns__writelocalsimulationResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns__writelocalsimulationResponse * SOAP_FMAC6 soap_new_ns__writelocalsimulationResponse(struct soap *soap, int n)
{	return soap_instantiate_ns__writelocalsimulationResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns__writelocalsimulationResponse(struct soap *soap, struct ns__writelocalsimulationResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns__writelocalsimulationResponse * SOAP_FMAC4 soap_instantiate_ns__writelocalsimulationResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__writelocalsimulationResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns__writelocalsimulationResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns__writelocalsimulationResponse;
		if (size)
			*size = sizeof(struct ns__writelocalsimulationResponse);
	}
	else
	{	cp->ptr = (void*)new struct ns__writelocalsimulationResponse[n];
		if (size)
			*size = n * sizeof(struct ns__writelocalsimulationResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns__writelocalsimulationResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns__writelocalsimulationResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns__writelocalsimulationResponse %p -> %p\n", q, p));
	*(struct ns__writelocalsimulationResponse*)p = *(struct ns__writelocalsimulationResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__createsimulation(struct soap *soap, const struct ns__createsimulation *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->id, SOAP_TYPE_int);
	soap_serialize_string(soap, &a->filename);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__createsimulation(struct soap *soap, struct ns__createsimulation *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->id);
	soap_default_string(soap, &a->filename);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__createsimulation(struct soap *soap, const struct ns__createsimulation *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns__createsimulation);
	if (soap_out_ns__createsimulation(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__createsimulation(struct soap *soap, const char *tag, int id, const struct ns__createsimulation *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__createsimulation), type);
	soap_out_int(soap, "id", -1, &a->id, "");
	soap_out_string(soap, "filename", -1, &a->filename, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct ns__createsimulation * SOAP_FMAC4 soap_get_ns__createsimulation(struct soap *soap, struct ns__createsimulation *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__createsimulation(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct ns__createsimulation * SOAP_FMAC4 soap_in_ns__createsimulation(struct soap *soap, const char *tag, struct ns__createsimulation *a, const char *type)
{
	short soap_flag_id = 1, soap_flag_filename = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct ns__createsimulation *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__createsimulation, sizeof(struct ns__createsimulation), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns__createsimulation(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_id && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "id", &a->id, "xsd:int"))
				{	soap_flag_id--;
					continue;
				}
			if (soap_flag_filename && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "filename", &a->filename, "xsd:string"))
				{	soap_flag_filename--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_id > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns__createsimulation *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_ns__createsimulation, 0, sizeof(struct ns__createsimulation), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns__createsimulation * SOAP_FMAC6 soap_new_ns__createsimulation(struct soap *soap, int n)
{	return soap_instantiate_ns__createsimulation(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns__createsimulation(struct soap *soap, struct ns__createsimulation *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns__createsimulation * SOAP_FMAC4 soap_instantiate_ns__createsimulation(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__createsimulation(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns__createsimulation, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns__createsimulation;
		if (size)
			*size = sizeof(struct ns__createsimulation);
	}
	else
	{	cp->ptr = (void*)new struct ns__createsimulation[n];
		if (size)
			*size = n * sizeof(struct ns__createsimulation);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns__createsimulation*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns__createsimulation(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns__createsimulation %p -> %p\n", q, p));
	*(struct ns__createsimulation*)p = *(struct ns__createsimulation*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__createsimulationResponse(struct soap *soap, const struct ns__createsimulationResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToint(soap, &a->status);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__createsimulationResponse(struct soap *soap, struct ns__createsimulationResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->status = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__createsimulationResponse(struct soap *soap, const struct ns__createsimulationResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns__createsimulationResponse);
	if (soap_out_ns__createsimulationResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__createsimulationResponse(struct soap *soap, const char *tag, int id, const struct ns__createsimulationResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__createsimulationResponse), type);
	if (a->status)
		soap_element_result(soap, "status");
	soap_out_PointerToint(soap, "status", -1, &a->status, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct ns__createsimulationResponse * SOAP_FMAC4 soap_get_ns__createsimulationResponse(struct soap *soap, struct ns__createsimulationResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__createsimulationResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct ns__createsimulationResponse * SOAP_FMAC4 soap_in_ns__createsimulationResponse(struct soap *soap, const char *tag, struct ns__createsimulationResponse *a, const char *type)
{
	short soap_flag_status = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct ns__createsimulationResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__createsimulationResponse, sizeof(struct ns__createsimulationResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns__createsimulationResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_status && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "status", &a->status, "xsd:int"))
				{	soap_flag_status--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns__createsimulationResponse *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_ns__createsimulationResponse, 0, sizeof(struct ns__createsimulationResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns__createsimulationResponse * SOAP_FMAC6 soap_new_ns__createsimulationResponse(struct soap *soap, int n)
{	return soap_instantiate_ns__createsimulationResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns__createsimulationResponse(struct soap *soap, struct ns__createsimulationResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns__createsimulationResponse * SOAP_FMAC4 soap_instantiate_ns__createsimulationResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__createsimulationResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns__createsimulationResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns__createsimulationResponse;
		if (size)
			*size = sizeof(struct ns__createsimulationResponse);
	}
	else
	{	cp->ptr = (void*)new struct ns__createsimulationResponse[n];
		if (size)
			*size = n * sizeof(struct ns__createsimulationResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns__createsimulationResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns__createsimulationResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns__createsimulationResponse %p -> %p\n", q, p));
	*(struct ns__createsimulationResponse*)p = *(struct ns__createsimulationResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__newsimulation(struct soap *soap, const struct ns__newsimulation *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->id, SOAP_TYPE_int);
	soap_serialize_string(soap, &a->simname);
	soap_serialize_string(soap, &a->xslname);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__newsimulation(struct soap *soap, struct ns__newsimulation *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->id);
	soap_default_string(soap, &a->simname);
	soap_default_string(soap, &a->xslname);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__newsimulation(struct soap *soap, const struct ns__newsimulation *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns__newsimulation);
	if (soap_out_ns__newsimulation(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__newsimulation(struct soap *soap, const char *tag, int id, const struct ns__newsimulation *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__newsimulation), type);
	soap_out_int(soap, "id", -1, &a->id, "");
	soap_out_string(soap, "simname", -1, &a->simname, "");
	soap_out_string(soap, "xslname", -1, &a->xslname, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct ns__newsimulation * SOAP_FMAC4 soap_get_ns__newsimulation(struct soap *soap, struct ns__newsimulation *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__newsimulation(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct ns__newsimulation * SOAP_FMAC4 soap_in_ns__newsimulation(struct soap *soap, const char *tag, struct ns__newsimulation *a, const char *type)
{
	short soap_flag_id = 1, soap_flag_simname = 1, soap_flag_xslname = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct ns__newsimulation *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__newsimulation, sizeof(struct ns__newsimulation), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns__newsimulation(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_id && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "id", &a->id, "xsd:int"))
				{	soap_flag_id--;
					continue;
				}
			if (soap_flag_simname && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "simname", &a->simname, "xsd:string"))
				{	soap_flag_simname--;
					continue;
				}
			if (soap_flag_xslname && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "xslname", &a->xslname, "xsd:string"))
				{	soap_flag_xslname--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_id > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns__newsimulation *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_ns__newsimulation, 0, sizeof(struct ns__newsimulation), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns__newsimulation * SOAP_FMAC6 soap_new_ns__newsimulation(struct soap *soap, int n)
{	return soap_instantiate_ns__newsimulation(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns__newsimulation(struct soap *soap, struct ns__newsimulation *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns__newsimulation * SOAP_FMAC4 soap_instantiate_ns__newsimulation(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__newsimulation(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns__newsimulation, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns__newsimulation;
		if (size)
			*size = sizeof(struct ns__newsimulation);
	}
	else
	{	cp->ptr = (void*)new struct ns__newsimulation[n];
		if (size)
			*size = n * sizeof(struct ns__newsimulation);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns__newsimulation*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns__newsimulation(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns__newsimulation %p -> %p\n", q, p));
	*(struct ns__newsimulation*)p = *(struct ns__newsimulation*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__newsimulationResponse(struct soap *soap, const struct ns__newsimulationResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToint(soap, &a->status);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__newsimulationResponse(struct soap *soap, struct ns__newsimulationResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->status = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__newsimulationResponse(struct soap *soap, const struct ns__newsimulationResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns__newsimulationResponse);
	if (soap_out_ns__newsimulationResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__newsimulationResponse(struct soap *soap, const char *tag, int id, const struct ns__newsimulationResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__newsimulationResponse), type);
	if (a->status)
		soap_element_result(soap, "status");
	soap_out_PointerToint(soap, "status", -1, &a->status, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct ns__newsimulationResponse * SOAP_FMAC4 soap_get_ns__newsimulationResponse(struct soap *soap, struct ns__newsimulationResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__newsimulationResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct ns__newsimulationResponse * SOAP_FMAC4 soap_in_ns__newsimulationResponse(struct soap *soap, const char *tag, struct ns__newsimulationResponse *a, const char *type)
{
	short soap_flag_status = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct ns__newsimulationResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__newsimulationResponse, sizeof(struct ns__newsimulationResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns__newsimulationResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_status && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "status", &a->status, "xsd:int"))
				{	soap_flag_status--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns__newsimulationResponse *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_ns__newsimulationResponse, 0, sizeof(struct ns__newsimulationResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns__newsimulationResponse * SOAP_FMAC6 soap_new_ns__newsimulationResponse(struct soap *soap, int n)
{	return soap_instantiate_ns__newsimulationResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns__newsimulationResponse(struct soap *soap, struct ns__newsimulationResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns__newsimulationResponse * SOAP_FMAC4 soap_instantiate_ns__newsimulationResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__newsimulationResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns__newsimulationResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns__newsimulationResponse;
		if (size)
			*size = sizeof(struct ns__newsimulationResponse);
	}
	else
	{	cp->ptr = (void*)new struct ns__newsimulationResponse[n];
		if (size)
			*size = n * sizeof(struct ns__newsimulationResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns__newsimulationResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns__newsimulationResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns__newsimulationResponse %p -> %p\n", q, p));
	*(struct ns__newsimulationResponse*)p = *(struct ns__newsimulationResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__deletesimulation(struct soap *soap, const struct ns__deletesimulation *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->isimid, SOAP_TYPE_int);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__deletesimulation(struct soap *soap, struct ns__deletesimulation *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->isimid);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__deletesimulation(struct soap *soap, const struct ns__deletesimulation *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns__deletesimulation);
	if (soap_out_ns__deletesimulation(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__deletesimulation(struct soap *soap, const char *tag, int id, const struct ns__deletesimulation *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__deletesimulation), type);
	soap_out_int(soap, "isimid", -1, &a->isimid, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct ns__deletesimulation * SOAP_FMAC4 soap_get_ns__deletesimulation(struct soap *soap, struct ns__deletesimulation *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__deletesimulation(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct ns__deletesimulation * SOAP_FMAC4 soap_in_ns__deletesimulation(struct soap *soap, const char *tag, struct ns__deletesimulation *a, const char *type)
{
	short soap_flag_isimid = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct ns__deletesimulation *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__deletesimulation, sizeof(struct ns__deletesimulation), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns__deletesimulation(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_isimid && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "isimid", &a->isimid, "xsd:int"))
				{	soap_flag_isimid--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_isimid > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns__deletesimulation *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_ns__deletesimulation, 0, sizeof(struct ns__deletesimulation), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns__deletesimulation * SOAP_FMAC6 soap_new_ns__deletesimulation(struct soap *soap, int n)
{	return soap_instantiate_ns__deletesimulation(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns__deletesimulation(struct soap *soap, struct ns__deletesimulation *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns__deletesimulation * SOAP_FMAC4 soap_instantiate_ns__deletesimulation(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__deletesimulation(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns__deletesimulation, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns__deletesimulation;
		if (size)
			*size = sizeof(struct ns__deletesimulation);
	}
	else
	{	cp->ptr = (void*)new struct ns__deletesimulation[n];
		if (size)
			*size = n * sizeof(struct ns__deletesimulation);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns__deletesimulation*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns__deletesimulation(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns__deletesimulation %p -> %p\n", q, p));
	*(struct ns__deletesimulation*)p = *(struct ns__deletesimulation*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__deletesimulationResponse(struct soap *soap, const struct ns__deletesimulationResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToint(soap, &a->status);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__deletesimulationResponse(struct soap *soap, struct ns__deletesimulationResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->status = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__deletesimulationResponse(struct soap *soap, const struct ns__deletesimulationResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns__deletesimulationResponse);
	if (soap_out_ns__deletesimulationResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__deletesimulationResponse(struct soap *soap, const char *tag, int id, const struct ns__deletesimulationResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__deletesimulationResponse), type);
	if (a->status)
		soap_element_result(soap, "status");
	soap_out_PointerToint(soap, "status", -1, &a->status, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct ns__deletesimulationResponse * SOAP_FMAC4 soap_get_ns__deletesimulationResponse(struct soap *soap, struct ns__deletesimulationResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__deletesimulationResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct ns__deletesimulationResponse * SOAP_FMAC4 soap_in_ns__deletesimulationResponse(struct soap *soap, const char *tag, struct ns__deletesimulationResponse *a, const char *type)
{
	short soap_flag_status = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct ns__deletesimulationResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__deletesimulationResponse, sizeof(struct ns__deletesimulationResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns__deletesimulationResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_status && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "status", &a->status, "xsd:int"))
				{	soap_flag_status--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns__deletesimulationResponse *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_ns__deletesimulationResponse, 0, sizeof(struct ns__deletesimulationResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns__deletesimulationResponse * SOAP_FMAC6 soap_new_ns__deletesimulationResponse(struct soap *soap, int n)
{	return soap_instantiate_ns__deletesimulationResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns__deletesimulationResponse(struct soap *soap, struct ns__deletesimulationResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns__deletesimulationResponse * SOAP_FMAC4 soap_instantiate_ns__deletesimulationResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__deletesimulationResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns__deletesimulationResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns__deletesimulationResponse;
		if (size)
			*size = sizeof(struct ns__deletesimulationResponse);
	}
	else
	{	cp->ptr = (void*)new struct ns__deletesimulationResponse[n];
		if (size)
			*size = n * sizeof(struct ns__deletesimulationResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns__deletesimulationResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns__deletesimulationResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns__deletesimulationResponse %p -> %p\n", q, p));
	*(struct ns__deletesimulationResponse*)p = *(struct ns__deletesimulationResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__getsimulationresults(struct soap *soap, const struct ns__getsimulationresults *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->isimid, SOAP_TYPE_int);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__getsimulationresults(struct soap *soap, struct ns__getsimulationresults *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->isimid);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__getsimulationresults(struct soap *soap, const struct ns__getsimulationresults *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns__getsimulationresults);
	if (soap_out_ns__getsimulationresults(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__getsimulationresults(struct soap *soap, const char *tag, int id, const struct ns__getsimulationresults *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__getsimulationresults), type);
	soap_out_int(soap, "isimid", -1, &a->isimid, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct ns__getsimulationresults * SOAP_FMAC4 soap_get_ns__getsimulationresults(struct soap *soap, struct ns__getsimulationresults *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__getsimulationresults(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct ns__getsimulationresults * SOAP_FMAC4 soap_in_ns__getsimulationresults(struct soap *soap, const char *tag, struct ns__getsimulationresults *a, const char *type)
{
	short soap_flag_isimid = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct ns__getsimulationresults *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__getsimulationresults, sizeof(struct ns__getsimulationresults), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns__getsimulationresults(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_isimid && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "isimid", &a->isimid, "xsd:int"))
				{	soap_flag_isimid--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_isimid > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns__getsimulationresults *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_ns__getsimulationresults, 0, sizeof(struct ns__getsimulationresults), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns__getsimulationresults * SOAP_FMAC6 soap_new_ns__getsimulationresults(struct soap *soap, int n)
{	return soap_instantiate_ns__getsimulationresults(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns__getsimulationresults(struct soap *soap, struct ns__getsimulationresults *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns__getsimulationresults * SOAP_FMAC4 soap_instantiate_ns__getsimulationresults(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__getsimulationresults(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns__getsimulationresults, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns__getsimulationresults;
		if (size)
			*size = sizeof(struct ns__getsimulationresults);
	}
	else
	{	cp->ptr = (void*)new struct ns__getsimulationresults[n];
		if (size)
			*size = n * sizeof(struct ns__getsimulationresults);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns__getsimulationresults*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns__getsimulationresults(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns__getsimulationresults %p -> %p\n", q, p));
	*(struct ns__getsimulationresults*)p = *(struct ns__getsimulationresults*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__getsimulationresultsResponse(struct soap *soap, const struct ns__getsimulationresultsResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTostring(soap, &a->result);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__getsimulationresultsResponse(struct soap *soap, struct ns__getsimulationresultsResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->result = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__getsimulationresultsResponse(struct soap *soap, const struct ns__getsimulationresultsResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns__getsimulationresultsResponse);
	if (soap_out_ns__getsimulationresultsResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__getsimulationresultsResponse(struct soap *soap, const char *tag, int id, const struct ns__getsimulationresultsResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__getsimulationresultsResponse), type);
	if (a->result)
		soap_element_result(soap, "result");
	soap_out_PointerTostring(soap, "result", -1, &a->result, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct ns__getsimulationresultsResponse * SOAP_FMAC4 soap_get_ns__getsimulationresultsResponse(struct soap *soap, struct ns__getsimulationresultsResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__getsimulationresultsResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct ns__getsimulationresultsResponse * SOAP_FMAC4 soap_in_ns__getsimulationresultsResponse(struct soap *soap, const char *tag, struct ns__getsimulationresultsResponse *a, const char *type)
{
	short soap_flag_result = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct ns__getsimulationresultsResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__getsimulationresultsResponse, sizeof(struct ns__getsimulationresultsResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns__getsimulationresultsResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTostring(soap, "result", &a->result, "xsd:string"))
				{	soap_flag_result--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns__getsimulationresultsResponse *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_ns__getsimulationresultsResponse, 0, sizeof(struct ns__getsimulationresultsResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns__getsimulationresultsResponse * SOAP_FMAC6 soap_new_ns__getsimulationresultsResponse(struct soap *soap, int n)
{	return soap_instantiate_ns__getsimulationresultsResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns__getsimulationresultsResponse(struct soap *soap, struct ns__getsimulationresultsResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns__getsimulationresultsResponse * SOAP_FMAC4 soap_instantiate_ns__getsimulationresultsResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__getsimulationresultsResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns__getsimulationresultsResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns__getsimulationresultsResponse;
		if (size)
			*size = sizeof(struct ns__getsimulationresultsResponse);
	}
	else
	{	cp->ptr = (void*)new struct ns__getsimulationresultsResponse[n];
		if (size)
			*size = n * sizeof(struct ns__getsimulationresultsResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns__getsimulationresultsResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns__getsimulationresultsResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns__getsimulationresultsResponse %p -> %p\n", q, p));
	*(struct ns__getsimulationresultsResponse*)p = *(struct ns__getsimulationresultsResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__setsimulationstatus(struct soap *soap, const struct ns__setsimulationstatus *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->newstatus, SOAP_TYPE_int);
	soap_embedded(soap, &a->isimid, SOAP_TYPE_int);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__setsimulationstatus(struct soap *soap, struct ns__setsimulationstatus *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->newstatus);
	soap_default_int(soap, &a->isimid);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__setsimulationstatus(struct soap *soap, const struct ns__setsimulationstatus *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns__setsimulationstatus);
	if (soap_out_ns__setsimulationstatus(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__setsimulationstatus(struct soap *soap, const char *tag, int id, const struct ns__setsimulationstatus *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__setsimulationstatus), type);
	soap_out_int(soap, "newstatus", -1, &a->newstatus, "");
	soap_out_int(soap, "isimid", -1, &a->isimid, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct ns__setsimulationstatus * SOAP_FMAC4 soap_get_ns__setsimulationstatus(struct soap *soap, struct ns__setsimulationstatus *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__setsimulationstatus(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct ns__setsimulationstatus * SOAP_FMAC4 soap_in_ns__setsimulationstatus(struct soap *soap, const char *tag, struct ns__setsimulationstatus *a, const char *type)
{
	short soap_flag_newstatus = 1, soap_flag_isimid = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct ns__setsimulationstatus *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__setsimulationstatus, sizeof(struct ns__setsimulationstatus), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns__setsimulationstatus(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_newstatus && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "newstatus", &a->newstatus, "xsd:int"))
				{	soap_flag_newstatus--;
					continue;
				}
			if (soap_flag_isimid && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "isimid", &a->isimid, "xsd:int"))
				{	soap_flag_isimid--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_newstatus > 0 || soap_flag_isimid > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns__setsimulationstatus *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_ns__setsimulationstatus, 0, sizeof(struct ns__setsimulationstatus), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns__setsimulationstatus * SOAP_FMAC6 soap_new_ns__setsimulationstatus(struct soap *soap, int n)
{	return soap_instantiate_ns__setsimulationstatus(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns__setsimulationstatus(struct soap *soap, struct ns__setsimulationstatus *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns__setsimulationstatus * SOAP_FMAC4 soap_instantiate_ns__setsimulationstatus(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__setsimulationstatus(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns__setsimulationstatus, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns__setsimulationstatus;
		if (size)
			*size = sizeof(struct ns__setsimulationstatus);
	}
	else
	{	cp->ptr = (void*)new struct ns__setsimulationstatus[n];
		if (size)
			*size = n * sizeof(struct ns__setsimulationstatus);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns__setsimulationstatus*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns__setsimulationstatus(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns__setsimulationstatus %p -> %p\n", q, p));
	*(struct ns__setsimulationstatus*)p = *(struct ns__setsimulationstatus*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__setsimulationstatusResponse(struct soap *soap, const struct ns__setsimulationstatusResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToint(soap, &a->status);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__setsimulationstatusResponse(struct soap *soap, struct ns__setsimulationstatusResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->status = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__setsimulationstatusResponse(struct soap *soap, const struct ns__setsimulationstatusResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns__setsimulationstatusResponse);
	if (soap_out_ns__setsimulationstatusResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__setsimulationstatusResponse(struct soap *soap, const char *tag, int id, const struct ns__setsimulationstatusResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__setsimulationstatusResponse), type);
	if (a->status)
		soap_element_result(soap, "status");
	soap_out_PointerToint(soap, "status", -1, &a->status, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct ns__setsimulationstatusResponse * SOAP_FMAC4 soap_get_ns__setsimulationstatusResponse(struct soap *soap, struct ns__setsimulationstatusResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__setsimulationstatusResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct ns__setsimulationstatusResponse * SOAP_FMAC4 soap_in_ns__setsimulationstatusResponse(struct soap *soap, const char *tag, struct ns__setsimulationstatusResponse *a, const char *type)
{
	short soap_flag_status = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct ns__setsimulationstatusResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__setsimulationstatusResponse, sizeof(struct ns__setsimulationstatusResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns__setsimulationstatusResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_status && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "status", &a->status, "xsd:int"))
				{	soap_flag_status--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns__setsimulationstatusResponse *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_ns__setsimulationstatusResponse, 0, sizeof(struct ns__setsimulationstatusResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns__setsimulationstatusResponse * SOAP_FMAC6 soap_new_ns__setsimulationstatusResponse(struct soap *soap, int n)
{	return soap_instantiate_ns__setsimulationstatusResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns__setsimulationstatusResponse(struct soap *soap, struct ns__setsimulationstatusResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns__setsimulationstatusResponse * SOAP_FMAC4 soap_instantiate_ns__setsimulationstatusResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__setsimulationstatusResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns__setsimulationstatusResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns__setsimulationstatusResponse;
		if (size)
			*size = sizeof(struct ns__setsimulationstatusResponse);
	}
	else
	{	cp->ptr = (void*)new struct ns__setsimulationstatusResponse[n];
		if (size)
			*size = n * sizeof(struct ns__setsimulationstatusResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns__setsimulationstatusResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns__setsimulationstatusResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns__setsimulationstatusResponse %p -> %p\n", q, p));
	*(struct ns__setsimulationstatusResponse*)p = *(struct ns__setsimulationstatusResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__simulationstatus(struct soap *soap, const struct ns__simulationstatus *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->isimid, SOAP_TYPE_int);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__simulationstatus(struct soap *soap, struct ns__simulationstatus *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->isimid);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__simulationstatus(struct soap *soap, const struct ns__simulationstatus *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns__simulationstatus);
	if (soap_out_ns__simulationstatus(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__simulationstatus(struct soap *soap, const char *tag, int id, const struct ns__simulationstatus *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__simulationstatus), type);
	soap_out_int(soap, "isimid", -1, &a->isimid, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct ns__simulationstatus * SOAP_FMAC4 soap_get_ns__simulationstatus(struct soap *soap, struct ns__simulationstatus *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__simulationstatus(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct ns__simulationstatus * SOAP_FMAC4 soap_in_ns__simulationstatus(struct soap *soap, const char *tag, struct ns__simulationstatus *a, const char *type)
{
	short soap_flag_isimid = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct ns__simulationstatus *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__simulationstatus, sizeof(struct ns__simulationstatus), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns__simulationstatus(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_isimid && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "isimid", &a->isimid, "xsd:int"))
				{	soap_flag_isimid--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_isimid > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns__simulationstatus *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_ns__simulationstatus, 0, sizeof(struct ns__simulationstatus), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns__simulationstatus * SOAP_FMAC6 soap_new_ns__simulationstatus(struct soap *soap, int n)
{	return soap_instantiate_ns__simulationstatus(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns__simulationstatus(struct soap *soap, struct ns__simulationstatus *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns__simulationstatus * SOAP_FMAC4 soap_instantiate_ns__simulationstatus(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__simulationstatus(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns__simulationstatus, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns__simulationstatus;
		if (size)
			*size = sizeof(struct ns__simulationstatus);
	}
	else
	{	cp->ptr = (void*)new struct ns__simulationstatus[n];
		if (size)
			*size = n * sizeof(struct ns__simulationstatus);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns__simulationstatus*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns__simulationstatus(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns__simulationstatus %p -> %p\n", q, p));
	*(struct ns__simulationstatus*)p = *(struct ns__simulationstatus*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__simulationstatusResponse(struct soap *soap, const struct ns__simulationstatusResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToint(soap, &a->status);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__simulationstatusResponse(struct soap *soap, struct ns__simulationstatusResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->status = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__simulationstatusResponse(struct soap *soap, const struct ns__simulationstatusResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns__simulationstatusResponse);
	if (soap_out_ns__simulationstatusResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__simulationstatusResponse(struct soap *soap, const char *tag, int id, const struct ns__simulationstatusResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__simulationstatusResponse), type);
	if (a->status)
		soap_element_result(soap, "status");
	soap_out_PointerToint(soap, "status", -1, &a->status, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct ns__simulationstatusResponse * SOAP_FMAC4 soap_get_ns__simulationstatusResponse(struct soap *soap, struct ns__simulationstatusResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__simulationstatusResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct ns__simulationstatusResponse * SOAP_FMAC4 soap_in_ns__simulationstatusResponse(struct soap *soap, const char *tag, struct ns__simulationstatusResponse *a, const char *type)
{
	short soap_flag_status = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct ns__simulationstatusResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__simulationstatusResponse, sizeof(struct ns__simulationstatusResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns__simulationstatusResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_status && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "status", &a->status, "xsd:int"))
				{	soap_flag_status--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns__simulationstatusResponse *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_ns__simulationstatusResponse, 0, sizeof(struct ns__simulationstatusResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns__simulationstatusResponse * SOAP_FMAC6 soap_new_ns__simulationstatusResponse(struct soap *soap, int n)
{	return soap_instantiate_ns__simulationstatusResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns__simulationstatusResponse(struct soap *soap, struct ns__simulationstatusResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns__simulationstatusResponse * SOAP_FMAC4 soap_instantiate_ns__simulationstatusResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__simulationstatusResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns__simulationstatusResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns__simulationstatusResponse;
		if (size)
			*size = sizeof(struct ns__simulationstatusResponse);
	}
	else
	{	cp->ptr = (void*)new struct ns__simulationstatusResponse[n];
		if (size)
			*size = n * sizeof(struct ns__simulationstatusResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns__simulationstatusResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns__simulationstatusResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns__simulationstatusResponse %p -> %p\n", q, p));
	*(struct ns__simulationstatusResponse*)p = *(struct ns__simulationstatusResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__submitsimulation(struct soap *soap, const struct ns__submitsimulation *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->simfilecontent);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__submitsimulation(struct soap *soap, struct ns__submitsimulation *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->simfilecontent);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__submitsimulation(struct soap *soap, const struct ns__submitsimulation *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns__submitsimulation);
	if (soap_out_ns__submitsimulation(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__submitsimulation(struct soap *soap, const char *tag, int id, const struct ns__submitsimulation *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__submitsimulation), type);
	soap_out_string(soap, "simfilecontent", -1, &a->simfilecontent, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct ns__submitsimulation * SOAP_FMAC4 soap_get_ns__submitsimulation(struct soap *soap, struct ns__submitsimulation *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__submitsimulation(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct ns__submitsimulation * SOAP_FMAC4 soap_in_ns__submitsimulation(struct soap *soap, const char *tag, struct ns__submitsimulation *a, const char *type)
{
	short soap_flag_simfilecontent = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct ns__submitsimulation *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__submitsimulation, sizeof(struct ns__submitsimulation), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns__submitsimulation(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_simfilecontent && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "simfilecontent", &a->simfilecontent, "xsd:string"))
				{	soap_flag_simfilecontent--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns__submitsimulation *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_ns__submitsimulation, 0, sizeof(struct ns__submitsimulation), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns__submitsimulation * SOAP_FMAC6 soap_new_ns__submitsimulation(struct soap *soap, int n)
{	return soap_instantiate_ns__submitsimulation(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns__submitsimulation(struct soap *soap, struct ns__submitsimulation *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns__submitsimulation * SOAP_FMAC4 soap_instantiate_ns__submitsimulation(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__submitsimulation(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns__submitsimulation, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns__submitsimulation;
		if (size)
			*size = sizeof(struct ns__submitsimulation);
	}
	else
	{	cp->ptr = (void*)new struct ns__submitsimulation[n];
		if (size)
			*size = n * sizeof(struct ns__submitsimulation);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns__submitsimulation*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns__submitsimulation(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns__submitsimulation %p -> %p\n", q, p));
	*(struct ns__submitsimulation*)p = *(struct ns__submitsimulation*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__submitsimulationResponse(struct soap *soap, const struct ns__submitsimulationResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToint(soap, &a->isimid);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__submitsimulationResponse(struct soap *soap, struct ns__submitsimulationResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->isimid = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__submitsimulationResponse(struct soap *soap, const struct ns__submitsimulationResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns__submitsimulationResponse);
	if (soap_out_ns__submitsimulationResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__submitsimulationResponse(struct soap *soap, const char *tag, int id, const struct ns__submitsimulationResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__submitsimulationResponse), type);
	if (a->isimid)
		soap_element_result(soap, "isimid");
	soap_out_PointerToint(soap, "isimid", -1, &a->isimid, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct ns__submitsimulationResponse * SOAP_FMAC4 soap_get_ns__submitsimulationResponse(struct soap *soap, struct ns__submitsimulationResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__submitsimulationResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct ns__submitsimulationResponse * SOAP_FMAC4 soap_in_ns__submitsimulationResponse(struct soap *soap, const char *tag, struct ns__submitsimulationResponse *a, const char *type)
{
	short soap_flag_isimid = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct ns__submitsimulationResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__submitsimulationResponse, sizeof(struct ns__submitsimulationResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns__submitsimulationResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_isimid && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "isimid", &a->isimid, "xsd:int"))
				{	soap_flag_isimid--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns__submitsimulationResponse *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_ns__submitsimulationResponse, 0, sizeof(struct ns__submitsimulationResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns__submitsimulationResponse * SOAP_FMAC6 soap_new_ns__submitsimulationResponse(struct soap *soap, int n)
{	return soap_instantiate_ns__submitsimulationResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns__submitsimulationResponse(struct soap *soap, struct ns__submitsimulationResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns__submitsimulationResponse * SOAP_FMAC4 soap_instantiate_ns__submitsimulationResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__submitsimulationResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns__submitsimulationResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns__submitsimulationResponse;
		if (size)
			*size = sizeof(struct ns__submitsimulationResponse);
	}
	else
	{	cp->ptr = (void*)new struct ns__submitsimulationResponse[n];
		if (size)
			*size = n * sizeof(struct ns__submitsimulationResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns__submitsimulationResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns__submitsimulationResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns__submitsimulationResponse %p -> %p\n", q, p));
	*(struct ns__submitsimulationResponse*)p = *(struct ns__submitsimulationResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__runrequestedsimulation(struct soap *soap, const struct ns__runrequestedsimulation *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->isimid, SOAP_TYPE_int);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__runrequestedsimulation(struct soap *soap, struct ns__runrequestedsimulation *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->isimid);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__runrequestedsimulation(struct soap *soap, const struct ns__runrequestedsimulation *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns__runrequestedsimulation);
	if (soap_out_ns__runrequestedsimulation(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__runrequestedsimulation(struct soap *soap, const char *tag, int id, const struct ns__runrequestedsimulation *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__runrequestedsimulation), type);
	soap_out_int(soap, "isimid", -1, &a->isimid, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct ns__runrequestedsimulation * SOAP_FMAC4 soap_get_ns__runrequestedsimulation(struct soap *soap, struct ns__runrequestedsimulation *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__runrequestedsimulation(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct ns__runrequestedsimulation * SOAP_FMAC4 soap_in_ns__runrequestedsimulation(struct soap *soap, const char *tag, struct ns__runrequestedsimulation *a, const char *type)
{
	short soap_flag_isimid = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct ns__runrequestedsimulation *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__runrequestedsimulation, sizeof(struct ns__runrequestedsimulation), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns__runrequestedsimulation(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_isimid && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "isimid", &a->isimid, "xsd:int"))
				{	soap_flag_isimid--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_isimid > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns__runrequestedsimulation *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_ns__runrequestedsimulation, 0, sizeof(struct ns__runrequestedsimulation), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns__runrequestedsimulation * SOAP_FMAC6 soap_new_ns__runrequestedsimulation(struct soap *soap, int n)
{	return soap_instantiate_ns__runrequestedsimulation(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns__runrequestedsimulation(struct soap *soap, struct ns__runrequestedsimulation *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns__runrequestedsimulation * SOAP_FMAC4 soap_instantiate_ns__runrequestedsimulation(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__runrequestedsimulation(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns__runrequestedsimulation, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns__runrequestedsimulation;
		if (size)
			*size = sizeof(struct ns__runrequestedsimulation);
	}
	else
	{	cp->ptr = (void*)new struct ns__runrequestedsimulation[n];
		if (size)
			*size = n * sizeof(struct ns__runrequestedsimulation);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns__runrequestedsimulation*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns__runrequestedsimulation(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns__runrequestedsimulation %p -> %p\n", q, p));
	*(struct ns__runrequestedsimulation*)p = *(struct ns__runrequestedsimulation*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__runrequestedsimulationResponse(struct soap *soap, const struct ns__runrequestedsimulationResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToint(soap, &a->istatus);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__runrequestedsimulationResponse(struct soap *soap, struct ns__runrequestedsimulationResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->istatus = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__runrequestedsimulationResponse(struct soap *soap, const struct ns__runrequestedsimulationResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns__runrequestedsimulationResponse);
	if (soap_out_ns__runrequestedsimulationResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__runrequestedsimulationResponse(struct soap *soap, const char *tag, int id, const struct ns__runrequestedsimulationResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__runrequestedsimulationResponse), type);
	if (a->istatus)
		soap_element_result(soap, "istatus");
	soap_out_PointerToint(soap, "istatus", -1, &a->istatus, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct ns__runrequestedsimulationResponse * SOAP_FMAC4 soap_get_ns__runrequestedsimulationResponse(struct soap *soap, struct ns__runrequestedsimulationResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__runrequestedsimulationResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct ns__runrequestedsimulationResponse * SOAP_FMAC4 soap_in_ns__runrequestedsimulationResponse(struct soap *soap, const char *tag, struct ns__runrequestedsimulationResponse *a, const char *type)
{
	short soap_flag_istatus = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct ns__runrequestedsimulationResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__runrequestedsimulationResponse, sizeof(struct ns__runrequestedsimulationResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns__runrequestedsimulationResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_istatus && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "istatus", &a->istatus, "xsd:int"))
				{	soap_flag_istatus--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns__runrequestedsimulationResponse *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_ns__runrequestedsimulationResponse, 0, sizeof(struct ns__runrequestedsimulationResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns__runrequestedsimulationResponse * SOAP_FMAC6 soap_new_ns__runrequestedsimulationResponse(struct soap *soap, int n)
{	return soap_instantiate_ns__runrequestedsimulationResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns__runrequestedsimulationResponse(struct soap *soap, struct ns__runrequestedsimulationResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns__runrequestedsimulationResponse * SOAP_FMAC4 soap_instantiate_ns__runrequestedsimulationResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__runrequestedsimulationResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns__runrequestedsimulationResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns__runrequestedsimulationResponse;
		if (size)
			*size = sizeof(struct ns__runrequestedsimulationResponse);
	}
	else
	{	cp->ptr = (void*)new struct ns__runrequestedsimulationResponse[n];
		if (size)
			*size = n * sizeof(struct ns__runrequestedsimulationResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns__runrequestedsimulationResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns__runrequestedsimulationResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns__runrequestedsimulationResponse %p -> %p\n", q, p));
	*(struct ns__runrequestedsimulationResponse*)p = *(struct ns__runrequestedsimulationResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__requestsimulation(struct soap *soap, const struct ns__requestsimulation *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->simfilecontent);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__requestsimulation(struct soap *soap, struct ns__requestsimulation *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->simfilecontent);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__requestsimulation(struct soap *soap, const struct ns__requestsimulation *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns__requestsimulation);
	if (soap_out_ns__requestsimulation(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__requestsimulation(struct soap *soap, const char *tag, int id, const struct ns__requestsimulation *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__requestsimulation), type);
	soap_out_string(soap, "simfilecontent", -1, &a->simfilecontent, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct ns__requestsimulation * SOAP_FMAC4 soap_get_ns__requestsimulation(struct soap *soap, struct ns__requestsimulation *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__requestsimulation(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct ns__requestsimulation * SOAP_FMAC4 soap_in_ns__requestsimulation(struct soap *soap, const char *tag, struct ns__requestsimulation *a, const char *type)
{
	short soap_flag_simfilecontent = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct ns__requestsimulation *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__requestsimulation, sizeof(struct ns__requestsimulation), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns__requestsimulation(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_simfilecontent && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "simfilecontent", &a->simfilecontent, "xsd:string"))
				{	soap_flag_simfilecontent--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns__requestsimulation *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_ns__requestsimulation, 0, sizeof(struct ns__requestsimulation), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns__requestsimulation * SOAP_FMAC6 soap_new_ns__requestsimulation(struct soap *soap, int n)
{	return soap_instantiate_ns__requestsimulation(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns__requestsimulation(struct soap *soap, struct ns__requestsimulation *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns__requestsimulation * SOAP_FMAC4 soap_instantiate_ns__requestsimulation(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__requestsimulation(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns__requestsimulation, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns__requestsimulation;
		if (size)
			*size = sizeof(struct ns__requestsimulation);
	}
	else
	{	cp->ptr = (void*)new struct ns__requestsimulation[n];
		if (size)
			*size = n * sizeof(struct ns__requestsimulation);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns__requestsimulation*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns__requestsimulation(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns__requestsimulation %p -> %p\n", q, p));
	*(struct ns__requestsimulation*)p = *(struct ns__requestsimulation*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__requestsimulationResponse(struct soap *soap, const struct ns__requestsimulationResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToint(soap, &a->isimid);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__requestsimulationResponse(struct soap *soap, struct ns__requestsimulationResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->isimid = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__requestsimulationResponse(struct soap *soap, const struct ns__requestsimulationResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns__requestsimulationResponse);
	if (soap_out_ns__requestsimulationResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__requestsimulationResponse(struct soap *soap, const char *tag, int id, const struct ns__requestsimulationResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__requestsimulationResponse), type);
	if (a->isimid)
		soap_element_result(soap, "isimid");
	soap_out_PointerToint(soap, "isimid", -1, &a->isimid, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct ns__requestsimulationResponse * SOAP_FMAC4 soap_get_ns__requestsimulationResponse(struct soap *soap, struct ns__requestsimulationResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__requestsimulationResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct ns__requestsimulationResponse * SOAP_FMAC4 soap_in_ns__requestsimulationResponse(struct soap *soap, const char *tag, struct ns__requestsimulationResponse *a, const char *type)
{
	short soap_flag_isimid = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct ns__requestsimulationResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__requestsimulationResponse, sizeof(struct ns__requestsimulationResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns__requestsimulationResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_isimid && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "isimid", &a->isimid, "xsd:int"))
				{	soap_flag_isimid--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns__requestsimulationResponse *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_ns__requestsimulationResponse, 0, sizeof(struct ns__requestsimulationResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns__requestsimulationResponse * SOAP_FMAC6 soap_new_ns__requestsimulationResponse(struct soap *soap, int n)
{	return soap_instantiate_ns__requestsimulationResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns__requestsimulationResponse(struct soap *soap, struct ns__requestsimulationResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns__requestsimulationResponse * SOAP_FMAC4 soap_instantiate_ns__requestsimulationResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__requestsimulationResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns__requestsimulationResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns__requestsimulationResponse;
		if (size)
			*size = sizeof(struct ns__requestsimulationResponse);
	}
	else
	{	cp->ptr = (void*)new struct ns__requestsimulationResponse[n];
		if (size)
			*size = n * sizeof(struct ns__requestsimulationResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns__requestsimulationResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns__requestsimulationResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns__requestsimulationResponse %p -> %p\n", q, p));
	*(struct ns__requestsimulationResponse*)p = *(struct ns__requestsimulationResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__runsimulation(struct soap *soap, const struct ns__runsimulation *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->id, SOAP_TYPE_int);
	soap_serialize_string(soap, &a->simfilecontent);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__runsimulation(struct soap *soap, struct ns__runsimulation *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->id);
	soap_default_string(soap, &a->simfilecontent);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__runsimulation(struct soap *soap, const struct ns__runsimulation *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns__runsimulation);
	if (soap_out_ns__runsimulation(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__runsimulation(struct soap *soap, const char *tag, int id, const struct ns__runsimulation *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__runsimulation), type);
	soap_out_int(soap, "id", -1, &a->id, "");
	soap_out_string(soap, "simfilecontent", -1, &a->simfilecontent, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct ns__runsimulation * SOAP_FMAC4 soap_get_ns__runsimulation(struct soap *soap, struct ns__runsimulation *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__runsimulation(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct ns__runsimulation * SOAP_FMAC4 soap_in_ns__runsimulation(struct soap *soap, const char *tag, struct ns__runsimulation *a, const char *type)
{
	short soap_flag_id = 1, soap_flag_simfilecontent = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct ns__runsimulation *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__runsimulation, sizeof(struct ns__runsimulation), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns__runsimulation(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_id && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "id", &a->id, "xsd:int"))
				{	soap_flag_id--;
					continue;
				}
			if (soap_flag_simfilecontent && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "simfilecontent", &a->simfilecontent, "xsd:string"))
				{	soap_flag_simfilecontent--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_id > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns__runsimulation *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_ns__runsimulation, 0, sizeof(struct ns__runsimulation), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns__runsimulation * SOAP_FMAC6 soap_new_ns__runsimulation(struct soap *soap, int n)
{	return soap_instantiate_ns__runsimulation(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns__runsimulation(struct soap *soap, struct ns__runsimulation *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns__runsimulation * SOAP_FMAC4 soap_instantiate_ns__runsimulation(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__runsimulation(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns__runsimulation, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns__runsimulation;
		if (size)
			*size = sizeof(struct ns__runsimulation);
	}
	else
	{	cp->ptr = (void*)new struct ns__runsimulation[n];
		if (size)
			*size = n * sizeof(struct ns__runsimulation);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns__runsimulation*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns__runsimulation(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns__runsimulation %p -> %p\n", q, p));
	*(struct ns__runsimulation*)p = *(struct ns__runsimulation*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__runsimulationResponse(struct soap *soap, const struct ns__runsimulationResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTostring(soap, &a->result);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__runsimulationResponse(struct soap *soap, struct ns__runsimulationResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->result = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__runsimulationResponse(struct soap *soap, const struct ns__runsimulationResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns__runsimulationResponse);
	if (soap_out_ns__runsimulationResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__runsimulationResponse(struct soap *soap, const char *tag, int id, const struct ns__runsimulationResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__runsimulationResponse), type);
	if (a->result)
		soap_element_result(soap, "result");
	soap_out_PointerTostring(soap, "result", -1, &a->result, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct ns__runsimulationResponse * SOAP_FMAC4 soap_get_ns__runsimulationResponse(struct soap *soap, struct ns__runsimulationResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__runsimulationResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct ns__runsimulationResponse * SOAP_FMAC4 soap_in_ns__runsimulationResponse(struct soap *soap, const char *tag, struct ns__runsimulationResponse *a, const char *type)
{
	short soap_flag_result = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct ns__runsimulationResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__runsimulationResponse, sizeof(struct ns__runsimulationResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns__runsimulationResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTostring(soap, "result", &a->result, "xsd:string"))
				{	soap_flag_result--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns__runsimulationResponse *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_ns__runsimulationResponse, 0, sizeof(struct ns__runsimulationResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns__runsimulationResponse * SOAP_FMAC6 soap_new_ns__runsimulationResponse(struct soap *soap, int n)
{	return soap_instantiate_ns__runsimulationResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns__runsimulationResponse(struct soap *soap, struct ns__runsimulationResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns__runsimulationResponse * SOAP_FMAC4 soap_instantiate_ns__runsimulationResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__runsimulationResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns__runsimulationResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns__runsimulationResponse;
		if (size)
			*size = sizeof(struct ns__runsimulationResponse);
	}
	else
	{	cp->ptr = (void*)new struct ns__runsimulationResponse[n];
		if (size)
			*size = n * sizeof(struct ns__runsimulationResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns__runsimulationResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns__runsimulationResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns__runsimulationResponse %p -> %p\n", q, p));
	*(struct ns__runsimulationResponse*)p = *(struct ns__runsimulationResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__runsimulationstep(struct soap *soap, const struct ns__runsimulationstep *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->id, SOAP_TYPE_int);
	soap_embedded(soap, &a->istepnum, SOAP_TYPE_int);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__runsimulationstep(struct soap *soap, struct ns__runsimulationstep *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->id);
	soap_default_int(soap, &a->istepnum);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__runsimulationstep(struct soap *soap, const struct ns__runsimulationstep *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns__runsimulationstep);
	if (soap_out_ns__runsimulationstep(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__runsimulationstep(struct soap *soap, const char *tag, int id, const struct ns__runsimulationstep *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__runsimulationstep), type);
	soap_out_int(soap, "id", -1, &a->id, "");
	soap_out_int(soap, "istepnum", -1, &a->istepnum, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct ns__runsimulationstep * SOAP_FMAC4 soap_get_ns__runsimulationstep(struct soap *soap, struct ns__runsimulationstep *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__runsimulationstep(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct ns__runsimulationstep * SOAP_FMAC4 soap_in_ns__runsimulationstep(struct soap *soap, const char *tag, struct ns__runsimulationstep *a, const char *type)
{
	short soap_flag_id = 1, soap_flag_istepnum = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct ns__runsimulationstep *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__runsimulationstep, sizeof(struct ns__runsimulationstep), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns__runsimulationstep(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_id && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "id", &a->id, "xsd:int"))
				{	soap_flag_id--;
					continue;
				}
			if (soap_flag_istepnum && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "istepnum", &a->istepnum, "xsd:int"))
				{	soap_flag_istepnum--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_id > 0 || soap_flag_istepnum > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns__runsimulationstep *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_ns__runsimulationstep, 0, sizeof(struct ns__runsimulationstep), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns__runsimulationstep * SOAP_FMAC6 soap_new_ns__runsimulationstep(struct soap *soap, int n)
{	return soap_instantiate_ns__runsimulationstep(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns__runsimulationstep(struct soap *soap, struct ns__runsimulationstep *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns__runsimulationstep * SOAP_FMAC4 soap_instantiate_ns__runsimulationstep(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__runsimulationstep(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns__runsimulationstep, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns__runsimulationstep;
		if (size)
			*size = sizeof(struct ns__runsimulationstep);
	}
	else
	{	cp->ptr = (void*)new struct ns__runsimulationstep[n];
		if (size)
			*size = n * sizeof(struct ns__runsimulationstep);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns__runsimulationstep*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns__runsimulationstep(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns__runsimulationstep %p -> %p\n", q, p));
	*(struct ns__runsimulationstep*)p = *(struct ns__runsimulationstep*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__runsimulationstepResponse(struct soap *soap, const struct ns__runsimulationstepResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToint(soap, &a->status);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__runsimulationstepResponse(struct soap *soap, struct ns__runsimulationstepResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->status = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__runsimulationstepResponse(struct soap *soap, const struct ns__runsimulationstepResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns__runsimulationstepResponse);
	if (soap_out_ns__runsimulationstepResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__runsimulationstepResponse(struct soap *soap, const char *tag, int id, const struct ns__runsimulationstepResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__runsimulationstepResponse), type);
	if (a->status)
		soap_element_result(soap, "status");
	soap_out_PointerToint(soap, "status", -1, &a->status, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct ns__runsimulationstepResponse * SOAP_FMAC4 soap_get_ns__runsimulationstepResponse(struct soap *soap, struct ns__runsimulationstepResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__runsimulationstepResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct ns__runsimulationstepResponse * SOAP_FMAC4 soap_in_ns__runsimulationstepResponse(struct soap *soap, const char *tag, struct ns__runsimulationstepResponse *a, const char *type)
{
	short soap_flag_status = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct ns__runsimulationstepResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__runsimulationstepResponse, sizeof(struct ns__runsimulationstepResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns__runsimulationstepResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_status && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "status", &a->status, "xsd:int"))
				{	soap_flag_status--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns__runsimulationstepResponse *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_ns__runsimulationstepResponse, 0, sizeof(struct ns__runsimulationstepResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns__runsimulationstepResponse * SOAP_FMAC6 soap_new_ns__runsimulationstepResponse(struct soap *soap, int n)
{	return soap_instantiate_ns__runsimulationstepResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns__runsimulationstepResponse(struct soap *soap, struct ns__runsimulationstepResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns__runsimulationstepResponse * SOAP_FMAC4 soap_instantiate_ns__runsimulationstepResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__runsimulationstepResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns__runsimulationstepResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns__runsimulationstepResponse;
		if (size)
			*size = sizeof(struct ns__runsimulationstepResponse);
	}
	else
	{	cp->ptr = (void*)new struct ns__runsimulationstepResponse[n];
		if (size)
			*size = n * sizeof(struct ns__runsimulationstepResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns__runsimulationstepResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns__runsimulationstepResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns__runsimulationstepResponse %p -> %p\n", q, p));
	*(struct ns__runsimulationstepResponse*)p = *(struct ns__runsimulationstepResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__setnsteps(struct soap *soap, const struct ns__setnsteps *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->id, SOAP_TYPE_int);
	soap_embedded(soap, &a->newnsteps, SOAP_TYPE_int);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__setnsteps(struct soap *soap, struct ns__setnsteps *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->id);
	soap_default_int(soap, &a->newnsteps);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__setnsteps(struct soap *soap, const struct ns__setnsteps *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns__setnsteps);
	if (soap_out_ns__setnsteps(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__setnsteps(struct soap *soap, const char *tag, int id, const struct ns__setnsteps *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__setnsteps), type);
	soap_out_int(soap, "id", -1, &a->id, "");
	soap_out_int(soap, "newnsteps", -1, &a->newnsteps, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct ns__setnsteps * SOAP_FMAC4 soap_get_ns__setnsteps(struct soap *soap, struct ns__setnsteps *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__setnsteps(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct ns__setnsteps * SOAP_FMAC4 soap_in_ns__setnsteps(struct soap *soap, const char *tag, struct ns__setnsteps *a, const char *type)
{
	short soap_flag_id = 1, soap_flag_newnsteps = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct ns__setnsteps *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__setnsteps, sizeof(struct ns__setnsteps), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns__setnsteps(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_id && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "id", &a->id, "xsd:int"))
				{	soap_flag_id--;
					continue;
				}
			if (soap_flag_newnsteps && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "newnsteps", &a->newnsteps, "xsd:int"))
				{	soap_flag_newnsteps--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_id > 0 || soap_flag_newnsteps > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns__setnsteps *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_ns__setnsteps, 0, sizeof(struct ns__setnsteps), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns__setnsteps * SOAP_FMAC6 soap_new_ns__setnsteps(struct soap *soap, int n)
{	return soap_instantiate_ns__setnsteps(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns__setnsteps(struct soap *soap, struct ns__setnsteps *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns__setnsteps * SOAP_FMAC4 soap_instantiate_ns__setnsteps(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__setnsteps(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns__setnsteps, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns__setnsteps;
		if (size)
			*size = sizeof(struct ns__setnsteps);
	}
	else
	{	cp->ptr = (void*)new struct ns__setnsteps[n];
		if (size)
			*size = n * sizeof(struct ns__setnsteps);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns__setnsteps*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns__setnsteps(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns__setnsteps %p -> %p\n", q, p));
	*(struct ns__setnsteps*)p = *(struct ns__setnsteps*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__setnstepsResponse(struct soap *soap, const struct ns__setnstepsResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToint(soap, &a->nsteps);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__setnstepsResponse(struct soap *soap, struct ns__setnstepsResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->nsteps = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__setnstepsResponse(struct soap *soap, const struct ns__setnstepsResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns__setnstepsResponse);
	if (soap_out_ns__setnstepsResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__setnstepsResponse(struct soap *soap, const char *tag, int id, const struct ns__setnstepsResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__setnstepsResponse), type);
	if (a->nsteps)
		soap_element_result(soap, "nsteps");
	soap_out_PointerToint(soap, "nsteps", -1, &a->nsteps, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct ns__setnstepsResponse * SOAP_FMAC4 soap_get_ns__setnstepsResponse(struct soap *soap, struct ns__setnstepsResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__setnstepsResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct ns__setnstepsResponse * SOAP_FMAC4 soap_in_ns__setnstepsResponse(struct soap *soap, const char *tag, struct ns__setnstepsResponse *a, const char *type)
{
	short soap_flag_nsteps = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct ns__setnstepsResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__setnstepsResponse, sizeof(struct ns__setnstepsResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns__setnstepsResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_nsteps && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "nsteps", &a->nsteps, "xsd:int"))
				{	soap_flag_nsteps--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns__setnstepsResponse *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_ns__setnstepsResponse, 0, sizeof(struct ns__setnstepsResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns__setnstepsResponse * SOAP_FMAC6 soap_new_ns__setnstepsResponse(struct soap *soap, int n)
{	return soap_instantiate_ns__setnstepsResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns__setnstepsResponse(struct soap *soap, struct ns__setnstepsResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns__setnstepsResponse * SOAP_FMAC4 soap_instantiate_ns__setnstepsResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__setnstepsResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns__setnstepsResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns__setnstepsResponse;
		if (size)
			*size = sizeof(struct ns__setnstepsResponse);
	}
	else
	{	cp->ptr = (void*)new struct ns__setnstepsResponse[n];
		if (size)
			*size = n * sizeof(struct ns__setnstepsResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns__setnstepsResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns__setnstepsResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns__setnstepsResponse %p -> %p\n", q, p));
	*(struct ns__setnstepsResponse*)p = *(struct ns__setnstepsResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__getnsteps(struct soap *soap, const struct ns__getnsteps *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->id, SOAP_TYPE_int);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__getnsteps(struct soap *soap, struct ns__getnsteps *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->id);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__getnsteps(struct soap *soap, const struct ns__getnsteps *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns__getnsteps);
	if (soap_out_ns__getnsteps(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__getnsteps(struct soap *soap, const char *tag, int id, const struct ns__getnsteps *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__getnsteps), type);
	soap_out_int(soap, "id", -1, &a->id, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct ns__getnsteps * SOAP_FMAC4 soap_get_ns__getnsteps(struct soap *soap, struct ns__getnsteps *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__getnsteps(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct ns__getnsteps * SOAP_FMAC4 soap_in_ns__getnsteps(struct soap *soap, const char *tag, struct ns__getnsteps *a, const char *type)
{
	short soap_flag_id = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct ns__getnsteps *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__getnsteps, sizeof(struct ns__getnsteps), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns__getnsteps(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_id && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "id", &a->id, "xsd:int"))
				{	soap_flag_id--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_id > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns__getnsteps *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_ns__getnsteps, 0, sizeof(struct ns__getnsteps), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns__getnsteps * SOAP_FMAC6 soap_new_ns__getnsteps(struct soap *soap, int n)
{	return soap_instantiate_ns__getnsteps(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns__getnsteps(struct soap *soap, struct ns__getnsteps *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns__getnsteps * SOAP_FMAC4 soap_instantiate_ns__getnsteps(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__getnsteps(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns__getnsteps, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns__getnsteps;
		if (size)
			*size = sizeof(struct ns__getnsteps);
	}
	else
	{	cp->ptr = (void*)new struct ns__getnsteps[n];
		if (size)
			*size = n * sizeof(struct ns__getnsteps);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns__getnsteps*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns__getnsteps(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns__getnsteps %p -> %p\n", q, p));
	*(struct ns__getnsteps*)p = *(struct ns__getnsteps*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__getnstepsResponse(struct soap *soap, const struct ns__getnstepsResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToint(soap, &a->nsstep);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__getnstepsResponse(struct soap *soap, struct ns__getnstepsResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->nsstep = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__getnstepsResponse(struct soap *soap, const struct ns__getnstepsResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns__getnstepsResponse);
	if (soap_out_ns__getnstepsResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__getnstepsResponse(struct soap *soap, const char *tag, int id, const struct ns__getnstepsResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__getnstepsResponse), type);
	if (a->nsstep)
		soap_element_result(soap, "nsstep");
	soap_out_PointerToint(soap, "nsstep", -1, &a->nsstep, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct ns__getnstepsResponse * SOAP_FMAC4 soap_get_ns__getnstepsResponse(struct soap *soap, struct ns__getnstepsResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__getnstepsResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct ns__getnstepsResponse * SOAP_FMAC4 soap_in_ns__getnstepsResponse(struct soap *soap, const char *tag, struct ns__getnstepsResponse *a, const char *type)
{
	short soap_flag_nsstep = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct ns__getnstepsResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__getnstepsResponse, sizeof(struct ns__getnstepsResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns__getnstepsResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_nsstep && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "nsstep", &a->nsstep, "xsd:int"))
				{	soap_flag_nsstep--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns__getnstepsResponse *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_ns__getnstepsResponse, 0, sizeof(struct ns__getnstepsResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns__getnstepsResponse * SOAP_FMAC6 soap_new_ns__getnstepsResponse(struct soap *soap, int n)
{	return soap_instantiate_ns__getnstepsResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns__getnstepsResponse(struct soap *soap, struct ns__getnstepsResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns__getnstepsResponse * SOAP_FMAC4 soap_instantiate_ns__getnstepsResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__getnstepsResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns__getnstepsResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns__getnstepsResponse;
		if (size)
			*size = sizeof(struct ns__getnstepsResponse);
	}
	else
	{	cp->ptr = (void*)new struct ns__getnstepsResponse[n];
		if (size)
			*size = n * sizeof(struct ns__getnstepsResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns__getnstepsResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns__getnstepsResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns__getnstepsResponse %p -> %p\n", q, p));
	*(struct ns__getnstepsResponse*)p = *(struct ns__getnstepsResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__setstep(struct soap *soap, const struct ns__setstep *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->id, SOAP_TYPE_int);
	soap_embedded(soap, &a->newstep, SOAP_TYPE_int);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__setstep(struct soap *soap, struct ns__setstep *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->id);
	soap_default_int(soap, &a->newstep);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__setstep(struct soap *soap, const struct ns__setstep *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns__setstep);
	if (soap_out_ns__setstep(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__setstep(struct soap *soap, const char *tag, int id, const struct ns__setstep *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__setstep), type);
	soap_out_int(soap, "id", -1, &a->id, "");
	soap_out_int(soap, "newstep", -1, &a->newstep, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct ns__setstep * SOAP_FMAC4 soap_get_ns__setstep(struct soap *soap, struct ns__setstep *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__setstep(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct ns__setstep * SOAP_FMAC4 soap_in_ns__setstep(struct soap *soap, const char *tag, struct ns__setstep *a, const char *type)
{
	short soap_flag_id = 1, soap_flag_newstep = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct ns__setstep *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__setstep, sizeof(struct ns__setstep), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns__setstep(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_id && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "id", &a->id, "xsd:int"))
				{	soap_flag_id--;
					continue;
				}
			if (soap_flag_newstep && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "newstep", &a->newstep, "xsd:int"))
				{	soap_flag_newstep--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_id > 0 || soap_flag_newstep > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns__setstep *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_ns__setstep, 0, sizeof(struct ns__setstep), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns__setstep * SOAP_FMAC6 soap_new_ns__setstep(struct soap *soap, int n)
{	return soap_instantiate_ns__setstep(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns__setstep(struct soap *soap, struct ns__setstep *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns__setstep * SOAP_FMAC4 soap_instantiate_ns__setstep(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__setstep(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns__setstep, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns__setstep;
		if (size)
			*size = sizeof(struct ns__setstep);
	}
	else
	{	cp->ptr = (void*)new struct ns__setstep[n];
		if (size)
			*size = n * sizeof(struct ns__setstep);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns__setstep*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns__setstep(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns__setstep %p -> %p\n", q, p));
	*(struct ns__setstep*)p = *(struct ns__setstep*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__setstepResponse(struct soap *soap, const struct ns__setstepResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToint(soap, &a->step);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__setstepResponse(struct soap *soap, struct ns__setstepResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->step = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__setstepResponse(struct soap *soap, const struct ns__setstepResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns__setstepResponse);
	if (soap_out_ns__setstepResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__setstepResponse(struct soap *soap, const char *tag, int id, const struct ns__setstepResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__setstepResponse), type);
	if (a->step)
		soap_element_result(soap, "step");
	soap_out_PointerToint(soap, "step", -1, &a->step, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct ns__setstepResponse * SOAP_FMAC4 soap_get_ns__setstepResponse(struct soap *soap, struct ns__setstepResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__setstepResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct ns__setstepResponse * SOAP_FMAC4 soap_in_ns__setstepResponse(struct soap *soap, const char *tag, struct ns__setstepResponse *a, const char *type)
{
	short soap_flag_step = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct ns__setstepResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__setstepResponse, sizeof(struct ns__setstepResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns__setstepResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_step && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "step", &a->step, "xsd:int"))
				{	soap_flag_step--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns__setstepResponse *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_ns__setstepResponse, 0, sizeof(struct ns__setstepResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns__setstepResponse * SOAP_FMAC6 soap_new_ns__setstepResponse(struct soap *soap, int n)
{	return soap_instantiate_ns__setstepResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns__setstepResponse(struct soap *soap, struct ns__setstepResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns__setstepResponse * SOAP_FMAC4 soap_instantiate_ns__setstepResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__setstepResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns__setstepResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns__setstepResponse;
		if (size)
			*size = sizeof(struct ns__setstepResponse);
	}
	else
	{	cp->ptr = (void*)new struct ns__setstepResponse[n];
		if (size)
			*size = n * sizeof(struct ns__setstepResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns__setstepResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns__setstepResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns__setstepResponse %p -> %p\n", q, p));
	*(struct ns__setstepResponse*)p = *(struct ns__setstepResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__getstep(struct soap *soap, const struct ns__getstep *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->id, SOAP_TYPE_int);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__getstep(struct soap *soap, struct ns__getstep *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->id);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__getstep(struct soap *soap, const struct ns__getstep *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns__getstep);
	if (soap_out_ns__getstep(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__getstep(struct soap *soap, const char *tag, int id, const struct ns__getstep *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__getstep), type);
	soap_out_int(soap, "id", -1, &a->id, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct ns__getstep * SOAP_FMAC4 soap_get_ns__getstep(struct soap *soap, struct ns__getstep *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__getstep(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct ns__getstep * SOAP_FMAC4 soap_in_ns__getstep(struct soap *soap, const char *tag, struct ns__getstep *a, const char *type)
{
	short soap_flag_id = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct ns__getstep *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__getstep, sizeof(struct ns__getstep), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns__getstep(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_id && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "id", &a->id, "xsd:int"))
				{	soap_flag_id--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_id > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns__getstep *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_ns__getstep, 0, sizeof(struct ns__getstep), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns__getstep * SOAP_FMAC6 soap_new_ns__getstep(struct soap *soap, int n)
{	return soap_instantiate_ns__getstep(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns__getstep(struct soap *soap, struct ns__getstep *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns__getstep * SOAP_FMAC4 soap_instantiate_ns__getstep(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__getstep(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns__getstep, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns__getstep;
		if (size)
			*size = sizeof(struct ns__getstep);
	}
	else
	{	cp->ptr = (void*)new struct ns__getstep[n];
		if (size)
			*size = n * sizeof(struct ns__getstep);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns__getstep*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns__getstep(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns__getstep %p -> %p\n", q, p));
	*(struct ns__getstep*)p = *(struct ns__getstep*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__getstepResponse(struct soap *soap, const struct ns__getstepResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToint(soap, &a->step);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__getstepResponse(struct soap *soap, struct ns__getstepResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->step = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__getstepResponse(struct soap *soap, const struct ns__getstepResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns__getstepResponse);
	if (soap_out_ns__getstepResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__getstepResponse(struct soap *soap, const char *tag, int id, const struct ns__getstepResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__getstepResponse), type);
	if (a->step)
		soap_element_result(soap, "step");
	soap_out_PointerToint(soap, "step", -1, &a->step, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct ns__getstepResponse * SOAP_FMAC4 soap_get_ns__getstepResponse(struct soap *soap, struct ns__getstepResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__getstepResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct ns__getstepResponse * SOAP_FMAC4 soap_in_ns__getstepResponse(struct soap *soap, const char *tag, struct ns__getstepResponse *a, const char *type)
{
	short soap_flag_step = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct ns__getstepResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__getstepResponse, sizeof(struct ns__getstepResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns__getstepResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_step && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "step", &a->step, "xsd:int"))
				{	soap_flag_step--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns__getstepResponse *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_ns__getstepResponse, 0, sizeof(struct ns__getstepResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns__getstepResponse * SOAP_FMAC6 soap_new_ns__getstepResponse(struct soap *soap, int n)
{	return soap_instantiate_ns__getstepResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns__getstepResponse(struct soap *soap, struct ns__getstepResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns__getstepResponse * SOAP_FMAC4 soap_instantiate_ns__getstepResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__getstepResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns__getstepResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns__getstepResponse;
		if (size)
			*size = sizeof(struct ns__getstepResponse);
	}
	else
	{	cp->ptr = (void*)new struct ns__getstepResponse[n];
		if (size)
			*size = n * sizeof(struct ns__getstepResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns__getstepResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns__getstepResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns__getstepResponse %p -> %p\n", q, p));
	*(struct ns__getstepResponse*)p = *(struct ns__getstepResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__add(struct soap *soap, const struct ns__add *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->a, SOAP_TYPE_double);
	soap_embedded(soap, &a->b, SOAP_TYPE_double);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__add(struct soap *soap, struct ns__add *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_double(soap, &a->a);
	soap_default_double(soap, &a->b);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__add(struct soap *soap, const struct ns__add *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns__add);
	if (soap_out_ns__add(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__add(struct soap *soap, const char *tag, int id, const struct ns__add *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__add), type);
	soap_out_double(soap, "a", -1, &a->a, "");
	soap_out_double(soap, "b", -1, &a->b, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct ns__add * SOAP_FMAC4 soap_get_ns__add(struct soap *soap, struct ns__add *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__add(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct ns__add * SOAP_FMAC4 soap_in_ns__add(struct soap *soap, const char *tag, struct ns__add *a, const char *type)
{
	short soap_flag_a = 1, soap_flag_b = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct ns__add *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__add, sizeof(struct ns__add), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns__add(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_a && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "a", &a->a, "xsd:double"))
				{	soap_flag_a--;
					continue;
				}
			if (soap_flag_b && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "b", &a->b, "xsd:double"))
				{	soap_flag_b--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_a > 0 || soap_flag_b > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns__add *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_ns__add, 0, sizeof(struct ns__add), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns__add * SOAP_FMAC6 soap_new_ns__add(struct soap *soap, int n)
{	return soap_instantiate_ns__add(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns__add(struct soap *soap, struct ns__add *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns__add * SOAP_FMAC4 soap_instantiate_ns__add(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__add(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns__add, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns__add;
		if (size)
			*size = sizeof(struct ns__add);
	}
	else
	{	cp->ptr = (void*)new struct ns__add[n];
		if (size)
			*size = n * sizeof(struct ns__add);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns__add*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns__add(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns__add %p -> %p\n", q, p));
	*(struct ns__add*)p = *(struct ns__add*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__addResponse(struct soap *soap, const struct ns__addResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTodouble(soap, &a->result);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__addResponse(struct soap *soap, struct ns__addResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->result = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__addResponse(struct soap *soap, const struct ns__addResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns__addResponse);
	if (soap_out_ns__addResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__addResponse(struct soap *soap, const char *tag, int id, const struct ns__addResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__addResponse), type);
	if (a->result)
		soap_element_result(soap, "result");
	soap_out_PointerTodouble(soap, "result", -1, &a->result, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct ns__addResponse * SOAP_FMAC4 soap_get_ns__addResponse(struct soap *soap, struct ns__addResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__addResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct ns__addResponse * SOAP_FMAC4 soap_in_ns__addResponse(struct soap *soap, const char *tag, struct ns__addResponse *a, const char *type)
{
	short soap_flag_result = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct ns__addResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__addResponse, sizeof(struct ns__addResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns__addResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTodouble(soap, "result", &a->result, "xsd:double"))
				{	soap_flag_result--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns__addResponse *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_ns__addResponse, 0, sizeof(struct ns__addResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns__addResponse * SOAP_FMAC6 soap_new_ns__addResponse(struct soap *soap, int n)
{	return soap_instantiate_ns__addResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns__addResponse(struct soap *soap, struct ns__addResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns__addResponse * SOAP_FMAC4 soap_instantiate_ns__addResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__addResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns__addResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns__addResponse;
		if (size)
			*size = sizeof(struct ns__addResponse);
	}
	else
	{	cp->ptr = (void*)new struct ns__addResponse[n];
		if (size)
			*size = n * sizeof(struct ns__addResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns__addResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns__addResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns__addResponse %p -> %p\n", q, p));
	*(struct ns__addResponse*)p = *(struct ns__addResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_fdata(struct soap *soap, struct fdata const*a)
{
	int i;
	if (a->__ptr && !soap_array_reference(soap, a, (struct soap_array*)&a->__ptr, 1, SOAP_TYPE_fdata))
		for (i = 0; i < a->__size; i++)
		{	soap_embedded(soap, a->__ptr + i, SOAP_TYPE_double);
		}
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_fdata(struct soap *soap, struct fdata *a)
{
	a->__size = 0;
	a->__ptr = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_fdata(struct soap *soap, const struct fdata *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, (struct soap_array*)&a->__ptr, 1, tag, SOAP_TYPE_fdata);
	if (soap_out_fdata(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_fdata(struct soap *soap, const char *tag, int id, const struct fdata *a, const char *type)
{
	int i, n = a->__size;
	char *t = soap_putsize(soap, "xsd:double", a->__size);
	id = soap_element_id(soap, tag, id, a, (struct soap_array*)&a->__ptr, 1, type, SOAP_TYPE_fdata);
	if (id < 0)
		return soap->error;
	soap_array_begin_out(soap, tag, id, t, NULL);
	for (i = 0; i < n; i++)
	{
		soap->position = 1;
		soap->positions[0] = i;
		soap_out_double(soap, "item", -1, &a->__ptr[i], "");
	}
	soap->position = 0;
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct fdata * SOAP_FMAC4 soap_get_fdata(struct soap *soap, struct fdata *p, const char *tag, const char *type)
{
	if ((p = soap_in_fdata(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct fdata * SOAP_FMAC4 soap_in_fdata(struct soap *soap, const char *tag, struct fdata *a, const char *type)
{	int i, j;
	double *p;
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (soap_match_array(soap, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct fdata *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_fdata, sizeof(struct fdata), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_fdata(soap, a);
	if (soap->body && !*soap->href)
	{
		a->__size = soap_getsize(soap->arraySize, soap->arrayOffset, &j);
		if (a->__size >= 0)
		{	a->__ptr = (double *)soap_malloc(soap, sizeof(double) * a->__size);
			for (i = 0; i < a->__size; i++)
				soap_default_double(soap, a->__ptr+i);
			for (i = 0; i < a->__size; i++)
			{	soap_peek_element(soap);
				if (soap->position)
				{	i = soap->positions[0]-j;
					if (i < 0 || i >= a->__size)
					{	soap->error = SOAP_IOB;
						return NULL;
					}
				}
				if (!soap_in_double(soap, NULL, a->__ptr + i, "xsd:double"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
		}
		else
		{	soap_new_block(soap);
			for (a->__size = 0; ; a->__size++)
			{	p = (double *)soap_push_block(soap, sizeof(double));
				if (!p)
					return NULL;
				soap_default_double(soap, p);
				if (!soap_in_double(soap, NULL, p, "xsd:double"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
			soap_pop_block(soap);
			a->__ptr = (double *)soap_malloc(soap, soap->blist->size);
			soap_save_block(soap, (char*)a->__ptr, 1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct fdata *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_fdata, 0, sizeof(struct fdata), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct fdata * SOAP_FMAC6 soap_new_fdata(struct soap *soap, int n)
{	return soap_instantiate_fdata(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_fdata(struct soap *soap, struct fdata *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct fdata * SOAP_FMAC4 soap_instantiate_fdata(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_fdata(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_fdata, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct fdata;
		if (size)
			*size = sizeof(struct fdata);
	}
	else
	{	cp->ptr = (void*)new struct fdata[n];
		if (size)
			*size = n * sizeof(struct fdata);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct fdata*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_fdata(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct fdata %p -> %p\n", q, p));
	*(struct fdata*)p = *(struct fdata*)q;
}

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Reason))
		soap_serialize_SOAP_ENV__Reason(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToSOAP_ENV__Reason);
	if (soap_out_PointerToSOAP_ENV__Reason(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Reason(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Reason *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Reason);
	if (id < 0)
		return soap->error;
	return soap_out_SOAP_ENV__Reason(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Reason ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Reason(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct SOAP_ENV__Reason ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Reason(struct soap *soap, const char *tag, struct SOAP_ENV__Reason **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Reason **)soap_malloc(soap, sizeof(struct SOAP_ENV__Reason *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Reason(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Reason **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Reason, sizeof(struct SOAP_ENV__Reason), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Detail))
		soap_serialize_SOAP_ENV__Detail(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToSOAP_ENV__Detail);
	if (soap_out_PointerToSOAP_ENV__Detail(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Detail(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Detail *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Detail);
	if (id < 0)
		return soap->error;
	return soap_out_SOAP_ENV__Detail(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Detail ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Detail(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct SOAP_ENV__Detail ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Detail(struct soap *soap, const char *tag, struct SOAP_ENV__Detail **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Detail **)soap_malloc(soap, sizeof(struct SOAP_ENV__Detail *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Detail(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Detail **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Detail, sizeof(struct SOAP_ENV__Detail), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Code))
		soap_serialize_SOAP_ENV__Code(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToSOAP_ENV__Code);
	if (soap_out_PointerToSOAP_ENV__Code(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Code(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Code *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Code);
	if (id < 0)
		return soap->error;
	return soap_out_SOAP_ENV__Code(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Code ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Code(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct SOAP_ENV__Code ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Code(struct soap *soap, const char *tag, struct SOAP_ENV__Code **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Code **)soap_malloc(soap, sizeof(struct SOAP_ENV__Code *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Code(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Code **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Code, sizeof(struct SOAP_ENV__Code), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTofdata(struct soap *soap, struct fdata **const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_PointerTofdata))
		soap_serialize_PointerTofdata(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTofdata(struct soap *soap, struct fdata **const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTofdata);
	if (soap_out_PointerToPointerTofdata(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerTofdata(struct soap *soap, const char *tag, int id, struct fdata **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTofdata);
	if (id < 0)
		return soap->error;
	return soap_out_PointerTofdata(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct fdata *** SOAP_FMAC4 soap_get_PointerToPointerTofdata(struct soap *soap, struct fdata ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPointerTofdata(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct fdata *** SOAP_FMAC4 soap_in_PointerToPointerTofdata(struct soap *soap, const char *tag, struct fdata ***a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (struct fdata ***)soap_malloc(soap, sizeof(struct fdata **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_PointerTofdata(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct fdata ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTofdata, sizeof(struct fdata *), 1);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTofdata(struct soap *soap, struct fdata *const*a)
{
	if (*a)
		soap_serialize_fdata(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTofdata(struct soap *soap, struct fdata *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTofdata);
	if (soap_out_PointerTofdata(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTofdata(struct soap *soap, const char *tag, int id, struct fdata *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, (struct soap_array*)&(*a)->__ptr, 1, type, SOAP_TYPE_fdata);
	if (id < 0)
		return soap->error;
	return soap_out_fdata(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct fdata ** SOAP_FMAC4 soap_get_PointerTofdata(struct soap *soap, struct fdata **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTofdata(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct fdata ** SOAP_FMAC4 soap_in_PointerTofdata(struct soap *soap, const char *tag, struct fdata **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (struct fdata **)soap_malloc(soap, sizeof(struct fdata *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_fdata(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct fdata **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_fdata, sizeof(struct fdata), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTostring(struct soap *soap, char **const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_string))
		soap_serialize_string(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTostring(struct soap *soap, char **const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTostring);
	if (soap_out_PointerTostring(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTostring(struct soap *soap, const char *tag, int id, char **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_string);
	if (id < 0)
		return soap->error;
	return soap_out_string(soap, tag, id, *a, type);
}

SOAP_FMAC3 char *** SOAP_FMAC4 soap_get_PointerTostring(struct soap *soap, char ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTostring(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 char *** SOAP_FMAC4 soap_in_PointerTostring(struct soap *soap, const char *tag, char ***a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (char ***)soap_malloc(soap, sizeof(char **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_string(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (char ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_string, sizeof(char *), 1);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToint(struct soap *soap, int *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_int);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToint(struct soap *soap, int *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToint);
	if (soap_out_PointerToint(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToint(struct soap *soap, const char *tag, int id, int *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_int);
	if (id < 0)
		return soap->error;
	return soap_out_int(soap, tag, id, *a, type);
}

SOAP_FMAC3 int ** SOAP_FMAC4 soap_get_PointerToint(struct soap *soap, int **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToint(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 int ** SOAP_FMAC4 soap_in_PointerToint(struct soap *soap, const char *tag, int **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (int **)soap_malloc(soap, sizeof(int *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_int(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (int **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_int, sizeof(int), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTodouble(struct soap *soap, double *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_double);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTodouble(struct soap *soap, double *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTodouble);
	if (soap_out_PointerTodouble(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTodouble(struct soap *soap, const char *tag, int id, double *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_double);
	if (id < 0)
		return soap->error;
	return soap_out_double(soap, tag, id, *a, type);
}

SOAP_FMAC3 double ** SOAP_FMAC4 soap_get_PointerTodouble(struct soap *soap, double **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTodouble(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 double ** SOAP_FMAC4 soap_in_PointerTodouble(struct soap *soap, const char *tag, double **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (double **)soap_malloc(soap, sizeof(double *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_double(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (double **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_double, sizeof(double), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__QName(struct soap *soap, char **a)
{	soap_default_string(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__QName(struct soap *soap, char *const*a)
{	soap_serialize_string(soap, a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__QName(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__QName);
	if (soap_out__QName(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__QName(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE__QName);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get__QName(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in__QName(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in__QName(struct soap *soap, const char *tag, char **a, const char *type)
{
	return soap_instring(soap, tag, a, type, SOAP_TYPE__QName, 2, -1, -1);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_string(struct soap *soap, char **a)
{	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_string
	*a = SOAP_DEFAULT_string;
#else
	*a = (char *)0;
#endif
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_string(struct soap *soap, char *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_string);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_string(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_string);
	if (soap_out_string(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_string(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_string);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_string(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_string(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_string(struct soap *soap, const char *tag, char **a, const char *type)
{
	return soap_instring(soap, tag, a, type, SOAP_TYPE_string, 1, -1, -1);
}

/* End of soapC.cpp */
